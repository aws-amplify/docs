---
title: DataStore
---
{% if jekyll.environment == 'production' %}
  {% assign base_dir = site.amplify.docs_baseurl %}
{% endif %}
{% assign media_base = base_dir | append: page.dir | append: "media" %}
{% assign common_media = base_dir | append: "/images" %}

<br />

**Note**
Amplify Android is in preview mode and is not intended for production usage at this time. We welcome feedback to improve your experience in using Amplify Android.
{: .callout .callout--warning}

# DataStore

Amplify DataStore provides a persistent on-device storage repository for you to write, read, and observe changes to your application data. DataStore works both online and offline. When online, DataStore seamlessly synchronizes data with the cloud, and across devices. You model your application data by defining types in the GraphQL schema definition language (SDL). This schema is automatically converted to Java-language **Model** classes that you can code into your business logic. You can use DataStore for offline use cases in a "local only" mode. In local-only mode, you do not need an AWS account, nor do you need to provision any AppSync or DynamoDB resources. When paired with AWS AppSync, DataStore enables lightweight *Delta Sync* synchronization and flexible conflict resolution strategies.

# Getting Started

## Model Generation

The first step to integrate DataStore into your app is to model your data with a GraphQL schema, and *generate models* from that schema. The same GraphQL may be used to generate models for Android, iOS, and JavaScript. The same schemas are also used by the network protocol when synchronizing data with the cloud. Models can be generated by running a Gradle task in Android Studio, or by executing a command with the Amplify CLI.

## Using Gradle

Open your project `build.gradle` and add `mavenCentral()` as a repository, `classpath 'com.amplifyframework:amplify-tools-gradle-plugin:0.2.1'` as a dependency, and `'com.amplifyframework.amplifytools'` as a plugin:


```gradle
buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.5.0'
        classpath 'com.amplifyframework:amplify-tools-gradle-plugin:0.2.1'
    }
}

apply plugin: 'com.amplifyframework.amplifytools'
```

Next, add the following dependencies to your app `build.gradle`:

```gradle
implementation 'com.amplifyframework:core:0.9.1'
implementation 'com.amplifyframework:aws-datastore:0.9.1'
```

Sync the project and ensure that it built successfully. Switch to the **Project** view in Android Studio and open the schema file at `amplify/backend/api/amplifyDatasource/schema.graphql`. For this guide, edit this file so that it contains the schema definition below. [Learn more](https://aws-amplify.github.io/docs/cli-toolchain/graphql){:target="_blank"} about annotating GraphQL schemas and data modeling.

```graphql
enum PostStatus {
  ACTIVE
  INACTIVE
}

type Post @model {
  id: ID!
  title: String!
  rating: Int!
  status: PostStatus!
}
```

Gradle tasks will generate model files to be used in your API calls, and will provision a backend for you.

After saving your `schema.graphql` file, click the Gradle Task dropdown in the toolbar and select **modelgen** and run the task. Once it completes you should have generated Java classes under `app/src/main/java/com/amplifyframework/datastore/generated/model`.

You do not need an AWS account to complete these steps, nor if you are using DataStore without a backend. However, if you wish to sync with the cloud, it is recommended that you [Install and configure the Amplify CLI](..)
{: .callout .callout--info}

## Manual Model Generation

If you do not wish to use the above Gradle task, you can perform the same steps manually. First, install the latest version of the Amplify CLI:

```
npm i -g @aws-amplify/cli@latest
```

Generate models at any time by executing this Amplify CLI command:

```
amplify codegen models
```

### Schema updates

When the code generator builds model classes for your schema, it also generates a version hash based on the current schema. When you make changes to your schema and re-run the modelgen task, the code generator will update the hash if it detects any changes that will impact the underlying on-device storage structure. For example, a new hash will be generated if data types are added/deleted, or if any field has a change to its required/optional status. Whenever DataStore starts on a device, it will check for a change in the version hash. If the version has changed, all instances of these models will be wiped from the device, and if you are syncing with the cloud, a full sync will take place. Local migrations on device are not supported. If you are syncing with the cloud, the existing structure and instances of your data in the backend will not be modified as part of this process.

## Setup

In your app's `onCreate` (or similar lifecycle callback), initialize Amplify:

```java
AWSDataStorePlugin dataStorePlugin = AWSDataStorePlugin.forModels(AmplifyModelProvider.getInstance());
Amplify.addPlugin(dataStorePlugin);
Amplify.addPlugin(new AWSApiPlugin()); // If using remote model synchronization
Amplify.configure(getApplicationContext());
```

If you do not have any configuration file at `app/src/main/res/raw/amplifyconfiguration.json`, create a placeholder for now. For more information about this file, see the configuration section of this guide.

```
{
  "userAgent": "aws-amplify-cli/2.0",
  "version": "1.0"
}
```

# Save Data

To write any data to the DataStore, you can pass an instance of a Model to `DataStore.save()` and it will be persisted in offline storage. The DataStore supports standard storage operations like querying, updating and deleting. If you choose to connect to the cloud at a later time, the local items will be synchronized using GraphQL mutations. Any other systems connected to the same backend can then run queries or mutations on your DataStore items, or observe changes to them via GraphQL subscriptions.

```java
Post post = Post.builder()
    .title("My First Post")
    .rating(10)
    .status(PostStatus.ACTIVE)
    .build();

Amplify.DataStore.save(post, new ResultListener<DataStoreItemChange<Post>>() {
    @Override
    public void onResult(DataStoreItemChange<Post> result) {
        Log.i("DataStore", "Result: " + result);
    }

    @Override
    public void onError(Throwable error) {
        Log.e("DataStore", "Error.", error);
    }
});
```

# Query Data

Queries are always performed against the local copy of your data. When connected to the cloud, the local copy of your data is automatically updated in the background. You can query for models by their class, or by providing additional search criteria for finer-grained results. A simple query without any filtering criteria is shown below.

```java
Amplify.DataStore.query(Post.class, new ResultListener<Iterator<Post>>() {
    @Override
    public void onResult(Iterator<Post> result) {       
        while (result.hasNext()) {
            Post post = result.next();
            Log.i("DataStore", "Title: " + post.getTitle());
            Log.i("DataStore", "Rating: " + post.getRating());
            Log.i("DataStore", "Status: " + post.getStatus());
        }
    }

    @Override
    public void onError(Throwable error) {
        Log.e("DataStore", "Error.", error);
    }
});
```

## Query with Predicates

You can provide additional filters to your query using a **query predicate**. The AWS-standard nomenclature of these query predicates will be familiar to those who have used Amazon DynamoDB, in the past.

**Strings:** `eq | ne | le | lt | ge | gt | contains | beginsWith | between`

**Numbers:** `eq | ne | le | lt | ge | gt | between`

**Lists:** `contains`

For example, if you wanted a list of all `Post` models that have a `rating` greater than 4:

```java
Amplify.DataStore.query(Post.class, Post.RATING.gt(4), new ResultListener<Iterator<Post>>() {
    @Override
    public void onResult(Iterator<Post> result) {
        while (result.hasNext()) {
            Post post = result.next();
            Log.i("DataStore", "Title: " + post.getTitle());
            Log.i("DataStore", "Rating: " + post.getRating());
            Log.i("DataStore", "Status: " + post.getStatus());
        }
    }

    @Override
    public void onError(Throwable error) {
        Log.e("DataStore", "Error.", error);
    }
});
```

Note: when constructing predicates, static `QueryField` instances such as `Post.RATING` do not own any information about the model to which the field belongs. In order to avoid any ambiguity between field names which are used across multiple models, it is recommended to construct a custom instance of `QueryField` in the form of  `QueryField.field("{model-name}.{field-name}")` (i.e. `QueryField.field("Post.rating")`).
{: .callout .callout--info}

Multiple conditions can be chained together by using `and | or | not`:

```java
Amplify.DataStore.query(
    Post.class,
    Post.RATING.gt(4).and(Post.STATUS.eq(PostStatus.ACTIVE)),
    new ResultListener<Iterator<Post>>() {
        @Override
        public void onResult(Iterator<Post> result) {
            while (result.hasNext()) {
                Post post = result.next();
                Log.i("DataStore", "Title: " +  post.getTitle());
                Log.i("DataStore", "Rating: " + post.getRating());
                Log.i("DataStore", "Status: " + post.getStatus());
            }
        }

        @Override
        public void onError(Throwable error) {
            Log.e("DataStore", "Error.", error);
        }
    }
);
```

# Update Data

An in-memory representation of a DataStore Model is immutable. Instead of directly modifying the fields on a Model, you must use the `.copyOfBuilder()` function to create a new representation of the model:

```java
ResultListener<DataStoreItemChange<Post>> updateListener = new ResultListener<DataStoreItemChange<Post>>() {
    @Override
    public void onResult(DataStoreItemChange<Post> result) {
        Log.i("DataStore", "Result: " + result.item());
    }

    @Override
    public void onError(Throwable error) {
        Log.e("DataStore", "Error.", error);
    }
};

Amplify.DataStore.query(Post.class, Post.ID.eq("123"), new ResultListener<Iterator<Post>>() {
    @Override
    public void onResult(Iterator<Post> result) {
        if (result.hasNext()) {
            Post original = result.next();
            Post edited = original.copyOfBuilder()
                .title("New Title")
                .build();
            Amplify.DataStore.save(edited, updateListener);
        }
    }

    @Override
    public void onError(Throwable error) {
        Log.e("DataStore", "Error.", error);
    }
});
```

# Delete Data

To delete an item, simply pass in an instance:

```java
ResultListener<DataStoreItemChange<Post>> deleteListener = new ResultListener<DataStoreItemChange<Post>>() {
    @Override
    public void onResult(DataStoreItemChange<Post> result) {
        Log.i("DataStore", "Result: " + result.item());
    }

    @Override
    public void onError(Throwable error) {
        Log.e("DataStore", "Error.", error);
    }
};

Amplify.DataStore.query(Post.class, Post.ID.eq("123"), new ResultListener<Iterator<Post>>() {
    @Override
    public void onResult(Iterator<Post> result) {
        if (result.hasNext()) {
            Post post = result.next();
            Amplify.DataStore.delete(post, deleteListener);
        }
    }

    @Override
    public void onError(Throwable error) {
        Log.e("DataStore", "Error.", error);
    }
});
```

# Observe Data

You can subscribe to changes on your Models by using the DataStore's `observe` method. This method reacts dynamically to all changes in local storage. These changes could be the result of local modifications, or the result of changes observed on your GraphQL endpoint, if using remote synchronization.

The `AWSDataStorePlugin.observe()` method returns an `io.reactivex.Observable<DataStoreItemChange<? extends Model>>`. You can subscribe to this Rx Observable to get notifications whenever any model is created, updated, or deleted. To use a method in this family, you must make Rx available at runtime by adding `implementation 'io.reactivex.rxjava2:rxandroid:2.1.1'` to your module's `build.gradle`. [Read more about RxJava, here](https://github.com/ReactiveX/RxJava/blob/v2.2.17/README.md#rxjava-reactive-extensions-for-the-jvm).
{: .callout .callout--info}

```java
Amplify.DataStore.observe(Post.class).subscribe(changed -> {
    Post post = changed.item();
    Log.i("DataStore", "Post Title: " + post.getTitle());
});
```

# Sync with the cloud

Once you're happy with your application, you can start syncing with the cloud by provisioning a backend from your project. This can be done using the `amplify-app` npx script or with the Amplify CLI. Provisioning will also create a project in the [AWS Amplify Console](https://aws.amazon.com/amplify/console/) to store metadata (such as the GraphQL schema) which you can pull down to generate models on other platforms.

DataStore can connect to an existing AppSync backend that has been deployed from another project. In these workflows, it is best to work with the CLI directly. Run the `amplify pull` command from your terminal, then generate models as discussed earlier in this guide.

For more information on this workflow please see the [Multiple Frontends documentation](https://aws-amplify.github.io/docs/cli-toolchain/quickstart#multiple-frontends){:target="_blank"}.

## Use Gradle

If you have installed the Gradle tools for Amplify, select the Gradle dropdown in the toolbar and click **amplifyPush** then run the task.

If you do not already have a local AWS profile with credentials (automatically setup with the Amplify CLI) you will be prompted to do this on the first push.
{: .callout .callout--info}

## Use Amplify CLI
```
amplify push
```

# Relational Models

DataStore has the capability to handle relationships between Models, such as `Has One`, `Has Many`, `Belongs To`, and `Many To Many`. In GraphQL this is done with `@connection` as defined in the [GraphQL Transformer documentation](https://aws-amplify.github.io/docs/cli-toolchain/graphql#connection){:target="_ blank"}. For the examples that follow, we will use the following schema:

```graphql
enum PostStatus {
  ACTIVE
  INACTIVE
}

type Post @model {
  id: ID!
  title: String!
  comments: [Comment] @connection(name: "PostComments")
  rating: Int!
  status: PostStatus!
}

type Comment @model {
  id: ID!
  content: String
  post: Post @connection(name: "PostComments")
}
```

## Saving relations

```java
Post post = Post.builder()
    .title("My Post with comments")
    .rating(10)
    .status(PostStatus.ACTIVE)
    .build();

Amplify.DataStore.save(post, new ResultListener<DataStoreItemChange<Post>>() {
    /* callback implementation */
});

Comment comment = Comment.builder()
    .content("Loving Amplify DataStore!")
    .post(post) // Directly pass in the post instance
    .build();

Amplify.DataStore.save(comment, new ResultListener<DataStoreItemChange<Comment>>() {
    /* callback implementation */
});
```

The above example shows how to use a one-to-many schema and save connected models. For many-to-many relationships, such as the one shown in the [GraphQL Transformer examples](https://aws-amplify.github.io/docs/cli-toolchain/graphql#connection) you can do as below:

```java
Post post = Post.builder()
    .title("My First Post")
    .build();
Amplify.DataStore.save(post, new ResultListener<DataStoreItemChange<Post>>() {
    /* Callback implementation here */
});

User editor = User.builder()
    .username("Nadia")
    .build();
Amplify.DataStore.save(editor, new ResultListener<DataStoreItemChange<User>>() {
    /* Callback implementation here */
});

PostEditor postEditor = PostEditor.builder()
    .post(post)
    .editor(editor)
    .build();
Amplify.DataStore.save(postEditor, new ResultListener<DataStoreItemChange<PostEditor>>() {
    /* Callback implementation here */
});
```

In this case, you save instances of models from each side of the relationship and then join them together in the connecting type on a field defined with `@connection`. For the schema above this corresponds to `post: Post! @connection(fields: ["postID"])` and `editor: User! @connection(fields: ["editorID"])`.

## Querying relations

When querying for a model that `Belongs To` (i.e. identity depends on) another model, the predicate can directly refer to model that owns it.

This example queries for all comments that belong to a post with given ID value.

```java
Amplify.DataStore.query(
    Comment.class,
    Post.ID.eq("123"),
    new ResultListener<Iterator<Comment>>() {
        /* callback implementation */
    }
);
```

## Deleting relations

When you delete a parent object in a one-to-many relationship, the children will also be removed from the DataStore. These deletions will also be dispatched for synchronization over the network. For example, the following operation would remove `myPost` as well as any related comments:

```java
Amplify.DataStore.delete(myPost, new ResultListener<DataStoreItemChange<Post>>() {
    /* callback implementation */
});
```
However, in a many-to-many relationship, the children are not removed and you must explicitly delete them.

# Config

In order to enable cloud sync, the `amplifyconfiguration.json` must:

1. Contain a configuration for the API category with EXACTLY ONE GraphQL endpoint, and
2. Contain a configuration for the Data Store category which sets `syncMode` to `api`

```json
{
  "userAgent": "aws-amplify-cli/2.0",
  "version": "1.0",
  "api": {
    "plugins": {
      "awsAPIPlugin": {
        "myApi": {
          "endpointType": "GraphQL",
          "endpoint": "{my-graphql-endpoint}",
          "region": "{region}",
          "authorizationType": "{my-authorization-type}"
        }
      }
    }
  },
  "dataStore": {
    "plugins": {
      "awsDataStorePlugin": {
        "syncMode": "api"
      }
    }
  }
}
```

If only using the DataStore for local data, without any cloud synchronization, your configuration file may be empty:
```
{}
```

## Conflict Resolution

When syncing with AWS AppSync, DataStore updates from multiple clients will converge by tracking object versions and adhere to different conflict resolution strategies. The default strategy is called *Automerge* where GraphQL type information on an object is inspected at runtime to perform merge operations. You can read more about this behavior and alternatives such as *Optimistic Concurrency* Control and *custom Lambda functions* in the [AWS AppSync documentation](https://docs.aws.amazon.com/appsync/latest/devguide/conflict-detection-and-sync.html){:target="_blank"}. To update the conflict resolution strategies navigate into your project from a terminal and run `amplify update api` choosing *Yes* when prompted to change the conflict detection and conflict resolution strategies:

```sh
amplify update api #Select GraphQL

? Do you want to configure advanced settings for the GraphQL API
❯ Yes, I want to make some additional changes.

? Configure conflict detection? Yes
? Select the default resolution strategy
  Auto Merge
❯ Optimistic Concurrency
  Custom Lambda
  Learn More
```

Note that this flow will also allow you to change the strategy on each individual GraphQL type, though is is recommended to use the same strategy for your whole schema unless you have an advanced use case:

```sh
? Do you want to override default per model settings? Yes
? Select the models from below:
❯◉ Post
 ◯ PostEditor
 ◯ User

? Select the resolution strategy for Post model Custom Lambda
? Select from the options below (Use arrow keys)
❯ Create a new Lambda Function
  Existing Lambda Function
```

# How it Works

<iframe width="600" height="345" src="https://www.youtube.com/embed/KcYl6_We0EU">
</iframe>

Amplify DataStore is an on device persistent repository for interacting with your local data while it synchronizes with the cloud. The core idea is to focus on your data modeling in your application with GraphQL, adding any authorization rules or business logic into your application when needed. This can be done using Amplify CLI project functionality (`amplify add auth` or `amplify add function`) as well as the [GraphQL Transformer](https://aws-amplify.github.io/docs/cli-toolchain/graphql){:target="_blank"}.

Starting with GraphQL schema (with or without an AWS account) a code generation process creates *Models* which are domain native constructs for a programming platform (TypeScript, Java, Swift classes). This "modelgen" process happens using the Amplify CLI which is either done manually in your terminal or using build tools that will invoke the CLI process (NPX scripts, Gradle, Xcode build phase).

Once Models have been generated, you can operate on these instances with the DataStore API to save, query, update, delete, or observe changes. At runtime models are passed into a *Storage Engine* that has a *Storage Adapter*. The Storage Engine manages a "Model Repository" of Models which were defined by the developer's GraphQL schema as well as "System Models" which are used for both metadata (such as settings) and queueing updates over the network when syncing to the cloud. Amplify ships with default Storage Adapter implementations, such as SQLite and IndexedDB, however the pattern allows for more in the future for community contributions and is not specific to one technology (e.g. SQL vs NoSQL).

![Image]({{common_media}}/storage.png)

When developer application code interacts with the DataStore API the it is the responsibility of the Storage Engine to store the specific Model for a GraphQL type in the Model Repository as well as serialize & deserialize as appropriate for persistence in the specific Storage Adapter representation. This includes conversion from a GraphQL specific type the appropriate structure in that database engine (e.g. `Int` to `Int64`).

If a developer chooses to sync with the cloud, the Amplify CLI will use the GraphQL schema to deploy an AWS AppSync backend with DynamoDB tables for each type and an additional table used for *Delta Sync*. Other AWS services such as Amazon Cognito or AWS Lambda will also be deployed if added to the project. Once this completes the local configuration for the platform (`aws-exports.js` or `amplifyconfiguration.json`) will be generated inside the project and updated with settings and endpoint information.

If the DataStore starts up and sees API information to sync with an AppSync endpoint, it will start an instance of it's *Sync Engine*. This component interfaces with the Storage Engine to get updates from the Model Repository. These components use an *Observer* pattern where the Sync Engine publishes events whenever updates happen in it (such as data being added, updated, or deleted) and both the DataStore API and Sync Engine subscribe to this publication stream. This is how the developer knows when updates have happened from the cloud by interacting with the DataStore API, and conversely how the Sync Engine knows when to communicate with the cloud when applications have made updates to data.

![Image]({{common_media}}/sync.png)

As notifications come into the Sync Engine from the Storage Engine it converts information from the Model Repository into GraphQL statements at runtime. This includes subscribing to all create/update/delete operations for each type, as well as running queries or mutations. 

The Sync Engine will run a GraphQL query on first start that hydrates the Storage Engine from the network using a *Base Query*. This defaults to a limit of 100 items at a time and will paginate through up to 1000 items. It will then store a *Last Sync Time* and each time the device goes from an offline to online state, it will use this as an argument in a *Delta Query*. When AppSync receives this Last Sync Time in it's argument list it will only returned the changes that have been missed by pulling items in a Delta Table.

All items (or "objects") are versioned by *Sync Enabled Resolvers* in AppSync using monotonically increasing counters. Clients never update versions, only the service controls versions. The Sync Engine receives new items or updates from GraphQL operations and applies them with their versions to the Storage Engine. When items are updated by application code they are always written to a queue and the Sync Engine sends them to AppSync using the currently known version as an argument (`_version`) in the mutation. 

When multiple clients send concurrent updates using the same version and conflict resolution is configured, a strategy for conflict resolution will be entered. The default strategy for clients is Automerge where the GraphQL type information is used to inspect the update and compare it to the current item that has been written to your table. Any non-conflicting fields are merged with the item and any lists will have values appended, with the service updating the item version as appropriate. You can change this default to apply version checks to the entire object with *Optimistic Concurrency* where the latest written item to your database will be used with a version check against the incoming record, or alternatively you can use a Lambda function and apply any custom business logic you wish to the process when merging or rejecting updates. In all cases the service controls the versions. For more information on how these conflict resolution rules work please [see the AWS AppSync documentation](https://docs.aws.amazon.com/appsync/latest/devguide/conflict-detection-and-sync.html){:target="_blank"}.

## Writing data from the AppSync console

DataStore is designed primarily for developers to not have to focus on the backend and let your application code and workflow create everything. However, there will be some use cases where you will use the AppSync console, a Lambda function, or other out of band processes to write data (such as batch actions or data migrations) and you might send GraphQL operations without the DataStore client.

In these cases it's important that the selection set of your GraphQL mutation includes the fields `_lastChangedAt`, `_version`, and `_deleted` so that the DataStore clients can react to these updates. You will also need to send the **current** object version in the mutation input argument as `_input` so that the service can act accordingly. If you do not send this information the clients will still eventually catch up during the global sync process, but you will not see realtime updates to the client DataStore repositories. An example mutation:

```graphql
mutation UpdatePost {
  updatePost(input: {
    id: "12345"
    title: "updated title 19:40"
    status: ACTIVE
    rating: 5
    _version: 7
  }) {
    id
    title
    status
    rating
    _lastChangedAt
    _version
    _deleted
  }
}
```

## API Reference   

For the complete API documentation for DataStore, visit our [API Reference](https://aws-amplify.github.io/docs/android/start)
{: .callout .callout--info}
