export const meta = {
  title: 'Nuxt 3 App',
  description: 'Get started with AWS Amplify (Gen 2) using Nuxt.'
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };
}

This Quickstart guide will walk you through how to build a task list application with TypeScript, Nuxt, and Vue. If you are new to these technologies, we recommend you go through the official [TypeScript](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html), [Nuxt](https://nuxt.com/docs/getting-started/introduction), and [Vue](https://vuejs.org/guide/introduction.html) tutorials first.


import prerequisites from 'src/fragments/gen2/quickstart/prerequisites.mdx';

<Fragments fragments={{ javascript: prerequisites, nuxtjs: prerequisites }} />

## Create a project

First, you will need to create a new Nuxt app. The following command will create a Nuxt 3 app in a directory called `nuxt-amplify-gen2`.

```bash title="Terminal" showLineNumbers={false}
npx nuxi@latest init nuxt-amplify-gen2

Ok to proceed? (y) y

✔ Which package manager would you like to use? npm
✔ Initialize git repository? yes

cd nuxt-amplify-gen2
```

import createAmplify from 'src/fragments/gen2/quickstart/create-amplify.mdx';

<Fragments fragments={{ javascript: createAmplify, nuxtjs: createAmplify}} />

import buildABackend from 'src/fragments/gen2/quickstart/build-a-backend.mdx';

<Fragments fragments={{ javascript: buildABackend, nuxtjs: buildABackend }} />

## Setup the AmplifyAPIs Plugin

Nuxt 3 offers universal rendering by default, where your data fetching logic may be executed on both the client and server sides. Amplify offers APIs that are capable of running within a server context to support use cases such as server-side rendering (SSR) and static site generation (SSG), though Amplify's client-side APIs and server-side APIs of Amplify are slightly different. You can set up an AmplifyAPIs plugin to make your data fetching logic run smoothly across the client and server. To learn more about how to use Amplify categories APIs in server side rendering, refer to this [documentation](https://docs.amplify.aws/react/build-a-backend/server-side-rendering/).

1. Create a `plugins` directory under the root of your Nuxt project. 
2. Create two files `01.amplify-apis.client.ts` and `01.amplify-apis.server.ts` under the `plugins` directory.

In these files, you will register both client-specific and server-specific Amplify APIs that you will use in your Nuxt project as a plugin. You can then access these APIs via the `useNuxtApp` composable.

<Callout>

**NOTE:** The leading number in the files name indicate the plugin loading order, for more details see https://nuxt.com/docs/guide/directory-structure/plugins#registration-order. The `.client` and `.server` indicate the runtime that the logic contained in the file will run on, client or server. For details see: https://nuxt.com/docs/guide/directory-structure/plugins

</Callout>

Modify the `01.amplify-apis.client.ts` file, with the following code:

```ts title="nuxt-amplify-gen2/plugins/01.amplify-apis.client.ts"
import {
  fetchAuthSession,
  fetchUserAttributes,
  signIn,
  signOut,
} from "aws-amplify/auth";
import { generateClient } from "aws-amplify/data";
import config from "../amplifyconfiguration.json";
import type { Schema } from "@/amplify/data/resource";
import { Amplify } from "aws-amplify";

// configure the Amplify client library
if (process.client) {
  Amplify.configure(config, { ssr: true });
}

// generate your data client using the Schema from your backend
const client = generateClient<Schema>();

export default defineNuxtPlugin({
  name: "AmplifyAPIs",
  enforce: "pre",
  setup() {
    return {
      provide: {
        // You can call the API by via the composable `useNuxtApp()`. For example:
        // `useNuxtApp().$Amplify.Auth.fetchAuthSession()`
        Amplify: {
          Auth: {
            fetchAuthSession,
            fetchUserAttributes,
            signIn,
            signOut,
          },
          GraphQL: {
            client,
          },
        },
      },
    };
  },
});
```

Next, modify the `01.amplify-apis.server.ts` file, with the following code:

```ts title="nuxt-amplify-gen2/plugins/01.amplify-apis.server.ts"
import type { CookieRef } from "nuxt/app";
import {
  createKeyValueStorageFromCookieStorageAdapter,
  createUserPoolsTokenProvider,
  createAWSCredentialsAndIdentityIdProvider,
  runWithAmplifyServerContext,
} from "aws-amplify/adapter-core";
import { parseAmplifyConfig } from "aws-amplify/utils";
import {
  fetchAuthSession,
  fetchUserAttributes,
  getCurrentUser,
} from "aws-amplify/auth/server";
import { generateClient } from "aws-amplify/api/server";
import type {
  LibraryOptions,
  FetchAuthSessionOptions,
} from "@aws-amplify/core";
import type {
  GraphQLOptionsV6,
  GraphQLResponseV6,
} from "@aws-amplify/api-graphql";

import config from "../amplifyconfiguration.json";

// parse the content of `amplifyconfiguration.json` into the shape of ResourceConfig
const amplifyConfig = parseAmplifyConfig(config);

// create the Amplify used token cookies names array
const userPoolClientId = amplifyConfig.Auth!.Cognito.userPoolClientId;
const lastAuthUserCookieName = `CognitoIdentityServiceProvider.${userPoolClientId}.LastAuthUser`;

// create a GraphQL client that can be used in a server context
const gqlServerClient = generateClient({ config: amplifyConfig });

const getAmplifyAuthKeys = (lastAuthUser: string) =>
  ["idToken", "accessToken", "refreshToken", "clockDrift"]
    .map(
      (key) =>
        `CognitoIdentityServiceProvider.${userPoolClientId}.${lastAuthUser}.${key}`
    )
    .concat(lastAuthUserCookieName);

// define the plugin
export default defineNuxtPlugin({
  name: "AmplifyAPIs",
  enforce: "pre",
  setup() {
    // The Nuxt composable `useCookie` is capable of sending cookies to the
    // client via the `SetCookie` header. If the `expires` option is left empty,
    // it sets a cookie as a session cookie. If you need to persist the cookie
    // on the client side after your end user closes your Web app, you need to
    // specify an `expires` value.
    //
    // We use 30 days here as an example (the default Cognito refreshToken
    // expiration time).
    const expires = new Date();
    expires.setDate(expires.getDate() + 30);

    // Get the last auth user cookie value
    //
    // We use `sameSite: 'lax'` in this example, which allows the cookie to be
    // sent to your Nuxt server when your end user gets redirected to your Web
    // app from a different domain. You should choose an appropriate value for
    // your own use cases.
    const lastAuthUserCookie = useCookie(lastAuthUserCookieName, {
      sameSite: "lax",
      expires,
      secure: true,
    });

    // Get all Amplify auth token cookie names
    const authKeys = lastAuthUserCookie.value
      ? getAmplifyAuthKeys(lastAuthUserCookie.value)
      : [];

    // Create a key-value map of cookie name => cookie ref
    //
    // Using the composable `useCookie` here in the plugin setup prevents
    // cross-request pollution.
    const amplifyCookies = authKeys
      .map((name) => ({
        name,
        cookieRef: useCookie(name, { sameSite: "lax", expires, secure: true }),
      }))
      .reduce<Record<string, CookieRef<string | null | undefined>>>(
        (result, current) => ({
          ...result,
          [current.name]: current.cookieRef,
        }),
        {}
      );

    // Create a key value storage based on the cookies
    //
    // This key value storage is responsible for providing Amplify Auth tokens to
    // the APIs that you are calling.
    //
    // If you implement the `set` method, when Amplify needed to refresh the Auth
    // tokens on the server side, the new tokens would be sent back to the client
    // side via `SetCookie` header in the response. Otherwise the refresh tokens
    // would not be propagate to the client side, and Amplify would refresh
    // the tokens when needed on the client side.
    //
    // In addition, if you decide not to implement the `set` method, you don't
    // need to pass any `CookieOptions` to the `useCookie` composable.
    const keyValueStorage = createKeyValueStorageFromCookieStorageAdapter({
      get(name) {
        const cookieRef = amplifyCookies[name];

        if (cookieRef && cookieRef.value) {
          return { name, value: cookieRef.value };
        }

        return undefined;
      },
      getAll() {
        return Object.entries(amplifyCookies).map(([name, cookieRef]) => {
          return { name, value: cookieRef.value ?? undefined };
        });
      },
      set(name, value) {
        const cookieRef = amplifyCookies[name];
        if (cookieRef) {
          cookieRef.value = value;
        }
      },
      delete(name) {
        const cookieRef = amplifyCookies[name];

        if (cookieRef) {
          cookieRef.value = null;
        }
      },
    });

    // Create a token provider
    const tokenProvider = createUserPoolsTokenProvider(
      amplifyConfig.Auth!,
      keyValueStorage
    );

    // Create a credentials provider
    const credentialsProvider = createAWSCredentialsAndIdentityIdProvider(
      amplifyConfig.Auth!,
      keyValueStorage
    );

    // Create the libraryOptions object
    const libraryOptions: LibraryOptions = {
      Auth: {
        tokenProvider,
        credentialsProvider,
      },
    };

    return {
      provide: {
        // You can add the Amplify APIs that you will use on the server side of
        // your Nuxt app here. You must only use the APIs exported from the
        // `aws-amplify/<category>/server` subpaths.
        //
        // You can call the API by via the composable `useNuxtApp()`. For example:
        // `useNuxtApp().$Amplify.Auth.fetchAuthSession()`
        //
        // Recall that Amplify server APIs are required to be called in a isolated
        // server context that is created by the `runWithAmplifyServerContext`
        // function.
        Amplify: {
          Auth: {
            fetchAuthSession: (options: FetchAuthSessionOptions) =>
              runWithAmplifyServerContext(
                amplifyConfig,
                libraryOptions,
                (contextSpec) => fetchAuthSession(contextSpec, options)
              ),
            fetchUserAttributes: () =>
              runWithAmplifyServerContext(
                amplifyConfig,
                libraryOptions,
                (contextSpec) => fetchUserAttributes(contextSpec)
              ),
            getCurrentUser: () =>
              runWithAmplifyServerContext(
                amplifyConfig,
                libraryOptions,
                (contextSpec) => getCurrentUser(contextSpec)
              ),
          },
          GraphQL: {
            client: {
              // Follow this typing to ensure the`graphql` API return type can
              // be inferred correctly according to your queries and mutations
              graphql: <
                FALLBACK_TYPES = unknown,
                TYPED_GQL_STRING extends string = string
              >(
                options: GraphQLOptionsV6<FALLBACK_TYPES, TYPED_GQL_STRING>,
                additionalHeaders?: Record<string, string>
              ) =>
                runWithAmplifyServerContext<
                  GraphQLResponseV6<FALLBACK_TYPES, TYPED_GQL_STRING>
                >(amplifyConfig, libraryOptions, (contextSpec) =>
                  gqlServerClient.graphql(
                    contextSpec,
                    options,
                    additionalHeaders
                  )
                ),
            },
          },
        },
      },
    };
  },
});
```

The `app.vue` file can be rendered on both the client and server sides by default. The `useNuxtApp().$Amplify` composable will pick up the correct implementation of `01.amplify-apis.client.ts` and `01.amplify-apis.server.ts` to use, depending on the runtime.

<Callout warning>

Only a subset of Amplify APIs are usable on the server side, and as the libraries evolve, `amplify-apis.client` and `amplify-apis.server` may diverge further. You can guard your API calls to ensure an API is available in the context where you use it. E.g., you can use `if (process.client)` to ensure that a client-only API isn't executed on the server.

</Callout>

## Build UI

Let's add UI that connects to the backend data and auth resources.

### Add a login form

First, install the Amplify UI component library:

```bash title="Terminal" showLineNumbers={false}
npm install @aws-amplify/ui-vue
```

Next, in your app's `app.vue` file, add the following imports and wrap your App in the `Authenticator` function:

```ts title="nuxt-amplify-gen2/app.vue"
// app.vue
<script setup lang="ts">
import { Authenticator } from '@aws-amplify/ui-vue';
import '@aws-amplify/ui-vue/styles.css';
</script>


<template>
  <Authenticator>
    <template v-slot="{ user, signOut }">
      <h1>Hello {{ user.username }}!</h1>
      <button @click="signOut">Sign Out</button>
    </template>
  </Authenticator>
</template>
```

Run your application with `npm run dev` and navigate to `http://localhost:3000`. You should now see the authenticator, which is already configured and ready for your first sign-up! Create a new user account, confirm the account through email, and then sign in.


### View list of to-do items

Now, let's display data on our app's frontend. Modify your app's home page file, `app.vue`, with the following code:

```ts title="nuxt-amplify-gen2/app.vue"
// app.vue
<script setup lang="ts">
import { Authenticator } from '@aws-amplify/ui-vue';
import '@aws-amplify/ui-vue/styles.css';
import { onMounted, ref } from 'vue';
import type { Schema } from '@/amplify/data/resource';

// create a reactive reference to the array of todos
const todos = ref<Schema['Todo'][]>([]);

async function listTodos() {
 try {
    // fetch all todos
    const { data } = await useNuxtApp().$Amplify.GraphQL.client.models.Todo.list();
    todos.value = data;

  } catch (error) {
     console.error('Error fetching todos', error);
  }
}

// fetch todos when the component is mounted
onMounted(() => {
  listTodos();
});
</script>


<template>
  <Authenticator>
    <template v-slot="{ user, signOut }">
      <h1>Hello, Amplify 👋</h1>
        <ul>
          <li v-for="todo in todos" :key="todo.id">{{ todo.content }}</li>
        </ul>
      <button @click="signOut">Sign Out</button>
    </template>
  </Authenticator>
</template>
```

Once you save the file and navigate back to `http://localhost:3000`, you should see a blank page for now because you have only an empty list of to-dos.

### Create a new to-do item

Let's update the vue component to also have a button for creating a new to-do list item, prompting the user to add a title. In a production app, you would want to create a full form, and run the create method on form submission.

```ts title="nuxt-amplify-gen2/app.vue"
// vue.app
<script setup lang="ts">
import { Authenticator } from '@aws-amplify/ui-vue';
import '@aws-amplify/ui-vue/styles.css';
import { onMounted, ref } from 'vue';
import type { Schema } from '@/amplify/data/resource';

// create a reactive reference to the array of todos
const todos = ref<Schema['Todo'][]>([]);

async function listTodos() {
  try {
    // fetch all todos
    const { data } = await useNuxtApp().$Amplify.GraphQL.client.models.Todo.list();
    todos.value = data;

  } catch (error) {
    console.error('Error fetching todos', error);
  }
}

async function createTodo() {
  try {
    // create a new Todo
    const title = window.prompt('Enter the title:');
    
    // if title is empty or user cancels, do nothing
    if (!title) return;

    const { errors, data: newTodo } = await useNuxtApp().$Amplify.GraphQL.client.models.Todo.create({
      content: title,
      done: false,
      priority: 'medium'
    });

    console.log(errors, newTodo);

    // after creating the todo, refresh the list
    await listTodos();
  } catch (error) {
    console.error('Error creating todo', error);
  }
}

// fetch todos when the component is mounted
 onMounted(() => {
  listTodos();
});
</script>


<template>
  <Authenticator>
    <template v-slot="{ user, signOut }">
      <h1>Hello, Amplify 👋</h1>
      <button @click="createTodo"> Create</button>
      <ul>
        <li v-for="todo in todos" :key="todo.id">{{ todo.content }}</li>
      </ul>
      <button @click="signOut">Sign Out</button>
    </template>
  </Authenticator>
</template>
```

Create a couple of to-dos, then refresh the page to see them. You can also subscribe to new to-dos in your `onMounted` to have them live reload on the page.

```ts title="nuxt-amplify-gen2/app.vue"
// vue.app
<script setup lang="ts">
import { Authenticator } from '@aws-amplify/ui-vue';
import '@aws-amplify/ui-vue/styles.css';
import { onMounted, ref } from 'vue';
import type { Schema } from '@/amplify/data/resource';

// create a reactive reference to the array of todos
const todos = ref<Schema['Todo'][]>([]);

async function listTodos() {
  try {
    // fetch all todos
    const { data } = await useNuxtApp().$Amplify.GraphQL.client.models.Todo.list();
    todos.value = data;

    // subscribe to todos
    subscribeToTodo();
  } catch (error) {
    console.error('Error fetching todos', error);
  }
}

async function createTodo() {
  try {
    // create a new Todo
    const title = window.prompt('Enter the title:');
    
    // if title is empty or user cancels, do nothing
    if (!title) return;

    const { errors, data: newTodo } = await useNuxtApp().$Amplify.GraphQL.client.models.Todo.create({
      content: title,
      done: false,
      priority: 'medium'
    });

    console.log(errors, newTodo);

    // after creating the todo, refresh the list
    await listTodos();
  } catch (error) {
    console.error('Error creating todo', error);
  }
}

function subscribeToTodo() {
  const sub = useNuxtApp().$Amplify.GraphQL.client.models.Todo.observeQuery().subscribe(({ items }) => {
    todos.value = items;
  });

  return sub;
}

// fetch todos when the component is mounted
 onMounted(() => {
  listTodos();
});

</script>


<template>
  <Authenticator>
    <template v-slot="{ user, signOut }">
      <h1>Hello, Amplify 👋</h1>
      <button @click="createTodo"> Create</button>
      <ul>
        <li v-for="todo in todos" :key="todo.id">{{ todo.content }}</li>
      </ul>
      <button @click="signOut">Sign Out</button>
    </template>
  </Authenticator>
</template>

```

## Setup Auth Middleware to Protect Your Routes

The auth middleware will use the plugin set up in the previous step as a dependency; therefore you can add the auth middleware via another plugin that will be loaded after the previous one.

Create a `02.auth-redirect.ts` file under the `plugins` directory.

<Callout>

**NOTE:** This file will run on both client and server, for more details see: https://nuxt.com/docs/guide/directory-structure/middleware#when-middleware-runs. The `02` name prefix ensures this plugin loads after the previous so `useNuxtApp().$Amplify` becomes available.

</Callout>

Modify the `02.auth-redirect.ts` file, with the following code:

```ts title="nuxt-amplify-gen2/plugins/02.auth-redirect.ts"
import { Amplify } from "aws-amplify";
import config from "~/amplifyconfiguration.json";

// configure the Amplify client library
if (process.client) {
  Amplify.configure(config, { ssr: true });
}

export default defineNuxtPlugin({
  name: "AmplifyAuthRedirect",
  enforce: "pre",
  setup() {
    addRouteMiddleware(
      "AmplifyAuthMiddleware",
      defineNuxtRouteMiddleware(async (to) => {
        try {
          const session = await useNuxtApp().$Amplify.Auth.fetchAuthSession();

          // If the request is not associated with a valid user session
          // redirect to the `/sign-in` route.
          // You can also add route match rules against `to.path`
          if (session.tokens === undefined && to.path !== "/sign-in") {
            return navigateTo("/sign-in");
          }

          if (session.tokens !== undefined && to.path === "/sign-in") {
            return navigateTo("/");
          }
        } catch (e) {
          if (to.path !== "/sign-in") {
            return navigateTo("/sign-in");
          }
        }
      }),
      { global: true }
    );
  },
});
```

## Setup Amplify for API Route Use Cases

Following the specification of Nuxt, your API route handlers will live under `~/server`, which is a separate environment from other parts of your Nuxt app; hence, the plugins created in the previous sections are not usable here, and extra work is required.

### Setup Amplify Server Context Utility

1. Create a `utils` directory under the `server` directory of your Nuxt project. 
2. Create an `amplifyUtils.ts` file under the `utils` directory.

In this file, you will create a helper function to call Amplify APIs that are capable of running on the server side with context isolation. Modify the `amplifyUtils.ts` file, with the following code:

```ts title="nuxt-amplify-gen2/server/utils/amplifyUtils.ts"
import type { H3Event, EventHandlerRequest } from "h3";
import {
  createKeyValueStorageFromCookieStorageAdapter,
  createUserPoolsTokenProvider,
  createAWSCredentialsAndIdentityIdProvider,
  runWithAmplifyServerContext,
  AmplifyServer,
  CookieStorage,
} from "aws-amplify/adapter-core";
import { parseAmplifyConfig } from "aws-amplify/utils";

import type { LibraryOptions } from "@aws-amplify/core";
import config from "~/amplifyconfiguration.json";

const amplifyConfig = parseAmplifyConfig(config);

const createCookieStorageAdapter = (
  event: H3Event<EventHandlerRequest>
): CookieStorage.Adapter => {
  // `parseCookies`, `setCookie` and `deleteCookie` are Nuxt provided functions
  const readOnlyCookies = parseCookies(event);

  return {
    get(name) {
      if (readOnlyCookies[name]) {
        return { name, value: readOnlyCookies[name] };
      }
    },
    set(name, value, options) {
      setCookie(event, name, value, options);
    },
    delete(name) {
      deleteCookie(event, name);
    },
    getAll() {
      return Object.entries(readOnlyCookies).map(([name, value]) => {
        return { name, value };
      });
    },
  };
};

const createLibraryOptions = (
  event: H3Event<EventHandlerRequest>
): LibraryOptions => {
  const cookieStorage = createCookieStorageAdapter(event);
  const keyValueStorage =
    createKeyValueStorageFromCookieStorageAdapter(cookieStorage);
  const tokenProvider = createUserPoolsTokenProvider(
    amplifyConfig.Auth!,
    keyValueStorage
  );
  const credentialsProvider = createAWSCredentialsAndIdentityIdProvider(
    amplifyConfig.Auth!,
    keyValueStorage
  );

  return {
    Auth: {
      tokenProvider,
      credentialsProvider,
    },
  };
};

export const runAmplifyApi = <Result>(
  // we need the event object to create a context accordingly
  event: H3Event<EventHandlerRequest>,
  operation: (
    contextSpec: AmplifyServer.ContextSpec
  ) => Result | Promise<Result>
) => {
  return runWithAmplifyServerContext<Result>(
    amplifyConfig,
    createLibraryOptions(event),
    operation
  );
};
```

Now, you can use the `runAmplifyApi` function to call Amplify APIs in an isolated server context. Next, create a new API route `/api/current-user` in the `server` directory.

Modify the `current-user.ts` file, with the following code:
```ts title="nuxt-amplify-gen2/server/api/current-user.ts"
import { getCurrentUser } from "aws-amplify/auth/server";
import { runAmplifyApi } from "~/server/utils/amplifyUtils";

export default defineEventHandler(async (event) => {
  const user = await runAmplifyApi(event, (contextSpec) =>
    getCurrentUser(contextSpec)
  );

  return user;
});
```

You can then fetch data from this API route, for example: `fetch('http://localhost:3000/api/current-user')`

## Setup Server Middleware to Protect Your API Routes

Similar to API routes, the previously added auth middleware are not usable under `/server`, hence extra work is required to set up a auth middleware to protect your routes.

1. Create a `middleware` directory under the `server` directory of your Nuxt project.
2. Create an `amplifyAuthMiddleware.ts` file under the middleware directory. 

This middleware will be executed before a request reaches your API route. Modify the `amplifyAuthMiddleware.ts` file, with the following code:
```ts title="nuxt-amplify-gen2/server/middleware/amplifyAuthMiddleware.ts"
import { fetchAuthSession } from "aws-amplify/auth/server";

export default defineEventHandler(async (event) => {
  if (event.path.startsWith("/api/")) {
    try {
      const session = await runAmplifyApi(event, (contextSpec) =>
        fetchAuthSession(contextSpec)
      );

      // You can add extra logic to match the requested routes to apply
      // the auth protection
      if (session.tokens === undefined) {
        setResponseStatus(event, 403);
        return {
          error: "Access denied!",
        };
      }
    } catch (error) {
      return {
        error: "Access denied!",
      };
    }
  }
});
```
With this middleware, when executing `fetch('http://localhost:3000/api/current-user')` without signing in a user on the client side, the fetch will receive a 403 error, and the request won’t reach route `/api/current-user`.

### Terminate dev server

Go to `localhost` in the browser to make sure you can now log in and create and list to-dos. You can end your development session by shutting down the frontend dev server and cloud sandbox. The sandbox prompts you to delete your backend resources. While you can retain your backend, we recommend deleting all resources so you can start clean again next time.

import deployAndHost from 'src/fragments/gen2/quickstart/deploy-and-host.mdx';

<Fragments fragments={{ javascript: deployAndHost, nuxtjs: deployAndHost }} />
