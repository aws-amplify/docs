export const meta = {
  title: 'Connect your app to existing MySQL and PostgreSQL database.',
  description:
    'Learn how to connect your app to existing MySQL and PostgreSQL database.'
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

Amplify's native integration supports any MySQL or Postgres database, no matter if they're hosted on AWS within a VPC or outside of AWS with a 3rd party hosted database provider.

You must have these information handy for your database:

- Database hostname
- Database port
- Database username
- Database user password
- Database name

## Step 1 - Set secrets for database connection

First, provide all the database connection information as secrets, you can use the Amplify sandbox's secret functionality to set them or go to the Amplify console to set secrets in a shared environment:

    <BlockSwitcher>

          <Block name="Sandbox">

                                                                                                                                                                                          ```bash
npx amplify sandbox secret MYSQL_HOSTNAME
npx amplify sandbox secret MYSQL_PORT
npx amplify sandbox secret MYSQL_USERNAME
npx amplify sandbox secret MYSQL_PASSWORD
npx amplify sandbox secret MYSQL_DB_NAME
```

      </Block>
      <Block name="Amplify console">
            </Block>

          </BlockSwitcher>

## Step 2 - Create a new database schema generator configuration file

Create a new **schema-generator.config.ts** file in the **amplify/data/** folder and provide the database connection information:

```ts
import { type SchemaGenerationConfig, secret } from '@aws-amplify/backend'

export const databases: SchemaGenerationConfig = {
  "rds": {
    engine: "mysql",
    hostname: secret("MYSQL_HOSTNAME"),
    username: secret("MYSQL_USERNAME"),
    password: secret("MYSQL_PASSWORD"),
    port: secret("MYSQL_PORT"),
    databaseName: secret("MYSQL_DB_NAME"),
    // Provide an optional output file path  
    // outputFile: 'my-custom-path/schema.mysql.ts' 
  }, 
}
```

### (Optional) Configure VPC settings for database connection 
If your database is behind a VPC, you must also provide the VPC settings for database connection.


## Step 3 - Generate database schema

Run the following command to generate the Data schema with your database connection information.

```bash
npx amplify generate schema-from-databases schema-generator.config.ts
```

This creates a new **schema.rds.ts** with a schema reflecting the types of your database. Import the schema to your **amplify/data/resource.ts** file and 

```ts
import { a, defineData } from '@aws-amplify/backend';
// highlight-next-line
import { schema as auroraSchema } from './schema.aurora.ts';

// Relational database sources can coexist with DynamoDB tables managed by Amplify.
const schema = a.schema({
  Todo: a.model({
    content: a.string(),
    isDone: a.boolean(),
  }),
});

// Use the .combine() operator to stitch together the models backed by DynamoDB
// and the models backed by Postgres or MySQL databases.
// highlight-next-line
const combinedSchema = a.schema.combine([schema, auroraSchema]);

export type Schema = typeof combinedSchema;
export const data = defineData({
  // highlight-next-line
  schema: combinedSchema,
});
```

## Step 4 - Add authorization rules

```ts
import { a, defineData } from '@aws-amplify/backend'
import { schema as rdsSchema } from './schema.rds.ts'

// Add an authorization rule to the schema
// highlight-next-line
rdsSchema.models.Todo.authorization([a.allow.public()])

const schema = a.schema({
  Todo: a.model({
    content: a.string()
    isDone: a.boolean()
  })
})

const combinedSchema = a.schema.combine([
  schema,
  rdsSchema
])

export type Schema = typeof schema
export const data = defineData({
  schema: combinedSchema
})
```

## Step 5 - Deploy your Data resources using the cloud sandbox

Finally, you can now validate your Data resources with your cloud sandbox:

```bash
npx amplify sandbox
```

## Rename generated models and fields 

```ts
import { a, defineData } from '@aws-amplify/backend'
import { schema as rdsSchema } from './schema.rds.ts'

// Rename models or fields to be more idiomatic for frontend code
// highlight-start
rdsSchema.models.todos.renameTo("Todo")
rdsSchema.models.todos.fields.title.renameTo("content")
// highlight-end

const schema = a.schema({
  Todo: a.model({
    content: a.string()
    isDone: a.boolean()
  })
}).authorization([a.allow.public()])

const combinedSchema = a.schema.combine([
  schema,
  rdsSchema
])

export type Schema = typeof schema
export const data = defineData({
  schema: combinedSchema
})
```

## Add relationships between tables

```ts
import { a, defineData } from '@aws-amplify/backend'
import { schema as rdsSchema } from './schema.rds.ts'

// highlight-start
rdsSchema.models.Todo.addRelationships({
  comments: a.hasMany("Comment").references("todo_id"),
  notes: a.hasMany("Note").references("todoId")
})
// highlight-end

const ddbSchema = a.schema({
   Note: a.model({
     content: a.string(),
     todoId: a.id()
     todo: a.belongsTo("Todo").references("todoId")
   })
})

const combinedSchema = a.schema.combine([rdsSchema, ddbSchema])

export type Schema = typeof combinedSchema
export const data = defineData({
  schema: combinedSchema
})
```

## Invoke SQL statements with custom queries and mutations

You can either define inline SQL statements or reference a file path containing custom sql statements in designated files. If both inline and custom statements are set, the sandbox/build should error out.

```ts

import { a, defineData } from '@aws-amplify/backend'
import { schema as rdsSchema } from './schema.rds.ts'

// Add custom mutations or queries that execute SQL statements
// highlight-start
rdsSchema.addQueries({
  searchTodoBasedOnGeolocation: a.query()
    .arguments({
      lat: a.float(),
      long: a.float(),
      radiusInMeters: a.float()
    })
    .returns(a.ref("Todo").array())
    .handler(a.handler.inlineSql`
      SELECT *
      FROM todos
      WHERE ST_DistanceSphere(
        location,
        ST_MakePoint(:lat, :long)
      ) <= :radiusInMeters`
    )
    .authorization([a.allow.public()])
})
// highlight-end

// highlight-start
rdsSchema.setSqlStatementFolderPath(path.join(__dirname, 'aurora-statements'))
// Create a "updateTodoBasedOnLocation.sql" file with the statement
rdsSchema.addMutation({
  updateTodoBasedOnLocation: a.mutation()
    .arguments({
      lat: a.float(),
      long: a.float(),
      radiusInMeters: a.float(),
      todoChange: a.ref("Todo")
    })
    .returns(a.ref("Todo"))
   .handler(a.handler.sqlReference()) 
    .authorization([a.allow.public()])
})
// highlight-end

const schema = a.schema({
  Todo: a.model({
    content: a.string()
    isDone: a.boolean()
  })
})

const combinedSchema = a.schema.combine([
  schema,
  rdsSchema
])

export type Schema = typeof combinedSchema
export const data = defineData({
  schema: combinedSchema
})
```

### Exclude or include only specific tables to introspect


### Generate Data schemas for multiple databases

You should see a read-only (TK) new schema.rds.tsx file in `amplify/data` now. This file contains a TypeScript representation of your relational database tables.

Next, import the schema into your data resource file to deploy to the cloud.

```ts title="amplify/data/resource.ts"
import { a, defineData } from '@aws-amplify/backend';
// highlight-next-line
import { schema as rdsSchema } from './schema.rds.ts';

// Relational database sources can coexist with DynamoDB tables managed by Amplify.
const schema = a.schema({
  Todo: a.model({
    content: a.string(),
    isDone: a.boolean(),
  }),
});

// Use the `.combine()` operator to stitch together the models backed by DynamoDB
// and the models backed by Postgres or MySQL databases.
// highlight-start
const combinedSchema = a.schema.combine([schema, rdsSchema]);
// highlight-end

export type Schema = typeof schema;
export const data = defineData({
  // highlight-next-line
  schema: combinedSchema,
});
```

Once your cloud sandbox has updated, you should be able to call any CRUDL operations for your relational database.

```bash
npx amplify sandbox
```

### Apply authorization rules

```ts title="amplify/data/resource.ts"
import { a, defineData } from '@aws-amplify/backend'
import { schema as rdsSchema } from './schema.rds.ts'

// Add an authorization rule to the schema
// highlight-next-line
rdsSchema.models.Todo.authorization([a.allow.public()])

const schema = a.schema({
  Todo: a.model({
    content: a.string()
    isDone: a.boolean()
  })
})

const combinedSchema = a.schema.combine([
  schema,
  rdsSchema
])

export type Schema = typeof schema
export const data = defineData({
  schema: combinedSchema
})
```

### Rename inferred model and field names

```ts title="amplify/data/resource.ts"
import { a, defineData } from '@aws-amplify/backend'
import { schema as rdsSchema } from './schema.rds.ts'

// Rename models or fields to be more idiomatic for frontend code
// highlight-start
rdsSchema.models.todos.renameTo("Todo")
rdsSchema.models.todos.fields.title.renameTo("content")
// highlight-end

const schema = a.schema({
  Todo: a.model({
    content: a.string()
    isDone: a.boolean()
  })
}).authorization([a.allow.public()])

const combinedSchema = a.schema.combine([
  schema,
  rdsSchema
])

export type Schema = typeof schema
export const data = defineData({
  schema: combinedSchema
})
```

### Invoke SQL statements with custom queries and mutations

```ts title="amplify/data/resource.ts"
import { a, defineData } from '@aws-amplify/backend'
import { schema as rdsSchema } from './schema.rds.ts'

// Add custom mutations or queries that execute SQL statements
// highlight-start
rdsSchema.addQueries({
  searchTodoBasedOnGeolocation: a.query()
    .arguments({
      lat: a.float(),
      long: a.float(),
      radiusInMeters: a.float()
    })
    .returns(a.ref("Todo").array())
    .handler(sql`
      SELECT *
      FROM todos
      WHERE ST_DistanceSphere(
        location,
        ST_MakePoint(:lat, :long)
      ) <= :radiusInMeters
    `)
    .authorization([a.allow.public()])
})
// highlight-end

const schema = a.schema({
  Todo: a.model({
    content: a.string()
    isDone: a.boolean()
  })
})

const combinedSchema = a.schema.combine([
  schema,
  rdsSchema
])

export type Schema = typeof combinedSchema
export const data = defineData({
  schema: combinedSchema
})
```

# NOTES:
- Auto-enabled debug mode on sandbox ðŸ”¥
