export const meta = {
  title: 'Connect your app to existing MySQL and PostgreSQL database.',
  description:
    'Learn how to connect your app to existing MySQL and PostgreSQL database.'
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

Amplify's native integration supports any MySQL or Postgres database, no matter if they're hosted on AWS within a VPC or outside of AWS with a 3rd party hosted database provider.

You must have these information handy for your database:

- Database hostname
- Database port
- Database username
- Database user password
- Database name

## Step 1 - Set secrets for database connection

First, provide all the database connection information as secrets, you can use the Amplify sandbox's secret functionality to set them or go to the Amplify console to set secrets in a shared environment:

<BlockSwitcher>
<Block name="Sandbox">

```bash
npx amplify sandbox secret set MYSQL_CONNECTION_STRING
# postgres://rene:password123@hohuoeatsuhsaoetu.eoauoaeum/main
```

</Block>

<Block name="Amplify console"></Block>

</BlockSwitcher>

## Step 2 - Generate database schema

Run the following command to generate the Data schema with your database connection information.

```bash
npx amplify generate schema-from-database --connection-uri-secret MYSQL_CONNECTION_STRING --out amplify/data/schema.rds.ts
```

<Callout info title="VPC connection">

If your database is behind a VPC, we'll autodetect the VPC configuration based on your connection string. This happens via a hostname lookup within your account. The sandbox profile in your account needs to have XYZ permissions to do a VPC lookup and connect to the VPC. (If your database is in a private subnet, we'll provision a Lambda to retrieve the database schema in order for us to generate the TypeScript data model.) TODO: Chris / Ed to connect on how best to implement this.

</Callout>

This creates a new **schema.rds.ts** with a schema reflecting the types of your database. Import the schema to your **amplify/data/resource.ts** file and

```ts
import { a, defineData } from '@aws-amplify/backend';
// highlight-next-line
import { schema as auroraSchema } from './schema.rds.ts';

// Relational database sources can coexist with DynamoDB tables managed by Amplify.
const schema = a.schema({
  Todo: a.model({
    content: a.string(),
    isDone: a.boolean()
  })
});

// Use the .combine() operator to stitch together the models backed by DynamoDB
// and the models backed by Postgres or MySQL databases.
// highlight-next-line
const combinedSchema = a.schema.combine([schema, auroraSchema]);

export type Schema = typeof combinedSchema;
export const data = defineData({
  // highlight-next-line
  schema: combinedSchema
});
```

## Step 3 - Add authorization rules

```ts
import { a, defineData } from '@aws-amplify/backend'
import { schema as rdsSchema } from './schema.rds.ts'

// Add an authorization rule to the schema
// highlight-next-line
rdsSchema.models.Todo.authorization([a.allow.public()])

const schema = a.schema({
  Todo: a.model({
    content: a.string()
    isDone: a.boolean()
  })
})

const combinedSchema = a.schema.combine([
  schema,
  rdsSchema
])

export type Schema = typeof schema
export const data = defineData({
  schema: combinedSchema
})
```

## Step 4 - Deploy your Data resources using the cloud sandbox

Finally, you can now validate your Data resources with your cloud sandbox:

```bash
npx amplify sandbox
```

## Rename generated models and fields

```ts
import { a, defineData } from '@aws-amplify/backend'
import { schema as rdsSchema } from './schema.rds.ts'

// Rename models or fields to be more idiomatic for frontend code
// highlight-start
rdsSchema.models.todos.renameTo("Todo")
rdsSchema.models.todos.fields.title.renameTo("content")
// highlight-end

const schema = a.schema({
  Todo: a.model({
    content: a.string()
    isDone: a.boolean()
  })
}).authorization([a.allow.public()])

const combinedSchema = a.schema.combine([
  schema,
  rdsSchema
])

export type Schema = typeof schema
export const data = defineData({
  schema: combinedSchema
})
```

Step 5 - Configure the `amplify.yml` TK

Customers need to update the `amplify.yml` to generate the DB schema if the DB is in a different VPC. Etc Etc. TK

TK: npx amplify generate config --connection-string $BRANCH_CONNECTION_STRING

## Add relationships between tables

```ts
import { a, defineData } from '@aws-amplify/backend'
import { schema as rdsSchema } from './schema.rds.ts'

// highlight-start
rdsSchema.models.Todo.addRelationships({
  comments: a.hasMany("Comment").references("todo_id"),
  notes: a.hasMany("Note").references("todoId")
})
// highlight-end

const ddbSchema = a.schema({
   Note: a.model({
     content: a.string(),
     todoId: a.id()
     todo: a.belongsTo("Todo").references("todoId")
   })
})

const combinedSchema = a.schema.combine([rdsSchema, ddbSchema])

export type Schema = typeof combinedSchema
export const data = defineData({
  schema: combinedSchema
})
```

## Invoke SQL statements with custom queries and mutations

You can either define inline SQL statements or reference a file path containing custom sql statements in designated files. If both inline and custom statements are set, the sandbox/build should error out.

```ts

import { a, defineData } from '@aws-amplify/backend'
import { schema as rdsSchema } from './schema.rds.ts'

// Add custom mutations or queries that execute SQL statements
// highlight-start
rdsSchema.addQueries({
  searchTodoBasedOnGeolocation: a.query()
    .arguments({
      lat: a.float(),
      long: a.float(),
      radiusInMeters: a.float()
    })
    .returns(a.ref("Todo").array())
    .handler(a.handler.inlineSql`
      SELECT *
      FROM todos
      WHERE ST_DistanceSphere(
        location,
        ST_MakePoint(:lat, :long)
      ) <= :radiusInMeters`
    )
    .authorization([a.allow.public()])
})
// highlight-end

// highlight-start
rdsSchema.setSqlStatementFolderPath('./aurora-statements/'))
// Create a "updateTodoBasedOnLocation.sql" file with the statement
rdsSchema.addMutation({
  updateTodoBasedOnLocation: a.mutation()
    .arguments({
      lat: a.float(),
      long: a.float(),
      radiusInMeters: a.float(),
      todoChange: a.ref("Todo")
    })
    .returns(a.ref("Todo"))
   .handler(a.handler.sqlReference())
    .authorization([a.allow.public()])
})
// highlight-end

const schema = a.schema({
  Todo: a.model({
    content: a.string()
    isDone: a.boolean()
  })
})

const combinedSchema = a.schema.combine([
  schema,
  rdsSchema
])

export type Schema = typeof combinedSchema
export const data = defineData({
  schema: combinedSchema
})
```

### Exclude or include only specific tables to introspect

### Generate Data schemas for multiple databases

You should see a read-only (TK) new schema.rds.tsx file in `amplify/data` now. This file contains a TypeScript representation of your relational database tables.

Next, import the schema into your data resource file to deploy to the cloud.

```ts title="amplify/data/resource.ts"
import { a, defineData } from '@aws-amplify/backend';
// highlight-next-line
import { schema as rdsSchema } from './schema.rds.ts';

// Relational database sources can coexist with DynamoDB tables managed by Amplify.
const schema = a.schema({
  Todo: a.model({
    content: a.string(),
    isDone: a.boolean()
  })
});

// Use the `.combine()` operator to stitch together the models backed by DynamoDB
// and the models backed by Postgres or MySQL databases.
// highlight-start
const combinedSchema = a.schema.combine([schema, rdsSchema]);
// highlight-end

export type Schema = typeof schema;
export const data = defineData({
  // highlight-next-line
  schema: combinedSchema
});
```

Once your cloud sandbox has updated, you should be able to call any CRUDL operations for your relational database.

```bash
npx amplify sandbox
```

### Apply authorization rules

```ts title="amplify/data/resource.ts"
import { a, defineData } from '@aws-amplify/backend'
import { schema as rdsSchema } from './schema.rds.ts'

// Add an authorization rule to the schema
// highlight-next-line
rdsSchema.models.Todo.authorization([a.allow.public()])

const schema = a.schema({
  Todo: a.model({
    content: a.string()
    isDone: a.boolean()
  })
})

const combinedSchema = a.schema.combine([
  schema,
  rdsSchema
])

export type Schema = typeof schema
export const data = defineData({
  schema: combinedSchema
})
```

### Rename inferred model and field names

```ts title="amplify/data/resource.ts"
import { a, defineData } from '@aws-amplify/backend'
import { schema as rdsSchema } from './schema.rds.ts'

// Rename models or fields to be more idiomatic for frontend code
// highlight-start
rdsSchema.models.todos.renameTo("Todo")
rdsSchema.models.todos.fields.title.renameTo("content")
// highlight-end

const schema = a.schema({
  Todo: a.model({
    content: a.string()
    isDone: a.boolean()
  })
}).authorization([a.allow.public()])

const combinedSchema = a.schema.combine([
  schema,
  rdsSchema
])

export type Schema = typeof schema
export const data = defineData({
  schema: combinedSchema
})
```

### Invoke SQL statements with custom queries and mutations

```ts title="amplify/data/resource.ts"
import { a, defineData } from '@aws-amplify/backend'
import { schema as rdsSchema } from './schema.rds.ts'

// Add custom mutations or queries that execute SQL statements
// highlight-start
rdsSchema.addQueries({
  searchTodoBasedOnGeolocation: a.query()
    .arguments({
      lat: a.float(),
      long: a.float(),
      radiusInMeters: a.float()
    })
    .returns(a.ref("Todo").array())
    .handler(sql`
      SELECT *
      FROM todos
      WHERE ST_DistanceSphere(
        location,
        ST_MakePoint(:lat, :long)
      ) <= :radiusInMeters
    `)
    .authorization([a.allow.public()])
})
// highlight-end

const schema = a.schema({
  Todo: a.model({
    content: a.string()
    isDone: a.boolean()
  })
})

const combinedSchema = a.schema.combine([
  schema,
  rdsSchema
])

export type Schema = typeof combinedSchema
export const data = defineData({
  schema: combinedSchema
})
```

# NOTES:

- Auto-enabled debug mode on sandbox ðŸ”¥
