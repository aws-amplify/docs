export const meta = {
  title: 'Modeling relationships',
  description:
    'Learn about the types of model relationships and modeling relationships.'
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

# Relationships

- [Relationships](#relationships)
  - [Intro](#intro)
  - [Identifiers](#identifiers)
    - [Single field identifier](#single-field-identifier)
    - [Composite identifier](#composite-identifier)
  - [Types of relationships](#types-of-relationships)
  - [Modeling relationships](#modeling-relationships)
    - [Has One relationship](#has-one-relationship)
    - [Has Many relationship](#has-many-relationship)
    - [Belongs To relationship](#belongs-to-relationship)
      - [Bi-directional Has One relationship](#bi-directional-has-one-relationship)
      - [Bi-directional Has Many relationship](#bi-directional-has-many-relationship)
    - [Many-to-many relationship](#many-to-many-relationship)
    - [Create multiple relationships between two models](#create-multiple-relationships-between-two-models)
    - [Relationships to a model with a composite identifier](#relationships-to-a-model-with-a-composite-identifier)
  - [Retrieving related models](#retrieving-related-models)
  - [Manipulating relationships](#manipulating-relationships)


## Intro
Applications that work with data need to define the entities that represent said data.

Entities are typically stored across different tables in a database, and items in a given table need a way to be **uniquely identified**. This is achieved by defining a field (or a combination of fields) that will hold a value (or values) to unambiguously refer to the item.

When modeling applications, there is often the need to **establish relationships** between the entities. These relationships are achieved by having a field (or fields) that hold the value of the unique identifier of the related entity.

Sometimes when retrieving data for a given entity, retrieving its relationships too can be an expensive operation; for this reason it is important to offer a mechanism for consumers to specify if relationships should be  lazily or eagerly retrieved. TypeBeast also provides a mechanism to do this.

TypeBeast's mechanism to model a schema provides (among other things) a way to **define identifiers**, **retrieve a subset of an entity's attributes** and **express relationships** between the entities.

## Identifiers
Identifiers are defined using the `.identifier()` method on a model definition. Its usage is optional, when it is not present, the model will automatically have a field called `id` of type `.autoUuid()` .

```typescript
const schema = a.schema({
  Todo: a.model({
    content: a.string(),
    completed: a.boolean(),
  })
});
```

```ts
const client = generateClient<Schema>();

const todo = await client.models.Todo.create({ content: 'Buy Milk', completed: false });
console.log(`New Todo created: ${todo.id}`); // New Todo created: 5DB6B4CC-CD41-49F5-9844-57C0AB506B69
```

If desired, TypeBeast allows you to define identifiers of the following types:
- Single field identifier
  - With a consumer provided value (type: `string`)
  - With an autogenerated value (type: `autoUuid`, `autoUlid`, `autoKsuid`)
- Composite identifier
  - With a consumer provided value (type: `string`)
  - With an autogenerated value (type: `autoUuid`, `autoUlid`, `autoKsuid`)

### Single field identifier

If the default `id` identifier field  needs to be customized, you can do so by passing the name of another field.

```typescript
const schema = a.schema({
  Todo: a.model({
    todoId: a.autoUuid(), // By specifying autoUuid instead of string, the field gets a value automatically
    title: a.string(),
    completed: a.boolean(),
  }).identifier('todoId')
});

const client = generateClient<Schema>();

const todo = await client.models.Todo.create({ title: 'Buy Milk', completed: false });
console.log(`New Todo created: ${todo.todoId}`); // New Todo created: 15C4B187-D08A-435C-BA32-417557AAC0EE
```

### Composite identifier

For cases where items are uniquely identified by more than a single field, you can pass an array of the field names to the `identifier()` function:

```typescript
const schema = a.schema({
  StoreBranch: a.model({
    tenantId: a.string(),
    name: a.string(),
    country: a.string(),
    state: a.string(),
    city: a.string(),
    zipCode: a.string(),
    streetAddress: a.string(),
  }).identifier(['tenantId', 'name'])
});

const client = generateClient<Schema>();

const branch = await client.models.StoreBranch.get({ tenantId: '123', name: 'Downtown' }); // All identifier fields are required when retrieving an item
```
## Types of relationships

|Relationship|Description|
|------------|--------|
|`hasOne`|Create a one-directional one-to-one relationship between two models. For example, a Project "has one" Team. This allows you to query the team from the project record.
|`hasMany`|Create a one-directional one-to-many relationship between two models. For example, a Post has many comments. This allows you to query all the comments from the post record.
|`belongsTo`|Use a "belongs to" relationship to make a "has one" or "has many" relationship bi-directional. For example, a Project has one Team and a Team belongs to a Project. This allows you to reference the team from the project record and vice versa.
|`manyToMany`| Creates a bi-directional relationship, it needs to be defined on both related models. For example, a Blog has many Tags and a Tag has many Blogs.

## Modeling relationships
When modeling relationships, the cardinality is encoded in the method call itself, meaning that there's no need to define fields as `.array()` or similar. A `hasOne('Team')` implies a field of type `Team`, a `hasMany('Comments')` implies a field of type `Array<Comments>`.
### Has One relationship

Create a one-directional one-to-one relationship between two models using the `hasOne()` method.

In the example below, a Project has a Team.

```typescript
const schema = a.schema({
  Project: a.model({
    name: a.string(),
    team: a.hasOne('Team')
  }),
  Team: a.model({
    name: a.string(),
  }),
});
```
By using `hasOne` this way, it will automatically generate a field to hold the identifier of the related model.
To customize the field that holds the relationship information, set the `field` argument and match it to a field on the type

```typescript
const schema = a.schema({
  Project: a.model({
    name: a.string(),
    teamID: a.string(), // 1. add a field to store the team's unique identifier
    team: a.hasOne('Team').references('teamId'), // 2. reference the team's 
  }),
  Team: a.model({
    name: a.string(),
  }),
});
```

A `hasOne` relationship always uses a reference to the identifier field (or fields) of the related model, by default `id` unless overwritten with the `identifier()` method.

### Has Many relationship

Create a one-directional one-to-many relationship between two models using the `hasMany()` method.

In the example below, a Post has many Comments.

```typescript
const schema = a.schema({
  Post: a.model({
    title: a.string(),
    comments: a.hasMany('Comment')
  }),
  Comment: a.model({
    content: a.string(),
  }),
});
```

As with other relationship types, the field used to hold the identifier for the related entity can be customized by passing a second argument with a `field` attribute.

### Belongs To relationship

Make a "has one" or "has many" relationship bi-directional with the `belongsTo()` method.

> Note: The `belongsTo()` method requires that a `hasOne()` or `hasMany()` relationship already exists from parent to the related model.

#### Bi-directional Has One relationship
```typescript
const schema = a.schema({
  Project: a.model({
    name: a.string(),
    team: a.hasOne('Team')
  }),
  Team: a.model({
    name: a.string(),
    project: a.belongsTo('Project'),
  }),
});

const client = generateClient<Schema>();

const { data: team } = await client.models.Team.get('FABF27EE-25D2-4851-AE1C-09BCA1604C77');

console.log((await team.project()).name); // There is a 'project' field in the team

(await team.project()).team === team; // Navigating back to the team from the project
```

#### Bi-directional Has Many relationship

```typescript
const schema = a.schema({
  Post: a.model({
    title: a.string(),
    comments: a.hasMany('Comment'),
  }),
  Comment: a.model({
    content: a.string(),
    post: a.belongsTo('Post'),
  }),
});

const client = generateClient<Schema>();

const { data: post } = await client.models.Post.get('FABF27EE-25D2-4851-AE1C-09BCA1604C77');

(await post.comments())[0].post === post; // Navigating back to the post from the comment
```

### Many-to-many relationship
Create a many-to-many relationship between two models with the `manyToMany()` method. Provide a common `relationName` on both models to join them into a many-to-many relationship. 

```typescript
const schema = a.schema({
  Post: a.model({
    title: a.string(),
    content: a.string(),
    tags: a.manyToMany('Tag', { relationName: 'PostTags'})
  }),
  Tag: a.model({
    name: a.string(),
    posts: a.manyToMany('Post', { relationName: 'PostTags'})
  }),
});
```

### Create multiple relationships between two models

```typescript
const schema = a.schema({
  Employee: a.model({
    firstName: a.string(),
    lastName: a.string(),
  }),
  Organization: a.model({
    name: a.string(),
    individualContributors: a.hasMany('Employee'),
    managers: a.hasMany('Employee'),
  }),
});

const client = generateClient<Schema>();

const { data: org } = await client.models.Organization.get('AE6191BF-FEB4-4D8B-867D-898A7DA33101');

const { data: ics } = await org.individualContributors();
const { data: managers } = await org.managers();
```

### Relationships to a model with a composite identifier

TK: stored in a single field with a separator? e.g. `manger.branch = 'TENANT123>Downtown'`

```typescript
const schema = a.schema({
  StoreBranch: a.model({
    tenantId: a.string(),
    name: a.string(),
    country: a.string(),
    state: a.string(),
    city: a.string(),
    zipCode: a.string(),
    streetAddress: a.string(),
  }).identifier(['tenantId', 'name'])
});
```

## Retrieving related models

```typescript
const schema = a.schema({
  Project: a.model({
    name: a.string(),
    team: a.hasOne('Team'),
  }),
  Team: a.model({
    name: a.string(),
  }),
});

const client = generateClient<Schema>();

const { data: project } = await client.models.Project.get('1234');
project.name;
(await project.team).name // project.team is typed as `Lazy<Team>` and can be awaited

const projectWithTeam = await client.models.Project.get('1234', ['team.*']);
project.team.name // All team attributes were requested, so no need to await, it was eagerly loaded
```

## Manipulating relationships

NO CASCADING BEHAVIOR
- Save in the right order (e.g. parent before children)
- What about bi-directionality then? chicken and egg situation

```typescript
client.Models.Project
```
