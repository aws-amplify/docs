export const meta = {
  title: 'Add custom business logic (Experimental)',
  description:
    'Learn how to customize your business logic for queries, mutations, and subscriptions.'
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

<Callout info>

**Coming soon:** The custom business logic experience in Amplify (Gen 2) is still under development. Expect the API surface to change dramatically during the Gen 2 preview period. If you have any feedback on the desired developer experience, please [file a GitHub issue](https://github.com/aws-amplify/amplify-backend).

</Callout>

In this section you'll learn how to create a custom mutation and query in three steps

1. Define a custom query or mutation
2. Configure custom business logic handler code
3. Invoke the custom query or mutation

## Step 1 - Define a custom query or mutation

| Type         | When to choose                                                                 |
| ------------ | ------------------------------------------------------------------------------ |
| Query        | When the request is read-only and it doesn't intend to modify any backend data |
| Mutation     | When the request is intended to modify the backend data                        |

Every custom query or mutation requires you to set a return type and, optionally, arguments. Use `a.query()` or `a.mutation()` to define your custom query or mutation in your **amplify/data/resource.ts** file:

<BlockSwitcher>

<Block name="Custom query">

```ts
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a.schema({
  // 1. Define your return type as a custom type
  EchoResponse: a.customType({
    content: a.string(),
    executionDuration: a.float()
  }),

  // 2. Define your query with the return type and, optionally, arguments
  echo: a.query()
    // arguments that this query accepts
    .arguments({ 
      content: a.string()
    }) 
    // return type of the query
    .returns(a.ref('EchoResponse'))
    // only allow signed in users to call this API
    .authorization([a.allow.private()])
})

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
})
```

</Block>

<Block name="Custom mutation">

```ts
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a.schema({
  // 1. Define your return type as a custom type or model
  Post: a.customType({
    id: a.id(),
    content: a.string(),
    likes: a.integer()
  }),

  // 2. Define your mutation with the return type and, optionally, arguments
  likePost: a.mutation()
    // arguments that this query accepts
    .arguments({ 
      content: a.string()
    }) 
    // return type of the query
    .returns(a.ref('Post'))
    // only allow signed in users to call this API
    .authorization([a.allow.private()])
})

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
})
```

</Block>

</BlockSwitcher>

## Step 2 - Configure custom business logic handler code

<Callout info>

**Coming soon:** The following example requires you to use JavaScript. We're working on adding TypeScript support natively for Gen 2's general availability. [Follow us on X](https://x.com/awsamplify) to keep up with updates to this functionality.

</Callout>

After your query or mutation is defined, you need to author your custom business logic in a Lambda function. In your **amplify/data/** folder, create a new folder named after your mutation or query with an **index.js** file. 

**amplify/data/echo/index.js**

```js
exports.handler = async (event) => {
  const start = performance.now()
  return {
    content: event.arguments.name,
    executionDuration: performance.now() - start
  }
}
```

In your **amplify/data/resource.ts** file, import the function using the **experimental** `Func` functionality and then reference the function with your query or mutation using the `.function()` modifier along with the `functions` map of `defineData`.

**amplify/data/resource.ts**

```ts
import {
  type ClientSchema,
  a,
  defineData,
  Func // Step 1 - import "Func" to create new functions
} from '@aws-amplify/backend';

const schema = a.schema({
  EchoResponse: a.customType({
    content: a.string(),
    executionDuration: a.float()
  }),

  echo: a.query()
    .arguments({ content: a.string() }) 
    .returns(a.ref('EchoResponse'))
    .authorization([a.allow.private()])
    // Step 2 - Define a function key ("echoHandler") that will be used
    // to map this query to the corresponding functions provided to
    // defineData(...)
    .function('echoHandler')
})

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  // Step 3 - map the function key to the newly created function
  functions: {
    'echoHandler': Func.fromDir({
      codePath: './echo',
      name: 'echoHandlerFunc',
    })
  }
})
```

## Step 3 - Invoke the custom query or mutation

<Callout info>

**Coming soon:** The following example requires you to manually generate GraphQL client code as an escape hatch to invoke the custom query or mutation. Amplify Data is built with GraphQL under the hood. While you're not expected to know GraphQL or have to interface with GraphQL directly when Amplify (Gen 2) becomes generally available, it is helpful to understand the [underlying GraphQL concepts](https://graphql.org) that enable Amplify Data's functionality.

For Gen 2's general availability, we plan on integrating this first class into the Data client, allowing you to call a custom query or mutations via an experience such as:

```ts
const response = await client.queries.echo({ content: 'hello' })
```

</Callout>

In the current Amplify (Gen 2) preview, you must first generate GraphQL client code for your custom queries and mutations and then pass them into the `client.graphql(...)` operation. In your Terminal, run the following command:

```bash
npx amplify generate graphql-client-code \
--format graphql-codegen \
--statement-target typescript \
--type-target typescript \
--out ./graphql \
--stack <YOUR_STACK_NAME_HERE> 
# you can find your stack name in your "npx amplify sandbox"
# console logs. It has the following format:
# amplify-<app-name>-<user-name>-sandbox-<unique-id>
```

This should create a the following set of GraphQL client helper code for you under **graphql/**:
- **API.ts** includes all the type definitions for queries, mutations, and subscriptions
- **mutations.ts** includes all GraphQL mutations from your API
- **queries.ts** includes all GraphQL queries from your API
- **subscriptions.ts** includes all GraphQL subscriptions from your API

To call the `echo` query from step 1, we need to import the `echo` function from **queries.ts** and pass it as a query to `client.graphql(...)`.

```ts
import { generateClient } from 'aws-amplify/data'
import { type Schema } from '@/amplify/data/resource'
import * as queries from '@/graphql/queries'

const client = generateClient<Schema>()

async function callEcho() {
  const response = await client.graphql({
    query: echo,
    variables: {
      content: "Echo me!"
    }
  })

  console.log(response.data.echo?.content)
  console.log(response.data.echo?.executionDuration)
}
```
