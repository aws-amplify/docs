export const meta = {
  title: 'Add custom queries and mutations',
  description:
    'Customize your business logic for queries and mutations.'
};

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

The `a.model()` data model provides a solid foundation for querying, mutating, and fetching data. However, you may need additional customizations to meet specific requirements around custom API requests, response formatting, and or fetching from external data sources.

In the following sections, we walk through the three steps to create a custom query or mutation:

1. Define a custom query or mutation
2. Configure custom business logic handler code
3. Invoke the custom query or mutation

## Step 1 - Define a custom query or mutation

| Type | When to choose |
| --- | --- |
| Query | When the request only needs to read data and will not modify any backend data |
| Mutation | When the request will modify backend data |

For every custom query or mutation, you need to set a return type and, optionally, arguments. Use `a.query()` or `a.mutation()` to define your custom query or mutation in your **amplify/data/resource.ts** file:

<BlockSwitcher>

<Block name="Custom query">

```ts
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a.schema({
  // 1. Define your return type as a custom type
  EchoResponse: a.customType({
    content: a.string(),
    executionDuration: a.float()
  }),

  // 2. Define your query with the return type and, optionally, arguments
  echo: a
    .query()
    // arguments that this query accepts
    .arguments({
      content: a.string()
    })
    // return type of the query
    .returns(a.ref('EchoResponse'))
    // only allow signed-in users to call this API
    .authorization([a.allow.private()])
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema
});
```

</Block>

<Block name="Custom mutation">

```ts
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a.schema({
  // 1. Define your return type as a custom type or model
  Post: a.model({
    id: a.id(),
    content: a.string(),
    likes: a.integer()
  }),

  // 2. Define your mutation with the return type and, optionally, arguments
  likePost: a
    .mutation()
    // arguments that this query accepts
    .arguments({
      postId: a.string()
    })
    // return type of the query
    .returns(a.ref('Post'))
    // only allow signed-in users to call this API
    .authorization([a.allow.private()])
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema
});
```

</Block>

</BlockSwitcher>

## Step 2 - Configure custom business logic handler code

After your query or mutation is defined, you need to author your custom business logic. You can either define it in a function or using an [AppSync JavaScript resolver](TK).

<BlockSwitcher>

<Block name="Function">

In your **amplify/data/echo-handler/** folder, create a **handler.ts** file.

```ts title="amplify/data/echo-handler.ts"
import type { AppSyncResolverHandler } from 'aws-lambda'; // types imported from @types/aws-lambda

type ResolverArgs = { content: string };

type ResolverResult = { content: string; executionDuration: number };

export const handler: AppSyncResolverHandler<
  ResolverArgs,
  ResolverResult
> = async (event, context) => {
  const start = performance.now();
  return {
    content: `Echoing content: ${event.arguments.content}`,
    executionDuration: performance.now() - start
  };
};
```

In your **amplify/data/resource.ts** file, define the function using `defineFunction` and then reference the function with your query or mutation using the `.function()` modifier along with the `functions` map of `defineData`.

```ts title="amplify/data/resource.ts"
import {
  type ClientSchema,
  a,
  defineData,
  defineFunction // Step 1 - Import "defineFunction" to create new functions
} from '@aws-amplify/backend';

const echoHandler = defineFunction({
  entry: './echo-handler/handler.ts'
})

const schema = a.schema({
  EchoResponse: a.customType({
    content: a.string(),
    executionDuration: a.float()
  }),

  echo: a
    .query()
    .arguments({ content: a.string() })
    .returns(a.ref('EchoResponse'))
    .authorization([a.allow.public()])
    .function('echoHandler')
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'apiKey',
    apiKeyAuthorizationMode: {
      expiresInDays: 30
    },
  },
  functions: {
    'echoHandler': echoHandler
  }
});
```

</Block>
<Block name="Custom resolver powered by AppSync JavaScript resolvers">

Custom resolvers work on a "request/response" basis, you choose a data source, map your request to the data sources' input parameters, and then map the data source's response back to the query/mutation's return type. Custom resolvers provide the benefit of no cold starts but has some limitations, such as TK.

In your **amplify/data/resource.ts** file, define a custom handler using `a.handler.custom`.

```ts title="amplify/data/resource.ts"
import {
  type ClientSchema,
  a,
  defineData,
} from '@aws-amplify/backend';

const schema = a.schema({
  Post: a.model({
    content: a.string(),
    likes: a.integer()
      .authorization([a.allow.private().to(['read'])])
  }).authorization([
    a.allow.owner(),
    a.allow.private().to(['read'])
  ]),

  likePost: a
    .mutation()
    .arguments({ postId: a.id() })
    .returns(a.ref('Post'))
    .authorization([a.allow.private()])
    .handler(a.handler.custom({
      dataSource: a.ref('Post'),
      entry: './increment-like.js'
    }))
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'apiKey',
    apiKeyAuthorizationMode: {
      expiresInDays: 30
    }
  },
});
```

```ts title="amplify/data/increment-like.js"
export function request(ctx) {
  return {
    operation: 'UpdateItem',
    key: util.dynamodb.toMapValues({ id: ctx.args.postId}),
    update: {
      expression: 'ADD likes :plusOne',
      expressionValues: { 'plusOne': { N: 1 } },
    }
  }
}

export function response(ctx: Context) {
  return ctx.result
}
```

By default, you'll be able to access any existing database tables (powered by Amazon DynamoDB) using `a.ref('MODEL_NAME')`. But you can also reference any other external data source from within your AWS account, by adding them to your backend definition. 

The supported data sources are:
- Amazon DynamoDB
- AWS Lambda
- Amazon RDS databases with Data API
- Amazon EventBridge
- OpenSearch
- HTTP endpoints

You can add these additional data sources via our the `amplify/backend.ts` file:

```ts title="amplify/backend.ts"
import * as dynamoDb from 'aws-cdk-lib/aws-dynamodb'
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource.js';
import { data } from './data/resource.js';

export const backend = defineBackend({
  auth,
  data,
});

const externalDataSourcesStack = backend.createStack("MyExternalDataSources")

const externalTable = dynamoDb.Table.fromTableName(externalDataSourcesStack, "MyTable", "MyExternalTable")

backend.data.addDynamoDbDataSource(
  // highlight-next-line
  "ExternalTableDataSource",
  externalTable)
```

In your schema you can then reference these additional data sources based on their name:

```ts title="amplify/data/resource.ts"
import {
  type ClientSchema,
  a,
  defineData,
} from '@aws-amplify/backend';

const schema = a.schema({
  Post: a.model({
    content: a.string(),
    likes: a.integer()
      .authorization([a.allow.private().to(['read'])])
  }).authorization([
    a.allow.owner(),
    a.allow.private().to(['read'])
  ]),

  likePost: a
    .mutation()
    .arguments({ postId: a.id() })
    .returns(a.ref('Post'))
    .authorization([a.allow.private()])
    .handler(a.handler.custom({
      // highlight-next-line
      dataSource: "ExternalTableDataSource",
      entry: './increment-like.js'
    }))
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'apiKey',
    apiKeyAuthorizationMode: {
      expiresInDays: 30
    }
  },
});
```

</Block>
</BlockSwitcher>

<Callout warning>

The `.handler()` accepts an array of handlers that will run in a pipeline. For now, in the developer, you can only use `a.handler.custom()` all other handlers, such as `a.handler.function()` are still under active development. 

</Callout>

{/* <Callout warning>

All handlers must be of the same type. For example, you can't mix and match `a.handler.function` with `a.handler.custom` within a single `.handler()` modifier.

</Callout> */}

## Step 3 - Invoke the custom query or mutation

From your generated Data client, you can find all your custom queries and mutations under `.queries` and `.mutations` respectively.

<BlockSwitcher>
<Block name="Custom query">

```ts
const { data, errors } = await client.queries.echo({
  content: 'hello'
});
```

</Block>
<Block name="Custom mutation">

```ts
const { data, errors } = await client.mutations.likePost({
  postId: 'hello'
});
```

</Block>
</BlockSwitcher>
