import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'About amplifyconfiguration',
  description: 'Reference for amplifyconfiguration.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };
}

In Amplify (Gen 2), the CLI will generate an `amplifyconfiguration.json` file with a similar structure to the configuration files generated by Amplify (Gen 1). Locally, this file is created while using `amplify sandbox`. In Amplify's CI/CD, this is created automatically for you based on the current Amplify app ID and git branch.

You can also manually create this file for a specified Amplify app ID and branch, or an AWS CloudFormation stack name with [`amplify generate config`](/gen2/reference/cli-commands#amplify-generate-config).

{/* @TODO full type/interface to reference */}

## Extending Amplify configuration file

The `amplifyconfiguration.json` file is not just a static artifact; it's designed to be extendable to suit the evolving needs of your application. By leveraging the `addOutput` method from your `backend`, you can programmatically add configurations. This is particularly useful for customizing outputs that are not directly exposed through the Amplify constructs or for dynamically adjusting your app's configuration in response to changes in your backend strategy.

<Callout warning>

Overriding Amplify-managed configurations on `amplifyconfiguration.json` is not supported.

</Callout>

One common scenario where extending the configuration becomes handy is when you need to add custom outputs or extend existing configurations without manual file edits.

Consider a scenario where you want to add output parameters in your `amplifyconfiguration.json` that specify an S3 bucket and its region that your application will use for storing files.

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend";
import { auth } from "./auth/resource";
import { data } from "./data/resource";

const backend = defineBackend({
  auth, 
  data, 
});

backend.addOutput({
  aws_user_files_s3_bucket: "my-externally-managed-bucket",
  aws_user_files_s3_bucket_region: "us-east-1",
});
```

In your frontend end application, you can configure Amplify as follows:

```ts title="src/index.ts"
import { Amplify } from "aws-amplify";
import config from "@/amplifyconfiguration.json";

Amplify.configure(config);
```

### Custom configuration

In addition to extending existing configurations, you can also add custom output parameters to your `amplifyconfiguration.json`. This is useful for surfacing arbitrary outputs, values from custom CDK resources, or any other information that might be necessary for your application's logic or configuration.

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend";
import { auth } from "./auth/resource";
import { data } from "./data/resource";

const backend = defineBackend({
  auth, 
  data, 
});

backend.addOutput({
  custom: {
    apiId: "restAPIId",
    apiEndpoint: "https://api.example.com",
    apiName: "restApiName",
  },
});
```


In your frontend end application, you can access these custom configurations as follows:

```ts title="src/index.ts"
import { Amplify } from "aws-amplify";
import config from "@/amplifyconfiguration.json";

Amplify.configure(config);
const currentConfig = Amplify.getConfig(); 
Amplify.configure({
  ...currentConfig,
  API: {
    REST: {
      [config.custom.apiName]: {
        endpoint: config.custom.apiEndpoint,
        region: "us-east-1",
      },
    },
  },
});
```

{/* @TODO  Link examples once published*/}

