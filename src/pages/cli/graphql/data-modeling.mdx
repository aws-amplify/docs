export const meta = {
  title: `Data modeling`,
  description: `Add authorization rules to your GraphQL schema to control access to your data.`,
};

Amplify automatically creates Amazon DynamoDB database tables for GraphQL types with the `@model` directive in your GraphQL schema. Then you can relate the data models via `@hasOne`, `@hasMany`, `@belongsTo`, and `@manyToMany` relationships.

## Setup database tables

The following GraphQL schema automatically creates a database table for "Todo". `@model` will also automatically add an `id` field as a primary key to the database table. *See [Configure a primary key](#configure-a-primary-key) to learn how to customize the primary key.*

```graphql
type Todo @model {
  content: String
}
```

Amplify CLI generates the Todo database table upon `amplify push` and generates a GraphQL API to perform create, read, update, delete, and list operations for the Todo model.

In addition, `@model` also adds helper fields like `createdAt` and `updatedAt` to your type. The values for those fields are read-only by clients unless explicitly overwritten. See [Customize creation and update timestamps](#customize-creation-and-update-timestamps) to learn more.

Try listing all the todos by executing the following query:
```graphql
query QueryAllTodos {
  listTodos() {
    todos {
      items {
        id
        content
        createdAt
        updatedAt
      }
    }
  }
}
```

### Configure a primary key

Every GraphQL type with the `@model` directive will automatically have a `id` field set as the primary key. You can override this behavior by marking another required field with the `@primaryKey` directive. 

In the example below, `todoId` is the database's primary key and `id` field won't be created automatically anymore by the `@model` directive.
```graphql
type Todo @model {
  todoId: ID! @primaryKey
  content: String
}
```

Without any further configuration, you'll only be able to query for a Todo via a exact equality match of its primary key field. In the example above, the `todoId` field.

> Note: After a primary key is configured and deployed, you can't change it without deleting and recreating your database table.

You can also specify "sort keys" to use a combination of different fields as a primary key. This will also allow you to apply more advanced sorting and filtering conditions on the specified "sort key fields".

```graphql
type Inventory @model {
  productID: ID! @primaryKey(sortKeyFields: ["warehouseID"])
  warehouseID: ID!
  InventoryAmount: Int!
}
```

The schema above will allow you to pass different conditions to query the correct inventory item:
```graphql
query QueryInventoryByProductAndWarehouse($productID: ID!, $warehouseID: ID!) {
  getInventory(productID: $productID, warehouseID: $warehouseID) {
    productID
    warehouseID
    inventoryAmount
  }
}
```

### Configure a secondary index

Amplify uses Amazon DynamoDB tables as the underlying data source for @model types. For key-value databases, it is critical to model your access patterns with "secondary indices". 

> **Amazon DynamoDB** is a key-value and document database that delivers single-digit millisecond performance at any scale but making it work for your access patterns requires a bit of forethought. DynamoDB query operations may use at most two attributes to efficiently query data. The first query argument passed to a query (the hash key) must use strict equality and the second attribute (the sort key) may use gt, ge, lt, le, eq, beginsWith, and between. DynamoDB can effectively implement a wide variety of access patterns that are powerful enough for the majority of applications.

A secondary index consists of a "hash key" and a "sort key". Use the "hash key" to perform strict equality and the "sort key" for greater than (gt), greater equals (ge), less than (lt), less equals (le), eq (equals), begins with, and between operations. 

```graphql
type Customer @model {
  id: ID!
  name: String!
  phoneNumber: String
  accountRepresentativeID: ID! @index(name: "byRepresentative", sortKeyFields: ["id"])
}
```

In the example above, you get the ability to query for "Customer" based on their "accountRepresentativeID":

```graphql
query QueryCustomersForAccountRepresentative($representativeId: ID!) {
  getAccountRepresentative(id: $representativeId) {
    customers {
      items {
        id
        name
        phoneNumber
      }
    }
  }
}
```

## Setup relationships between models

Create "has one", "has many", "belongs to", and "many to many" relationships between `@model` types.

|Relationship|Description|
|------------|--------|
|`@hasOne`|Create a one-directional one-to-one relationship between two models. For example, a Project "has one" Team. This allows you to query the team from the project record.
|`@hasMany`|Create a one-directional one-to-many relationship between two models. For example, a Post has many comments. This allows you to query all the comments from the post record.
|`@belongsTo`|Use a "belongs to" relationship to make a "has one" or "has many" relationship bi-directional. For example, a Project has one Team and a Team belongs to a Project. This allows you to query the team from the project record and vice versa.|
|`@manyToMany`|Configures a "join table" between two models to facilitate a many-to-many relationship. For example, a Blog has many Tags and a Tag has many Blogs.  

### Has One relationship
Create a one-directional one-to-one relationship between two models using the `@hasOne` directive.

In the example below, a Project has a Team.
```graphql
type Project @model {
  id: ID!
  name: String
  team: Team @hasOne
}

type Team @model {
  id: ID!
  name: String!
}
```

This generates queries and mutations that allow you to retrieve the related record from the source record:

```graphql
mutation CreateProject {
  createProject(input: {projectTeamId: "team-id", name: "Some Name"}) {
    team {
      name
      id
    }
    name
    id
  }
}
```

To customize the field to be used for storing the relationship information, set the `fields` array argument and matching it to a field on the type:

```graphql
type Project @model {
  id: ID!
  name: String
  teamID: ID
  team: Team @hasOne(fields: ["teamID"])
}

type Team @model {
  id: ID!
  name: String!
}
```

In this case, the Project type has a `teamID` field added as an identifier for the team. @hasOne can then get the connected Team object by querying the Team table with this `teamID`:

```graphql
mutation CreateProject {
  createProject(input: { name: "New Project", teamID: "a-team-id"}) {
    id
    name
    team {
      id
      name
    }
  }
}
```

A `@hasOne` relationship always uses a reference to the primary key of the related model, by default `id` unless overridden with the [`@primaryKey` directive](#configure-a-primary-key).

### Has Many relationship
Create a one-directional one-to-many relationship between two models using the `@hasMany` directive.

```graphql
type Post @model {
  id: ID!
  title: String!
  comments: [Comment] @hasMany
}

type Comment @model {
  id: ID!
  content: String!
}
```

This generates queries and mutations that allow you to retrieve the related Comment records from the source Post record:

```graphql
mutation CreatePost {
  createPost(input: {title: "Hello World!!"}) {
    title
    id
    comments {
      items {
        id
        content
      }
    }
  }
}
```

Under the hood, `@hasMany` configures a secondary index on the related table to enable you to query the related model from the source model.

You can customize the specific secondary index used for the "has many" relationship. First, configure a secondary index using `@index`. Then, pass in the secondary index name `indexName` parameter and the respective `fields`.

```graphql
type Post @model {
  id: ID!
  title: String!
  comments: [Comment] @hasMany(indexName: "byPost", fields: ["id"])
}

type Comment @model {
  id: ID!
  postID: ID! @index(name: "byPost", sortKeyFields: ["content"])
  content: String!
}
```

In this case, the Comment type has a `postID` field added to store the reference of Post record. @hasMany can then get the connected Comment object by querying the Comment table's secondary index "byPost" with this `postID`:

```graphql
mutation CreatePost {
  createPost(input: {title: "Hello world!"}) {
    comments {
      items {
        postID
        content
        id
      }
    }
    title
    id
  }
}
```

### Belongs To relationship
Make a "has one" or "has many" relationship bi-directional with the `@belongsTo` directive.

<BlockSwitcher>

<Block name='Bi-directional "has one" relationship'>

```graphql
type Project @model {
  id: ID!
  name: String
  team: Team @hasOne
}

type Team @model {
  id: ID!
  name: String!
  project: Project @belongsTo
}
```

This generates queries and mutations that allow you to retrieve the related Comment records from the source Post record and vice versa:

```graphql
mutation CreateProject {
  createProject(input: { name: "New Project", teamID: "a-team-id"}) {
    id
    name
    team { # query team from project
      id
      name
      project { # bi-directional query: team to project
        id
        name
      }
    }
  }
}
```
</Block>

<Block name='Bi-directional "has many" relationship'>

```graphql
type Post @model {
  id: ID!
  title: String!
  comments: [Comment] @hasMany
}

type Comment @model {
  id: ID!
  content: String!
  post: Post @belongsTo
}
```

This generates queries and mutations that allow you to retrieve the related Comment records from the source Post record and vice versa:

```graphql
mutation CreatePost {
  createPost(input: {title: "Hello World!!"}) {
    title
    id
    comments { # query comments from the post
      items {
        id
        content
        post { # bi-directional query: comment to post
          id
          title
        }
      }
    }
  }
}
```
</Block>

</BlockSwitcher>

`@belongsTo` can be used without the `fields` argument. In those cases, a field is automatically generated to reference the parent’s primary key.

Alternatively, you set up a custom field to store the reference of the parent object. An example bidirectional “has many” relationship is shown below.

```graphql
type Post @model {
  id: ID!
  title: String!
  comments: [Comment] @hasMany(indexName: "byPost", fields: ["id"])
}

type Comment @model {
  id: ID!
  postID: ID! @index(name: "byPost", sortKeyFields: ["content"])
  content: String!
  post: Post @belongsTo(fields: ["postID"])
}
```

> Note: The `@belongsTo` directive requires that a `@hasOne` or `@hasMany` relationship already exists from parent to the related model. 

### Many-to-many relationship
Create many-to-many relationship between two models with the `@manyToMany` directive. Provide a common `relationName` on both models to join them into a many-to-many relationship. 

```graphql
type Post @model {
  id: ID!
  title: String!
  content: String
  tags: [Tag] @manyToMany(relationName: "PostTags")
}

type Tag @model {
  id: ID!
  label: String!
  posts: [Post] @manyToMany(relationName: "PostTags")
}
```

Under the hood, the `@manyToMany` directive will create a "join table" named after the `relationName` to facilitate the many-to-many relationship. This generates queries and mutations that allow you to retrieve the related Comment records from the source Post record and vice versa:

```graphql
mutation CreatePost {
  createPost(input: {title: "Hello World!!"}) {
    id
    title
    content
    tags { # queries the "join table" PostTags
      items {
        tag { # related Tag records from Post
          id
          label
          posts { # queries the "join table" PostTags
            items {
              post { # related Post records from Tag
                id
                title
                content
              }
            }
          }
        }
      }
    }
  }
}
```

## Assign default values for fields

You can use the `@default` directive to specify a default value for optional [scalar type fields](https://docs.aws.amazon.com/appsync/latest/devguide/scalars.html) such as `Int`, `String`, and more. 

```graphql
type Todo @model {
  content: String @default(value: "My new Todo")
}
```

If you create a new Todo and don't supply a `content` input, Amplify will ensure that `My new Todo` is auto populated as a value. 

## Advanced

### Rename generated queries and mutations

You can override the names of any `@model`-generated GraphQL queries, mutations and subscriptions, or remove operations. Just supply the desired prefix for the queries, mutations, and subscriptions. To disable a certain operation, just assign their value to `null`

```graphql
type Todo @model(queries: { get: "queryFor" }, mutations: null, subscriptions: null) {
  content: String!
}
```

In the example above, you'll be able to run a `queryForTodo` query to get a single Todo element. Mutations (meaning create, update, and delete) as well as subscriptions are disabled for the Todo model above.

### Customize creation and update timestamps
`@model` directive automatically adds `createdAt` and `updatedAt` timestamps to each entities. The timestamp field names can be changed by passing timestamps attribute to the directive.

```graphql
type Todo @model(timestamps:{createdAt: "createdOn", updatedAt: "updatedOn"}) {
  content: String
}
```

For example, the schema above will allow you to query for the following contents:

```graphql
type Todo {
  id: ID!
  content: String
  createdOn: AWSDateTime!
  updatedOn: AWSDateTime!
}
```

### How it works
The `@model` directive will generate:
- An Amazon DynamoDB table with PAY_PER_REQUEST billing mode enabled by default.
- An AWS AppSync DataSource configured to access the table above.
- An AWS IAM role attached to the DataSource that allows AWS AppSync to call the above table on your behalf.
- Up to 8 resolvers (create, update, delete, get, list, onCreate, onUpdate, onDelete) but this is configurable via the queries, mutations, and subscriptions arguments on the @model directive.
- Input objects for create, update, and delete mutations.
- Filter input objects that allow you to filter objects in list queries and relationship fields.
- For list queries the default number of objects returned is 100. You can override this behavior by setting the limit argument.

Type definition of the `@model` directive:

```graphql
directive @model(
  queries: ModelQueryMap
  mutations: ModelMutationMap
  subscriptions: ModelSubscriptionMap
  timestamps: TimestampConfiguration
) on OBJECT

input ModelMutationMap {
  create: String
  update: String
  delete: String
}

input ModelQueryMap {
  get: String
  list: String
}

input ModelSubscriptionMap {
  onCreate: [String]
  onUpdate: [String]
  onDelete: [String]
  level: ModelSubscriptionLevel
}

enum ModelSubscriptionLevel {
  off
  public
  on
}

input TimestampConfiguration {
  createdAt: String
  updatedAt: String
}
```

## Common data access patterns example

In this "Warehouse management system" example, you will learn how to configure common access patterns for your app. This example has the following types:

- Warehouse
- Product
- Inventory
- Employee
- AccountRepresentative
- Customer

These types have the following common access patterns:

1. [Look up employee details by employee ID](#1-look-up-employee-details-by-employee-id)
2. [Query employee details by employee name](#2-query-employee-details-by-employee-name)
3. [Find an employee's phone number(s)](#3-find-an-employees-phone-number)
4. [Find a customer's phone number(s)](#4-find-a-customers-phone-number)
5. [Get orders for a given customer within a given date range](#5-get-orders-for-a-given-customer-within-a-given-date-range)
6. [Show all open orders within a given date range across all customers](#6-show-all-open-orders-within-a-given-date-range-across-all-customers)
7. [See all employees recently hired](#7-see-all-employees-hired-recently)
8. [Find all employees working in a given warehouse](#8-find-all-employees-working-in-a-given-warehouse)
9. [Get all items on order for a given product](#9-get-all-items-on-order-for-a-given-product)
10. [Get current inventories for a given product at all warehouses](#10-get-current-inventories-for-a-product-at-all-warehouses)
11. [Get customers by account representative](#11-get-customers-by-account-representative)
12. [Get orders by account representative and date](#12-get-orders-by-account-representative-and-date)
13. [Get all items on order for a given product](#13-get-all-items-on-order-for-a-given-product)
14. [Get all employees with a given job title](#14-get-all-employees-with-a-given-job-title)
15. [Get inventory by product and warehouse](#15-get-inventory-by-product-by-warehouse)
16. [Get total product inventory](#16-get-total-product-inventory)
17. [Get account representatives ranked by order total and sales period](#17-get-sales-representatives-ranked-by-order-total-and-sales-period)

The following schema introduces the required indexes and relationships so that we can support these access patterns:

```graphql
# Enables public CRUD data access for prototyping. Review the authorization rule docs to configure production-ready authorization rules. 
input AMPLIFY { global_auth_rule: AuthorizationRule = { allow: public }}

type Order @model {
  id: ID!
  customerID: ID! @index(name: "byCustomerByStatusByDate", sortKeyFields: ["status", "date"]) @index(name: "byCustomerByDate", sortKeyFields: ["date"])
  accountRepresentativeID: ID! @index(name: "byRepresentativebyDate", sortKeyFields: ["date"])
  productID: ID! @index(name: "byProduct", sortKeyFields: ["id"])
  status: String!
  amount: Int!
  date: String!
}

type Customer @model {
  id: ID!
  name: String!
  phoneNumber: String
  accountRepresentativeID: ID! @index(name: "byRepresentative", sortKeyFields: ["id"])
  ordersByDate: [Order] @hasMany(indexName: "byCustomerByDate", fields: ["id"])
  ordersByStatusDate: [Order] @hasMany(indexName: "byCustomerByStatusByDate", fields: ["id"])
}

type Employee @model {
  id: ID!
  name: String! @index(name: "byName", queryField: "employeeByName", sortKeyFields: ["id"])
  startDate: String!
  phoneNumber: String!
  warehouseID: ID! @index(name: "byWarehouse", sortKeyFields: ["id"])
  jobTitle: String! @index(name: "byTitle", queryField: "employeesByJobTitle", sortKeyFields: ["id"])
  newHire: String! @index(name: "newHire", queryField: "employeesNewHire", sortKeyFields: ["id"]) @index(name: "newHireByStartDate", queryField: "employeesNewHireByStartDate", sortKeyFields: ["startDate"])
}

type Warehouse @model {
  id: ID!
  employees: [Employee] @hasMany(indexName: "byWarehouse", fields: ["id"])
}

type AccountRepresentative @model {
  id: ID!
  customers: [Customer] @hasMany(indexName: "byRepresentative", fields: ["id"])
  orders: [Order] @hasMany(indexName: "byRepresentativebyDate", fields: ["id"])
  orderTotal: Int
  salesPeriod: String @index(name: "bySalesPeriodByOrderTotal", queryField: "repsByPeriodAndTotal", sortKeyFields: ["orderTotal"])
}

type Inventory @model {
  productID: ID! @primaryKey(sortKeyFields: ["warehouseID"])
  warehouseID: ID! @index(name: "byWarehouseID", queryField: "itemsByWarehouseID")
  inventoryAmount: Int!
}

type Product @model {
  id: ID!
  name: String!
  orders: [Order] @hasMany(indexName: "byProduct", fields: ["id"])
  inventories: [Inventory] @hasMany(fields: ["id"])
}
```

Now that we have the schema created, let's create the items in the database that we will be operating against:

```graphql
# first
mutation createWarehouse {
  createWarehouse(input: {id: "1"}) {
    id
  }
}

# second
mutation createEmployee {
  createEmployee(input: {
    id: "amanda"
    name: "Amanda",
    startDate: "2018-05-22",
    phoneNumber: "6015555555",
    warehouseID: "1",
    jobTitle: "Manager",
    newHire: "true"}
  ) {
    id
    jobTitle
    name
    newHire
    phoneNumber
    startDate
    warehouseID
  }
}

# third
mutation createAccountRepresentative {
  createAccountRepresentative(input: {
    id: "dabit"
    orderTotal: 400000
    salesPeriod: "January 2019"
  }) {
    id
    orderTotal
    salesPeriod
  }
}

# fourth
mutation createCustomer {
  createCustomer(input: {
    id: "jennifer_thomas"
    accountRepresentativeID: "dabit"
    name: "Jennifer Thomas"
    phoneNumber: "+16015555555"
  }) {
    id
    name
    accountRepresentativeID
    phoneNumber
  }
}

# fifth
mutation createProduct {
  createProduct(input: {
    id: "yeezyboost"
    name: "Yeezy Boost"
  }) {
    id
    name
  }
}

# sixth
mutation createInventory {
  createInventory(input: {
    productID: "yeezyboost"
    warehouseID: "1"
    inventoryAmount: 300
  }) {
    productID
    inventoryAmount
    warehouseID
  }
}

# seventh
mutation createOrder {
  createOrder(input: {
    amount: 300
    date: "2018-07-12"
    status: "pending"
    accountRepresentativeID: "dabit"
    customerID: "jennifer_thomas"
    productID: "yeezyboost"
  }) {
    id
    customerID
    accountRepresentativeID
    amount
    date
    customerID
    productID
  }
}
```

### 1. Look up employee details by employee ID

This can simply be done by querying the employee model with an employee ID, no `@primaryKey` or `@index` need to be explicitly specified to make this work.

```graphql
query getEmployee($id: ID!) {
  getEmployee(id: $id) {
    id
    name
    phoneNumber
    startDate
    jobTitle
  }
}
```

### 2. Query employee details by employee name

The `@index` `byName` on the `Employee` type makes this access-pattern feasible because under the covers an index is created and a query is used to match against the name field. We can use this query:

```graphql
query employeeByName($name: String!) {
  employeeByName(name: $name) {
    items {
      id
      name
      phoneNumber
      startDate
      jobTitle
    }
  }
}
```

### 3. Find an Employee’s phone number

Either one of the previous queries would work to find an employee’s phone number as long as one has their ID or name.

### 4. Find a customer’s phone number

A similar query to those given above but on the Customer model would give you a customer’s phone number.

```graphql
query getCustomer($customerID: ID!) {
  getCustomer(id: $customerID) {
    phoneNumber
  }
}
```

### 5. Get orders for a given customer within a given date range

There is a one-to-many relation that lets all the orders of a customer be queried.

This relationship is created by having the `@index` name `byCustomerByDate` on the Order model that is queried by the `@hasMany` relationship on the orders field of the Customer model.

A sort key with the date is used. What this means is that the GraphQL resolver can use predicates like `Between` to efficiently search the date range rather than scanning all records in the database and then filtering them out.

The query one would need to get the orders to a customer within a date range would be:

```graphql
query getCustomerWithOrdersByDate($customerID: ID!) {
  getCustomer(id: $customerID) {
    ordersByDate(date: {
      between: [ "2018-01-22", "2020-10-11" ]
    }) {
      items {
        id
        amount
        productID
      }
    }
  }
}
```

### 6. Show all open orders within a given date range across all customers

The `@index` `byCustomerByStatusByDate` enables you to run a query that would work for this access pattern.

In this example, a composite sort key (combination of two or more keys) with the `status` and `date` is used. What this means is that the unique identifier of a record in the database is created by concatenating these two fields (status and date) together, and then the GraphQL resolver can use predicates like `Between` or `Contains` to efficiently search the unique identifier for matches rather than scanning all records in the database and then filtering them out.

```graphql
query getCustomerWithOrdersByStatusDate($customerID: ID!) {
  getCustomer(id: $customerID) {
    ordersByStatusDate (statusDate: {
      between: [
        { status: "pending" date:  "2018-01-22" },
        { status: "pending", date: "2020-10-11"}
      ]}) {
        items {
            id
            amount
            date
        }
    }
  }
}
```

### 7. See all employees hired recently

Having `@index(name: "newHire", fields: ["newHire", "id"])` on the `Employee` model allows one to query by whether an employee has been hired recently.

```graphql
query employeesNewHire {
  employeesNewHire(newHire: "true") {
    items {
      id
      name
      phoneNumber
      startDate
      jobTitle
    }
  }
}
```

We can also query and have the results returned by start date by using the `employeesNewHireByStartDate` query:

```graphql
query employeesNewHireByDate {
  employeesNewHireByStartDate(newHire: "true") {
    items {
      id
      name
      phoneNumber
      startDate
      jobTitle
    }
  }
}
```

### 8. Find all employees working in a given warehouse

This needs a one to many relationship from warehouses to employees. As can be seen from the `@hasMany` relationship in the `Warehouse` model, this relationship uses the `byWarehouse` index on the `Employee` model. The relevant query would look like this:

```graphql
query getWarehouse($warehouseID: ID!) {
  getWarehouse(id: $warehouseID) {
    id
    employees{
      items {
        id
        name
        startDate
        phoneNumber
        jobTitle
      }
    }
  }
}
```

### 9. Get all items on order for a given product

This access-pattern would use a one-to-many relation from products to orders. With this query we can get all orders of a given product:

```graphql
query getProductOrders($productID: ID!) {
  getProduct(id: $productID) {
    id
    orders {
      items {
        id
        status
        amount
        date
      }
    }
  }
}
```

### 10. Get current inventories for a product at all warehouses

The query needed to get the inventories of a product in all warehouses would be:

```graphql
query getProductInventoryInfo($productID: ID!) {
  getProduct(id: $productID) {
    id
    inventories {
      items {
        warehouseID
        inventoryAmount
      }
    }
  }
}
```

### 11. Get customers by account representative

This uses a has-many relationship between account representatives and customers:

The query needed would look like this:

```graphql
query getCustomersForAccountRepresentative($representativeId: ID!) {
  getAccountRepresentative(id: $representativeId) {
    customers {
      items {
        id
        name
        phoneNumber
      }
    }
  }
}
```

### 12. Get orders by account representative and date

As can be seen in the AccountRepresentative model this relationship uses the `byRepresentativebyDate` field on the `Order` model to create the connection needed. The query needed would look like this:

```graphql
query getOrdersForAccountRepresentative($representativeId: ID!) {
  getAccountRepresentative(id: $representativeId) {
    id
    orders(date: {
      between: [
         "2010-01-22", "2020-10-11"
      ]
    }) {
        items {
          id
          status
          amount
          date
        }
    }
  }
}
```

### 13. Get all items on order for a given product

This is the same as number 9.

### 14. Get all employees with a given job title

Using the `byTitle` `@index` makes this access pattern quite easy.

```graphql
query employeesByJobTitle {
  employeesByJobTitle(jobTitle: "Manager") {
    items {
      id
      name
      phoneNumber
      jobTitle
    }
  }
}
```

### 15. Get inventory by product by warehouse

Here having the inventories be held in a separate model is particularly useful since this model can have its own partition key and sort key such that the inventories themselves can be queried as is needed for this access-pattern.

A query on this model would look like this:

```graphql
query inventoryByProductAndWarehouse($productID: ID!, $warehouseID: ID!) {
  getInventory(productID: $productID, warehouseID: $warehouseID) {
    productID
    warehouseID
    inventoryAmount
  }
}

```

We can also get all inventory from an individual warehouse by using the `itemsByWarehouseID` query created by the `byWarehouseID` key:

```graphql
query byWarehouseId($warehouseID: ID!) {
  itemsByWarehouseID(warehouseID: $warehouseID) {
    items {
      inventoryAmount
      productID
    }
  }
}
```

### 16. Get total product inventory

How this would be done depends on the use case. If one just wants a list of all inventories in all warehouses, one could just run a list inventories on the Inventory model:

```graphql
query listInventorys {
  listInventorys {
    items {
      productID
      warehouseID
      inventoryAmount
    }
  }
}
```

### 17. Get sales representatives ranked by order total and sales period

The sales period is either a date range or maybe even a month or week. Therefore we can set the sales period as a string and query using the combination of `salesPeriod` and `orderTotal`. We can also set the `sortDirection` in order to get the return values from largest to smallest:

```graphql
query repsByPeriodAndTotal {
  repsByPeriodAndTotal(
    sortDirection: DESC,
    salesPeriod: "January 2019",
    orderTotal: {
      ge: 1000
    }) {
    items {
      id
      orderTotal
    }
  }
}
```
