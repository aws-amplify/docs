export const meta = {
  title: `Relational models`,
  description: `Learn more about how API (GraphQL) handles relationships between Models, such as "has one", "has many", "belongs to".`
};

API (GraphQL) has the capability to handle relationships between Models, such as _has one_, _has many_, and _belongs to_. In Amplify GraphQL APIs, this is done with the `@hasOne`, `@hasMany` and `@belongsTo` directives as defined in the [GraphQL data modeling documentation](/cli/graphql/data-modeling).

By default, GraphQL APIs requests generate a selection set with a depth of 0. Connected relationship models are not returned in the initial request, but can be lazily loaded as needed with an additional API request. We provide mechanisms to customize the selection set, which allows connected relationships to be eagerly loaded on the initial request.

## Prerequisites

The following examples have a minimum version requirement of the following:

<InlineFilter filters={["android"]}>

- Amplify CLI v12.7.0
- Amplify Android Library v2.14.0
- This guide uses updated model types generated by the Amplify CLI. To follow this guide, locate `"generatemodelsforlazyloadandcustomselectionset"` in `{project-directory}/amplify/cli.json` and set the value to `true`.

<Callout>

If you already have relational models in your project, you must re-run `amplify codegen models` after updating the feature flag. After the models have been updated, breaking changes will need to be addressed because relationship fields will now be wrapped in `ModelList`/`ModelReference` types. Follow the rest of the guide on this page information on how to use the new lazy supported models.

</Callout>

</InlineFilter>

## Create a GraphQL schema with relationships between models

For the following example, let's add a Post and Comment model to the [schema](/lib/graphqlapi/getting-started#configure-api):

```graphql
type Post @model {
  id: ID!
  title: String!
  rating: Int!
  comments: [Comment] @hasMany
}

type Comment @model {
  id: ID!
  content: String
  post: Post @belongsTo
}
```

Generate the models for the updated schema using the [Amplify CLI](/lib/graphqlapi/getting-started#generate-todo-model-class).

```bash
amplify codegen models
```

## Creating relationships

In order to create connected models, you will create an instance of the model you wish to connect and pass it to `Amplify.API.mutate`:

import android6 from '/src/fragments/lib/graphqlapi/android/relational/save-snippet.mdx';

<Fragments fragments={{ android: android6 }} />

## Querying relationships

import android10 from '/src/fragments/lib/graphqlapi/android/relational/query-snippet.mdx';

<Fragments fragments={{ android: android10 }} />

import android4 from '/src/fragments/lib/graphqlapi/android/relational/codegen-reference-types.mdx';

<Fragments fragments={{ android: android4 }} />

## Deleting relationships

When you delete a parent object in a one-to-many relationship, the children will not be removed. Delete the children before deleting the parent to prevent orphaned data.

## Many-to-many relationships

For many-to-many relationships, you can use the `@manyToMany` directive and specify a `relationName`. Under the hood, Amplify creates a join table and a one-to-many relationship from both models.

<Callout warning>

Join table records must be deleted prior to deleting the associated records. For example, for a many-to-many relationship between `Post`s and `Tag`s, delete the `PostTag`s join record prior to deleting a `Post` or `Tag`.

</Callout>

```graphql
type Post @model {
  id: ID!
  title: String!
  rating: Int
  editors: [User] @manyToMany(relationName: "PostEditor")
}

type User @model {
  id: ID!
  username: String!
  posts: [Post] @manyToMany(relationName: "PostEditor")
}
```

import android18 from '/src/fragments/lib/graphqlapi/android/relational/save-many-snippet.mdx';

<Fragments fragments={{ android: android18 }} />

## Customizing query depth with custom selection sets

You can perform a nested query through one network request, by specifying which connected models to include. This is achieved by using the optional `includes` parameter for a GraphQL request.

Query for the `Comment` and the `Post` that it belongs to:

import android20 from '/src/fragments/lib/graphqlapi/android/relational/customizing-query-depth-comment-post.mdx';

<Fragments fragments={{ android: android20 }} />

Query for the `Post` and the first page of comments for the post: 

import android22 from '/src/fragments/lib/graphqlapi/android/relational/customizing-query-depth-post-comments.mdx';

<Fragments fragments={{ android: android22 }} />

import android23 from '/src/fragments/lib/graphqlapi/android/relational/complex-query-depth.mdx';

<Fragments fragments={{ android: android23 }} />
