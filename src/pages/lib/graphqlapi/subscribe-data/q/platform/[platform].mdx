export const meta = {
  title: `Subscribe to data`,
  description: `Learn more about how to observe to data changes using subscriptions in Amplify.`
};

<InlineFilter filters={["ios"]}>

Subscribe to mutations for creating real-time clients.

Because the lifetime of the subscription will last longer than the lifetime of a single function, you can create an instance variable at the top of your class:

<BlockSwitcher>

<Block name="Async/Await">

```swift
var subscription: AmplifyAsyncThrowingSequence<GraphQLSubscriptionEvent<Todo>>
```

</Block>

<Block name="Combine">

```swift
var subscription: AnyCancellable?
```

</Block>

</BlockSwitcher>

To listen to creation updates, you can use the following code sample:

<BlockSwitcher>

<Block name="Async/Await">

```swift
func createSubscription() {
    subscription = Amplify.API.subscribe(request: .subscription(of: Todo.self, type: .onCreate))
    Task {
        do {
            for try await subscriptionEvent in subscription {
                switch subscriptionEvent {
                case .connection(let subscriptionConnectionState):
                    print("Subscription connect state is \(subscriptionConnectionState)")
                case .data(let result):
                    switch result {
                    case .success(let createdTodo):
                        print("Successfully got todo from subscription: \(createdTodo)")
                    case .failure(let error):
                        print("Got failed result with \(error.errorDescription)")
                    }
                }
            }
        } catch {
            print("Subscription has terminated with \(error)")
        }
    }
}
```
</Block>

<Block name="Combine">

```swift
func createSubscription() {
    let sequence = Amplify.API.subscribe(request: .subscription(of: Todo.self, type: .onCreate))
    subscription = Amplify.Publisher.create(sequence)
        .sink {
        if case let .failure(apiError) = $0 {
            print("Subscription has terminated with \(apiError)")
        } else {
            print("Subscription has been closed successfully")
        }
    }
    receiveValue: { result in
        switch result {
            case .connection(let subscriptionConnectionState):
                print("Subscription connect state is \(subscriptionConnectionState)")
            case .data(let result):
                switch result {
                case .success(let createdTodo):
                    print("Successfully got todo from subscription: \(createdTodo)")
                case .failure(let error):
                    print("Got failed result with \(error.errorDescription)")
            }
        }
    }
}
```

</Block>

</BlockSwitcher>

### Unsubscribing from updates

#### Async/Await

To unsubscribe from updates, you can call `cancel()` on the subscription.

```swift
func cancelSubscription() {
    // Cancel the subscription listener when you're finished with it
    subscription?.cancel()
}
```

#### Combine

Calling `cancel()` on the sequence will disconnect the subscription from the backend. Any downstream subscribers will also be cancelled.

```swift
let sequence = Amplify.API.subscribe(...)
let subscription = Amplify.Publisher.create(sequence)
let allUpdates = subscription.sink(...)
let filteredUpdates = subscription.filter{...}.sink(...)
sequence.cancel()   // sequence is now disconnected
                    // allUpdates and filteredUpdates will no longer receive data
```

Similarly, calling `cancel()` on the Combine subscriber (e.g., the `AnyCancellable` returned from `sink()`) will cause the underlying sequence to cancel. This will cause all attached subscribers to stop receiving updates.

```swift
allUpdates.cancel() // sequence is disconnected
                    // filteredUpdates will no longer receive data
```


</InlineFilter>

<InlineFilter filters={["android"]}>

Subscribe to mutations for creating real-time clients:

<BlockSwitcher>
<Block name="Java">

```java
ApiOperation subscription = Amplify.API.subscribe(
    ModelSubscription.onCreate(Todo.class),
    onEstablished -> Log.i("ApiQuickStart", "Subscription established"),
    onCreated -> Log.i("ApiQuickStart", "Todo create subscription received: " + ((Todo) onCreated.getData()).getName()),
    onFailure -> Log.e("ApiQuickStart", "Subscription failed", onFailure),
    () -> Log.i("ApiQuickStart", "Subscription completed")
);

// Cancel the subscription listener when you're finished with it
subscription.cancel();
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val subscription = Amplify.API.subscribe(
    ModelSubscription.onCreate(Todo::class.java),
    { Log.i("ApiQuickStart", "Subscription established") },
    { Log.i("ApiQuickStart", "Todo create subscription received: ${(it.data as Todo).name}") },
    { Log.e("ApiQuickStart", "Subscription failed", it) },
    { Log.i("ApiQuickStart", "Subscription completed") }
)

// Cancel the subscription listener when you're finished with it
subscription.cancel();
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val job = activityScope.launch {
    try {
        Amplify.API.subscribe(ModelSubscription.onCreate(Todo::class.java))
            .catch { Log.e("ApiQuickStart", "Error on subscription", it) }
            .collect { Log.i("ApiQuickStart", "Todo created!  ${it.data.name}") }
    } catch (notEstablished: ApiException) {
        Log.e("ApiQuickStart", "Subscription not established", it)
    }
}

// When done with subscription
job.cancel()
```

</Block>
<Block name="RxJava">

```java
RxSubscriptionOperation<? extends GraphQLResponse<?>> subscription =
        RxAmplify.API.subscribe(request);

subscription
        .observeConnectionState()
        .subscribe(connectionStateEvent -> Log.i("ApiQuickStart", String.valueOf(connectionStateEvent)));

subscription
        .observeSubscriptionData()
        .subscribe(
            data -> Log.i("ApiQuickStart", data),
            exception -> Log.e("ApiQuickStart", "Subscription failed.", exception),
            () -> Log.i("ApiQuickStart", "Subscription completed.")
        );

// Cancel the subscription listener when you're finished with it
subscription.cancel();
```

</Block>
</BlockSwitcher>


</InlineFilter>

<InlineFilter filters={["js", "react-native"]}>

<!-- TODO Rewrite needs a better intro and description to subscriptions in general - and why a dev would use them -->

## Using Amplify GraphQL client

Subscriptions is a GraphQL feature allowing the server to send data to its clients when a specific event happens. You can enable real-time data integration in your app with a subscription.

<BlockSwitcher>
<Block name="TypeScript">

```ts
import { Amplify, API, graphqlOperation } from 'aws-amplify';
import { GraphQLSubscription } from '@aws-amplify/api';
import * as subscriptions from './graphql/subscriptions';
import { OnCreateTodoSubscription } from './API';

// Subscribe to creation of Todo
const sub = API.graphql<GraphQLSubscription<OnCreateTodoSubscription>>(
  graphqlOperation(subscriptions.onCreateTodo)
).subscribe({
  next: ({ provider, value }) => console.log({ provider, value }),
  error: (error) => console.warn(error)
});

// Stop receiving data updates from the subscription
sub.unsubscribe();
```

</Block>

<Block name="JavaScript">

```js
import { Amplify, API, graphqlOperation } from 'aws-amplify';
import * as subscriptions from './graphql/subscriptions';

// Subscribe to creation of Todo
const sub = API.graphql(
  graphqlOperation(subscriptions.onCreateTodo)
).subscribe({
  next: ({ provider, value }) => console.log({ provider, value }),
  error: (error) => console.warn(error)
});

// Stop receiving data updates from the subscription
sub.unsubscribe();
```

</Block>
</BlockSwitcher>

When using **AWS AppSync** subscriptions, be sure that your AppSync configuration is at the root of the configuration object, instead of being under API:

```javascript
Amplify.configure({
  Auth: {
    identityPoolId: 'xxx',
    region: 'xxx',
    cookieStorage: {
      domain: 'xxx',
      path: 'xxx',
      secure: true
    }
  },
  aws_appsync_graphqlEndpoint: 'xxxx',
  aws_appsync_region: 'xxxx',
  aws_appsync_authenticationType: 'xxxx',
  aws_appsync_apiKey: 'xxxx'
});
```

Subscriptions take an optional `filter` argument to define service-side subscription filters:

<BlockSwitcher>
<Block name="TypeScript">

```ts
// ...
import { GraphQLSubscription } from '@aws-amplify/api';
import { OnCreateTodoSubscriptionVariables, OnCreateTodoSubscription } from './API';

const variables: OnCreateTodoSubscriptionVariables = {
  filter: {
    // Only receive Todo messages where the "type" field is "Personal"
    type: { eq: "Personal" }
  }
}

const sub = API.graphql<GraphQLSubscription<OnCreateTodoSubscription>>(
  graphqlOperation(subscriptions.onCreateTodo, variables)
).subscribe({
  next: ({ provider, value }) => console.log({ provider, value }),
  error: error => console.warn(error)
});
```

</Block>

<Block name="JavaScript">

```js
// ...

const variables = {
  filter: {
    // Only receive Todo messages where the "type" field is "Personal"
    type: { eq: "Personal" }
  }
}

const sub = API.graphql(
  graphqlOperation(subscriptions.onCreateTodo, variables)
).subscribe({
  next: ({ provider, value }) => console.log({ provider, value }),
  error: error => console.warn(error)
});
```

</Block>
</BlockSwitcher>

If you want to get all subscription events, don’t pass any `filter` parameters.

<Callout>

**Important**: Passing an empty object `{}` as a filter is NOT recommended. Using `{}` as a filter might cause inconsistent behavior based on your data model's authorization rules.

</Callout>

### Subscription connection status updates

Now that your application is setup and using subscriptions, you may want to know when the subscription is finally established, or reflect to your users when the subscription isn't healthy. You can monitor the connection state for changes via Hub.

```ts
import { CONNECTION_STATE_CHANGE, ConnectionState } from '@aws-amplify/pubsub';
import { Hub } from 'aws-amplify';

Hub.listen('api', (data: any) => {
  const { payload } = data;
  if (payload.event === CONNECTION_STATE_CHANGE) {
    const connectionState = payload.data.connectionState as ConnectionState;
    console.log(connectionState);
  }
});
```

import jsConnectionStates from '/src/fragments/lib/pubsub/js/connection-states.mdx';

<Fragments fragments={{ js: jsConnectionStates }} />

### Connection issues and automated reconnection

import jsReconnectDescription from '/src/fragments/lib/pubsub/js/reconnect-description.mdx';

<Fragments fragments={{ js: jsReconnectDescription }} />

<BlockSwitcher>
<Block name="TypeScript">

```ts
// ...
import { GraphQLQuery, GraphQLSubscription } from '@aws-amplify/api';
import {
  ListTodosQuery
  OnCreateTodoSubscription,
  OnUpdateTodoSubscription,
  OnDeleteTodoSubscription
} from './API';

const fetchRecentData = () => {
  // Retrieve some/all data from AppSync
  const allTodos = await API.graphql<GraphQLQuery<ListTodosQuery>>({ 
    query: queries.listTodos 
  });
}

let priorConnectionState: ConnectionState;

Hub.listen("api", (data: any) => {
  const { payload } = data;
  if (
    payload.event === CONNECTION_STATE_CHANGE
  ) {

    if (priorConnectionState === ConnectionState.Connecting && payload.data.connectionState === ConnectionState.Connected) {
      fetchRecentData();
    }
    priorConnectionState = payload.data.connectionState;
  }
});

const createSub = API.graphql<GraphQLSubscription<OnCreateTodoSubscription>>(
  graphqlOperation(subscriptions.onCreateTodo)
).subscribe({
  next: data => // Process incoming messages
});

const updateSub = API.graphql<GraphQLSubscription<OnUpdateTodoSubscription>>(
  graphqlOperation(subscriptions.onUpdateTodo)
).subscribe({
  next: data => // Process incoming messages
});

const deleteSub = API.graphql<GraphQLSubscription<OnDeleteTodoSubscription>>(
  graphqlOperation(subscriptions.onDeleteTodo)
).subscribe({
  next: data => // Process incoming messages
});

const cleanupSubscriptions = () => {
  createSub.unsubscribe();
  updateSub.unsubscribe();
  deleteSub.unsubscribe();
}
```

</Block>

<Block name="JavaScript">

```js
// ...

const fetchRecentData = () => {
  // Retrieve some/all data from AppSync
  const allTodos = await API.graphql({ query: queries.listTodos });
}

let priorConnectionState: ConnectionState;

Hub.listen("api", (data: any) => {
  const { payload } = data;
  if (
    payload.event === CONNECTION_STATE_CHANGE
  ) {

    if (priorConnectionState === ConnectionState.Connecting && payload.data.connectionState === ConnectionState.Connected) {
      fetchRecentData();
    }
    priorConnectionState = payload.data.connectionState;
  }
});

const createSub = API.graphql(
  graphqlOperation(subscriptions.onCreateTodo)
).subscribe({
  next: data => // Process incoming messages
});

const updateSub = API.graphql(
  graphqlOperation(subscriptions.onUpdateTodo)
).subscribe({
  next: data => // Process incoming messages
});

const deleteSub = API.graphql(
  graphqlOperation(subscriptions.onDeleteTodo)
).subscribe({
  next: data => // Process incoming messages
});

const cleanupSubscriptions = () => {
  createSub.unsubscribe();
  updateSub.unsubscribe();
  deleteSub.unsubscribe();
}
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["flutter"]}>

Subscribe to mutations for creating real-time clients.

## Setup subscription with callbacks

When creating subscriptions, a [`Stream`](https://api.dart.dev/stable/dart-async/Stream-class.html) object will be returned to you. This `Stream` will continue producing events until either the subscription encounters an error or you cancel the subscription. In the case of need for limiting the amount of data that is omitted, you can take advantage of the Stream's helper functions such as `take`. The cancellation occurs when the defined amount of event has occurred:

```dart
Stream<GraphQLResponse<Todo>> subscribe() {
  final subscriptionRequest = ModelSubscriptions.onCreate(Todo.classType);
  final Stream<GraphQLResponse<Todo>> operation = Amplify.API
      .subscribe(
        subscriptionRequest,
        onEstablished: () => safePrint('Subscription established'),
      )
      // Listens to only 5 elements
      .take(5)
      .handleError(
    (Object error) {
      safePrint('Error in subscription stream: $error');
    },
  );
  return operation;
}
```

Alternatively, you can call [`Stream.listen`](https://api.dart.dev/stable/dart-async/Stream/listen.html) to create a [`StreamSubscription`](https://api.dart.dev/stable/dart-async/StreamSubscription-class.html) object which can be programmatically canceled.

```dart
// Be sure to import this
import 'dart:async';

...

StreamSubscription<GraphQLResponse<Todo>>? subscription;

void subscribe() {
  final subscriptionRequest = ModelSubscriptions.onCreate(Todo.classType);
  final Stream<GraphQLResponse<Todo>> operation = Amplify.API.subscribe(
    subscriptionRequest,
    onEstablished: () => safePrint('Subscription established'),
  );
  subscription = operation.listen(
    (event) {
      safePrint('Subscription event data received: ${event.data}');
    },
    onError: (Object e) => safePrint('Error in subscription stream: $e'),
  );
}

void unsubscribe() {
  subscription?.cancel();
  subscription = null;
}
```

In addition to an `onCreate` subscription, you can also call `.onUpdate()` or `.onDelete()`.

```dart
final onUpdateSubscriptionRequest = ModelSubscriptions.onUpdate(Todo.classType);
// or
final onDeleteSubscriptionRequest = ModelSubscriptions.onDelete(Todo.classType);
```

## Subscription connection status

Now that you set up the application and are using subscriptions, you may want to know when the subscription is closed, or reflect to your users when the subscription isn’t healthy. You can monitor the subscription status for changes via `Amplify.Hub`

```dart
Amplify.Hub.listen(
  HubChannel.Api,
  (ApiHubEvent event) {
    if (event is SubscriptionHubEvent) {
      safePrint(event.status);
    }
  },
);
```

#### SubscriptionStatus

- **`connected`** - Connected and working with no issues
- **`connecting`** - Attempting to connect (both initial connection and reconnection)
- **`pendingDisconnect`** - Connection has no active subscriptions and is shutting down
- **`disconnected`** - Connection has no active subscriptions and is disconnected
- **`failed`** - Connection had a failure and has been disconnected

## Automated Reconnection

Under the hood, we will attempt to maintain a healthy web socket connection through network changes. For example, if a device’s connection changes from Wi-Fi to 5g network, the plugin will attempt to reconnect using the new network.

Likewise, when disconnected from the internet unexpectedly, the subscription will attempt to reconnect using an exponential retry/back off strategy. By default, we will make 8 recovery attempts over about 50 seconds. If we cannot make a successful connection, then the web socket will be closed. You can customize this strategy when configuring the API plugin through `RetryOptions`.

```dart
Future<void> _configureAmplify() async {
  final apiPlugin = AmplifyAPI(
    modelProvider: ModelProvider.instance,
    // Optional config
    subscriptionOptions: const GraphQLSubscriptionOptions(
      retryOptions: RetryOptions(maxAttempts: 10),
    ),
  );
  await Amplify.addPlugin(apiPlugin);

  try {
    await Amplify.configure(amplifyconfig);
  } on AmplifyAlreadyConfiguredException {
    safePrint(
        "Tried to reconfigure Amplify; this can occur when your app restarts on Android.");
  }
}
```

<Callout>

**Important**: While offline, your application will miss messages and will not automatically catch up when reconnection happens. Depending on your use case, you may want to take action to catch up when your app comes back online. The following example solves this problem by retrieving all data on reconnection.

</Callout>

```dart
import 'package:amplify_flutter/amplify_flutter.dart';
import 'package:amplify_api/amplify_api.dart';
import './models/ModelProvider.dart'; // <--- Update import to reflect your project
import 'dart:async';

// ...

List<Todo?> allTodos = [];
SubscriptionStatus prevSubscriptionStatus = SubscriptionStatus.disconnected;
StreamSubscription<GraphQLResponse<Todo>>? subscription;

/// ...

// Init listeners
Amplify.Hub.listen(
  HubChannel.Api,
  (ApiHubEvent event) {
    if (event is SubscriptionHubEvent) {
      if (prevSubscriptionStatus == SubscriptionStatus.connecting &&
          event.status == SubscriptionStatus.connected) {
        getTodos(); // refetch todos
      }
      prevSubscriptionStatus = event.status;
    }
  },
);

subscribe();

/// ...

Future<void> getTodos() async {
  try {
    final request = ModelQueries.list(Todo.classType);
    final response = await Amplify.API.query(request: request).response;

    final todos = response.data?.items ?? [];
    if (response.errors.isNotEmpty) {
      safePrint('errors: ${response.errors}');
    }

    setState(() {
      allTodos = todos;
    });
  } on ApiException catch (e) {
    safePrint('Query failed: $e');
    return;
  }
}

void subscribe() {
  final subscriptionRequest = ModelSubscriptions.onCreate(Todo.classType);
  final Stream<GraphQLResponse<Todo>> operation = Amplify.API.subscribe(
    subscriptionRequest,
    onEstablished: () => safePrint('Subscription established'),
  );
  subscription = operation.listen(
    (event) {
      setState(() {
        allTodos.add(event.data);
      });
    },
    onError: (Object e) => safePrint('Error in subscription stream: $e'),
  );
}

```


</InlineFilter>
