import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Connect API and database to the app',
  description:
    'Getting started with Amplify - How to model your data using Amplify',
  platforms: ['angular', 'javascript', 'nextjs', 'react', 'react-native', 'vue']
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

<InlineFilter filters={['javascript','react','angular','react-native','vue', 'nextjs']}>

Now that you’ve created and configured your application and initialized a new Amplify project, you can add a feature. The first feature you will add is an API.

The Amplify CLI supports creating and interacting with two types of API categories: REST and GraphQL.

The API you will be creating in this step is a GraphQL API using AWS AppSync (a managed GraphQL service) and the database will be Amazon DynamoDB (a NoSQL database).

## Create a GraphQL API and database

Add a [GraphQL API](https://docs.aws.amazon.com/appsync/latest/devguide/designing-a-graphql-api.html) to your app and automatically provision a database by running the following command from the root of your application directory:

```bash
amplify add api
```

Accept the **default values** which are highlighted below:

```console
? Select from one of the below mentioned services: GraphQL
? Here is the GraphQL API that we will create. Select a setting to edit or continue Continue
? Choose a schema template: Single object with fields (e.g., “Todo” with ID, name, description)
```

The CLI will prompt you to open this GraphQL schema in your text editor.

**amplify/backend/api/your-api-name/schema.graphql**

```graphql
# This "input" configures a global authorization rule to enable public access to
# all models in this schema. Learn more about authorization rules here: https://docs.amplify.aws/react/build-a-backend/graphqlapi/customize-authorization-rules/

input AMPLIFY {
  globalAuthRule: AuthRule = { allow: public }
} # FOR TESTING ONLY!
type Todo @model {
  id: ID!
  name: String!
  description: String
}
```

The schema generated is for a Todo app. You'll notice a `@model` directive on the `Todo` type. This directive is part of the [Amplify GraphQL API](/[platform]/build-a-backend/graphqlapi/data-modeling/) category.

Amplify GraphQL API provides custom GraphQL directives that allow you to define data models, set up authorization rules, configure serverless functions as resolvers, and more.

A GraphQL type decorated with the `@model` directive will scaffold out the database table for the type (Todo table), the schema for CRUD (create, read, update, delete) and list operations, and the GraphQL resolvers needed to make everything work together.

From the command line, press **enter** to accept the schema and continue to the next steps.

### Deploying the API

To deploy this backend, run the `push` command:

```bash
amplify push
```

Choose the following values for each prompt:

<BlockSwitcher>
<Block name="TypeScript">

```console
✔ Are you sure you want to continue? (Y/n) · yes
...
? Do you want to generate code for your newly created GraphQL API: Yes
? Choose the code generation language target: typescript
? Enter the file name pattern of graphql queries, mutations and subscriptions: src/graphql/**/*.ts
? Do you want to generate/update all possible GraphQL operations - queries, mutations and subscriptions: Yes
? Enter maximum statement depth [increase from default if your schema is deeply nested]: 2
? Enter the file name for the generated code: src/API.ts
```

</Block>
<Block name="JavaScript">

```console
✔ Are you sure you want to continue? (Y/n) · yes
...
? Do you want to generate code for your newly created GraphQL API Yes
? Choose the code generation language target javascript
? Enter the file name pattern of graphql queries, mutations and subscriptions src/graphql/**/*.js
? Do you want to generate/update all possible GraphQL operations - queries, mutations and subscriptions Yes
? Enter maximum statement depth [increase from default if your schema is deeply nested] 2
? Enter the file name for the generated code src/API.js
```

</Block>
</BlockSwitcher>

Now the API is live and you can start interacting with it! The API you have deployed includes operations for creating, reading, updating, deleting, and listing posts.

<Accordion title="Review deployment status" headingLevel="3">

Next, run the following command to check Amplify's status:

```bash
amplify status
```

This will give us the current status of the Amplify project, including the current environment, any categories that have been created, and what state those categories are in. It should look similar to this:

```console

    Current Environment: dev

┌──────────┬───────────────────────┬───────────┬───────────────────┐
│ Category │ Resource name         │ Operation │ Provider plugin   │
├──────────┼───────────────────────┼───────────┼───────────────────┤
│ Api      │ your-api-name         │ No Change │ awscloudformation │
└──────────┴───────────────────────┴───────────┴───────────────────┘
```

</Accordion>
<Accordion title="Review deployed API in AWS console">

To view the GraphQL API in the AppSync console at any time, run the following command:

```bash
amplify console api
```

To view your entire app in the Amplify console at any time, run the following command:

```bash
amplify console
```

</Accordion>

<Accordion title="Test API with local mocking">

To test this out locally, you can run the `mock` command. Note: Refer to the [instructions to setup mocking](/[platform]/tools/cli/usage/mock/).

> If you'd like to go ahead and connect the front end, you can [jump to the next step](#connect-frontend-to-api).

```bash
amplify mock api
```

_Note:_ `amplify mock api` requires Java.

```console
# If you have not already deployed your API, you will be walked through the following steps for GraphQL code generation
? Choose the code generation language target: javascript (or preferred target)
? Enter the file name pattern of graphql queries, mutations and subscriptions: src/graphql/**/*.js
? Do you want to generate/update all possible GraphQL operations - queries, mutations and subscriptions: Yes
? Enter maximum statement depth [increase from default if your schema is deeply nested] 2
```

This will open the GraphiQL explorer on a local port. From the test environment you can try out different operations locally, like queries and mutations.

In the GraphiQL toolbar, select **Use: User Pool** and try creating a todo:

```graphql
mutation CreateTodo {
  createTodo(input: { name: "Test Todo", description: "Todo description" }) {
    id
    owner
    name
    updatedAt
    createdAt
    description
  }
}
```

Next, update auth to **Use: API Key** and try querying the list of todos:

```graphql
query ListTodos {
  listTodos {
    items {
      description
      createdAt
      id
      owner
      name
    }
  }
}
```

</Accordion>

<InlineFilter filters={["javascript", "angular", "vue", "react", "react-native"]}>

## Connect frontend to API

<InlineFilter filters={['javascript']}>

Update your `main.js` file to setup your app to add data to your database with a mutation by using `client.graphql()`:

```javascript
import './style.css';
import { Amplify } from 'aws-amplify';
import amplifyconfig from './src/amplifyconfiguration.json';

import { generateClient } from 'aws-amplify/api';
import { createTodo } from './src/graphql/mutations';
import { listTodos } from './src/graphql/queries';
import { onCreateTodo } from './src/graphql/subscriptions';

Amplify.configure(amplifyconfig);

const client = generateClient();

const MutationButton = document.getElementById('MutationEventButton');
const MutationResult = document.getElementById('MutationResult');
const QueryResult = document.getElementById('QueryResult');
const SubscriptionResult = document.getElementById('SubscriptionResult');

async function addTodo() {
  const todo = {
    name: 'Use AppSync',
    description: `Realtime and Offline (${new Date().toLocaleString()})`
  };

  return await client.graphql({
    query: createTodo,
    variables: {
      input: todo
    }
  });
}

async function fetchTodos() {
  try {
    const response = await client.graphql({
      query: listTodos
    });

    response.data.listTodos.items.map((todo, i) => {
      QueryResult.innerHTML += `<p>${todo.name} - ${todo.description}</p>`;
    });
  } catch (e) {
    console.log('Something went wrong', e);
  }
}

MutationButton.addEventListener('click', (evt) => {
  addTodo().then((evt) => {
    MutationResult.innerHTML += `<p>${evt.data.createTodo.name} - ${evt.data.createTodo.description}</p>`;
  });
});

function subscribeToNewTodos() {
  client.graphql({ query: onCreateTodo }).subscribe({
    next: (evt) => {
      const todo = evt.data.onCreateTodo;
      SubscriptionResult.innerHTML += `<p>${todo.name} - ${todo.description}</p>`;
    }
  });
}

subscribeToNewTodos();
fetchTodos();
```

Let's walk through some of the functions:

**fetchTodos** - Uses the Amplify API `client` created by `generateClient()` to call the AppSync GraphQL API with the `listTodos` query. Once the data is returned, the items array is passed in to the `setTodos` function to update the local state.

**addTodo** - Uses the Amplify API `client` created by `generateClient()` to call the AppSync GraphQL API with the `createTodo` mutation. A difference between the `listTodos` query and the `createTodo` mutation is that `createTodo` accepts an argument containing the variables needed for the mutation.

**subscribeToNewTodos** - Uses the Amplify API `client` created by `generateClient()` to subscribe to any new todos created and displays it to the user.

</InlineFilter>

<InlineFilter filters={['react']}>

In this section you will create a way to list and create todos from the React application. To do this, you will create a form with a button to create todos as well as a way to fetch and render the list of todos.

<BlockSwitcher>
<Block name="TypeScript">

Open **src/App.tsx** and replace it with the following code:

```typescript
import { useEffect, useState } from 'react';

import { generateClient } from 'aws-amplify/api';

import { createTodo } from './graphql/mutations';
import { listTodos } from './graphql/queries';
import { type CreateTodoInput, type Todo } from './API';

const initialState: CreateTodoInput = { name: '', description: '' };
const client = generateClient();

const App = () => {
  const [formState, setFormState] = useState<CreateTodoInput>(initialState);
  const [todos, setTodos] = useState<Todo[] | CreateTodoInput[]>([]);

  useEffect(() => {
    fetchTodos();
  }, []);

  async function fetchTodos() {
    try {
      const todoData = await client.graphql({
        query: listTodos,
      });
      const todos = todoData.data.listTodos.items;
      setTodos(todos);
    } catch (err) {
      console.log('error fetching todos');
    }
  }

  async function addTodo() {
    try {
      if (!formState.name || !formState.description) return;
      const todo = { ...formState };
      setTodos([...todos, todo]);
      setFormState(initialState);
      await client.graphql({
        query: createTodo,
        variables: {
          input: todo,
        },
      });
    } catch (err) {
      console.log('error creating todo:', err);
    }
  }

  return (
    <div style={styles.container}>
      <h2>Amplify Todos</h2>
      <input
        onChange={(event) =>
          setFormState({ ...formState, name: event.target.value })
        }
        style={styles.input}
        value={formState.name}
        placeholder="Name"
      />
      <input
        onChange={(event) =>
          setFormState({ ...formState, description: event.target.value })
        }
        style={styles.input}
        value={formState.description as string}
        placeholder="Description"
      />
      <button style={styles.button} onClick={addTodo}>
        Create Todo
      </button>
      {todos.map((todo, index) => (
        <div key={todo.id ? todo.id : index} style={styles.todo}>
          <p style={styles.todoName}>{todo.name}</p>
          <p style={styles.todoDescription}>{todo.description}</p>
        </div>
      ))}
    </div>
  );
};

const styles = {
  container: {
    width: 400,
    margin: "0 auto",
    display: "flex",
    flexDirection: "column",
    justifyContent: "center",
    padding: 20,
  },
  todo: { marginBottom: 15 },
  input: {
    border: "none",
    backgroundColor: "#ddd",
    marginBottom: 10,
    padding: 8,
    fontSize: 18,
  },
  todoName: { fontSize: 20, fontWeight: "bold" },
  todoDescription: { marginBottom: 0 },
  button: {
    backgroundColor: "black",
    color: "white",
    outline: "none",
    fontSize: 18,
    padding: "12px 0px",
  },
} as const;

export default App;

```

</Block>
<Block name="JavaScript">

Open **src/App.jsx** and replace it with the following code:

```javascript
import { useEffect, useState } from 'react';

import { generateClient } from 'aws-amplify/api';

import { createTodo } from './graphql/mutations';
import { listTodos } from './graphql/queries';

const initialState = { name: '', description: '' };
const client = generateClient();

const App = () => {
  const [formState, setFormState] = useState(initialState);
  const [todos, setTodos] = useState([]);

  useEffect(() => {
    fetchTodos();
  }, []);

  function setInput(key, value) {
    setFormState({ ...formState, [key]: value });
  }

  async function fetchTodos() {
    try {
      const todoData = await client.graphql({
        query: listTodos
      });
      const todos = todoData.data.listTodos.items;
      setTodos(todos);
    } catch (err) {
      console.log('error fetching todos');
    }
  }

  async function addTodo() {
    try {
      if (!formState.name || !formState.description) return;
      const todo = { ...formState };
      setTodos([...todos, todo]);
      setFormState(initialState);
      await client.graphql({
        query: createTodo,
        variables: {
          input: todo
        }
      });
    } catch (err) {
      console.log('error creating todo:', err);
    }
  }

  return (
    <div style={styles.container}>
      <h2>Amplify Todos</h2>
      <input
        onChange={(event) => setInput('name', event.target.value)}
        style={styles.input}
        value={formState.name}
        placeholder="Name"
      />
      <input
        onChange={(event) => setInput('description', event.target.value)}
        style={styles.input}
        value={formState.description}
        placeholder="Description"
      />
      <button style={styles.button} onClick={addTodo}>
        Create Todo
      </button>
      {todos.map((todo, index) => (
        <div key={todo.id ? todo.id : index} style={styles.todo}>
          <p style={styles.todoName}>{todo.name}</p>
          <p style={styles.todoDescription}>{todo.description}</p>
        </div>
      ))}
    </div>
  );
};

const styles = {
  container: {
    width: 400,
    margin: '0 auto',
    display: 'flex',
    flexDirection: 'column',
    justifyContent: 'center',
    padding: 20
  },
  todo: { marginBottom: 15 },
  input: {
    border: 'none',
    backgroundColor: '#ddd',
    marginBottom: 10,
    padding: 8,
    fontSize: 18
  },
  todoName: { fontSize: 20, fontWeight: 'bold' },
  todoDescription: { marginBottom: 0 },
  button: {
    backgroundColor: 'black',
    color: 'white',
    outline: 'none',
    fontSize: 18,
    padding: '12px 0px'
  }
};

export default App;
```

</Block>
</BlockSwitcher>

**useEffect** - After the component renders, the `useEffect` hook is called and it invokes the `fetchTodos` function.

**fetchTodos** - Uses the Amplify API `client` created by `generateClient()` to call the AppSync GraphQL API with the `listTodos` query. Once the data is returned, the items array is passed in to the `setTodos` function to update the local state.

**addTodo** - Uses the Amplify API `client` created by `generateClient()` to call the AppSync GraphQL API with the `createTodo` mutation. A difference between the `listTodos` query and the `createTodo` mutation is that `createTodo` accepts an argument containing the variables needed for the mutation.

</InlineFilter>

<InlineFilter filters={['angular']}>

First, create a `todos` Angular component:

```bash
npx ng generate component --standalone todos
```

In `src/app/app.component.ts` update it to import `TodosComponent` and add it to the Component imports:

```ts
import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterOutlet } from '@angular/router';
import { TodosComponent } from './todos/todos.component';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [CommonModule, RouterOutlet, TodosComponent],
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'amplify-app';
}
```

Open `src/app/app.component.html`, and replace the default content with the Angular component you created:

```html
<app-todos></app-todos>
```

In your `src/app/todos/todos.component.ts` file, add data to your database with a mutation by using the `API.ts` file which was generated when you ran `amplify add api`. Additionally, make sure to import the needed form helpers as well as adding `ReactiveFormsModule` to your Component imports:

```typescript
import { Component } from '@angular/core';
import {
  FormBuilder,
  FormGroup,
  ReactiveFormsModule,
  Validators
} from '@angular/forms';
import { generateClient, type Client } from 'aws-amplify/api';
import { Todo, ListTodosQuery } from '../../API';
import * as mutations from '../../graphql/mutations';

@Component({
  standalone: true,
  imports: [ReactiveFormsModule],
  selector: 'app-todos',
  templateUrl: './todos.component.html',
  styleUrls: ['./todos.component.css']
})
export class TodosComponent {
  public createForm: FormGroup;
  public client: Client;

  constructor(private fb: FormBuilder) {
    this.createForm = this.fb.group({
      name: ['', Validators.required],
      description: ['', Validators.required]
    });

    this.client = generateClient();
  }

  public async onCreate(todo: Todo) {
    try {
      const response = await this.client.graphql({
        query: mutations.createTodo,
        variables: {
          input: todo
        }
      });
      console.log('item created!', response);
      this.createForm.reset();
    } catch (e) {
      console.log('error creating todo...', e);
    }
  }
}
```

Next, add a form that will be used for creating todos. Add the following to your `src/app/todos/todos.component.html`:

```html
<div class="form-body">
  <form
    autocomplete="off"
    [formGroup]="createForm"
    (ngSubmit)="onCreate(createForm.value)"
  >
    <div>
      <label>Name: </label>
      <input type="text" formControlName="name" autocomplete="off" />
    </div>
    <div>
      <label>Description: </label>
      <input type="text" formControlName="description" autocomplete="off" />
    </div>
    <button type="submit">Submit</button>
  </form>
</div>
```

Next, update your `TodosComponent` class so that it will list all todos in the database when the app starts. To do so, implement [OnInit](https://angular.io/api/core/OnInit) and add a `ListTodos` query in `src/app/todos/todos.component.ts`. Store the query results in an array.

```typescript
import { Component, OnInit } from '@angular/core';
import {
  FormBuilder,
  FormGroup,
  ReactiveFormsModule,
  Validators
} from '@angular/forms';

import { generateClient, type Client } from 'aws-amplify/api';
import { ListTodosQuery, Todo } from '../../API';
import * as mutations from '../../graphql/mutations';
import * as queries from '../../graphql/queries';

@Component({
  standalone: true,
  selector: 'app-todos',
  imports: [ReactiveFormsModule],
  templateUrl: './todos.component.html',
  styleUrls: ['./todos.component.css']
})
export class TodosComponent implements OnInit {
  public createForm: FormGroup;
  public client: Client;

  /* declare todos variable */
  public todos: ListTodosQuery['listTodos'];

  constructor(private fb: FormBuilder) {
    this.createForm = this.fb.group({
      name: ['', Validators.required],
      description: ['', Validators.required]
    });

    this.client = generateClient();
  }

  async ngOnInit() {
    /* fetch todos when app loads */
    try {
      const response = await this.client.graphql({
        query: queries.listTodos
      });
      this.todos = response.data.listTodos.items;
    } catch (e) {
      console.log('error fetching todos', e);
    }
  }

  public async onCreate(todo: Todo) {
    try {
      const response = await this.client.graphql({
        query: mutations.createTodo,
        variables: {
          input: todo
        }
      });
      console.log('item created!', response);
      this.createForm.reset();
    } catch (e) {
      console.log('error creating todo...', e);
    }
  }
}
```

Add the following to your `src/app/todos/todos.component.html` to display any of the todos you have added:

```html
<div>
  @for (todo of todos; track todo?.id) {
  <div>{{ todo?.name }}</div>
  <div>{{ todo?.description }}</div>
  } @empty {
  <div>There are no items.</div>
  }
</div>
```

To subscribe to realtime data, declare a subscription class variable and update `ngOnInit` in `src/app/todos.component.ts`. When the app starts, this code will set up a subscription. The subscription will update the `todos` array when new events are received (when a new todo is created):

```typescript
...

import * as subscriptions from '../../graphql/subscriptions'

export class TodosComponent implements OnInit {

  private subscription: any = null;

  ...

  async ngOnInit() {

    ...

    try {
      const res = await this.client.graphql({
        query: queries.listTodos
      })
      console.log(res)

      this.todos = res.data.listTodos.items;
    } catch(e) {
      console.log(e)
    };

    /* subscribe to new todos being created */
    this.subscription = this.client.graphql({
      query: subscriptions.onCreateTodo
    }).subscribe({
      next: (event: any) => {
        const newTodo = event.data.onCreateTodo;
        if(this.todos) {
          this.todos = [newTodo, ...this.todos];
        }
      }
    });
  }
}
```

Finally, unsubscribe from the subscription when the component is destroyed. Import and add `OnDestroy` in `src/app/todos.component.ts`:

```typescript
import { Component, OnDestroy, OnInit } from '@angular/core';

...

export class TodosComponent implements OnInit, OnDestroy {

  ...

  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    this.subscription = null;
  }
}
```

The final `todos.component.ts` file should look like the following:

```typescript
import { Component, OnInit, OnDestroy } from '@angular/core';
import {
  FormBuilder,
  FormGroup,
  ReactiveFormsModule,
  Validators
} from '@angular/forms';

import { generateClient, type Client } from 'aws-amplify/api';
import { Todo, ListTodosQuery } from '../../API';
import * as mutations from '../../graphql/mutations';
import * as queries from '../../graphql/queries';
import * as subscriptions from '../../graphql/subscriptions';

@Component({
  standalone: true,
  selector: 'app-todos',
  imports: [ReactiveFormsModule],
  templateUrl: './todos.component.html',
  styleUrls: ['./todos.component.css']
})
export class TodosComponent implements OnInit, OnDestroy {
  public todos: ListTodosQuery['listTodos'];
  public createForm: FormGroup;
  public client: Client;

  private subscription: any = null;

  constructor(private fb: FormBuilder) {
    this.createForm = this.fb.group({
      name: ['', Validators.required],
      description: ['', Validators.required]
    });

    this.client = generateClient();
  }

  async ngOnInit() {
    /* fetch todos when app loads */
    try {
      const response = await this.client.graphql({
        query: queries.listTodos
      });
      this.todos = response.data.listTodos.items;
    } catch (e) {
      console.log('error fetching todos', e);
    }

    this.subscription = this.client
      .graphql({
        query: subscriptions.onCreateTodo
      })
      .subscribe({
        next: (event: any) => {
          const newTodo: Todo = event.data.onCreateTodo;
          if (this.todos) {
            this.todos.items = [newTodo, ...this.todos];
          }
        }
      });
  }

  ngOnDestroy(): void {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    this.subscription = null;
  }

  public async onCreate(todo: Todo) {
    try {
      const response = await this.client.graphql({
        query: mutations.createTodo,
        variables: {
          input: todo
        }
      });
      console.log('item created!', response);
      this.createForm.reset();
    } catch (e) {
      console.log('error creating todo...', e);
    }
  }
}
```

</InlineFilter>

<InlineFilter filters={['react-native']}>

In this section you will create a way to list and create todos from the React application. To do this, you will create a form with a button to create todos as well as a way to fetch and render the list of todos.

<BlockSwitcher>
<Block name="Expo CLI">

Open **App.js** and replace it with the following code:

```javascript
import React, { useEffect, useState } from 'react';
import {
  StyleSheet,
  Text,
  View,
  TextInput,
  Pressable,
  SafeAreaView
} from 'react-native';
import { generateClient } from 'aws-amplify/api';
import { createTodo } from './src/graphql/mutations';
import { listTodos } from './src/graphql/queries';

import { Amplify } from 'aws-amplify';
import amplifyconfig from './src/amplifyconfiguration.json';
Amplify.configure(amplifyconfig);

const initialState = { name: '', description: '' };
const client = generateClient();

const App = () => {
  const [formState, setFormState] = useState(initialState);
  const [todos, setTodos] = useState([]);

  useEffect(() => {
    fetchTodos();
  }, []);

  function setInput(key, value) {
    setFormState({ ...formState, [key]: value });
  }

  async function fetchTodos() {
    try {
      const todoData = await client.graphql({
        query: listTodos
      });
      const todos = todoData.data.listTodos.items;
      setTodos(todos);
    } catch (err) {
      console.log('error fetching todos');
    }
  }

  async function addTodo() {
    try {
      if (!formState.name || !formState.description) return;
      const todo = { ...formState };
      setTodos([...todos, todo]);
      setFormState(initialState);
      await client.graphql({
        query: createTodo,
        variables: {
          input: todo
        }
      });
    } catch (err) {
      console.log('error creating todo:', err);
    }
  }

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.container}>
        <TextInput
          onChangeText={(value) => setInput('name', value)}
          style={styles.input}
          value={formState.name}
          placeholder="Name"
        />
        <TextInput
          onChangeText={(value) => setInput('description', value)}
          style={styles.input}
          value={formState.description}
          placeholder="Description"
        />
        <Pressable onPress={addTodo} style={styles.buttonContainer}>
          <Text style={styles.buttonText}>Create todo</Text>
        </Pressable>
        {todos.map((todo, index) => (
          <View key={todo.id ? todo.id : index} style={styles.todo}>
            <Text style={styles.todoName}>{todo.name}</Text>
            <Text style={styles.todoDescription}>{todo.description}</Text>
          </View>
        ))}
      </View>
    </SafeAreaView>
  );
};

export default App;

const styles = StyleSheet.create({
  container: { width: 400, flex: 1, padding: 20, alignSelf: 'center' },
  todo: { marginBottom: 15 },
  input: {
    backgroundColor: '#ddd',
    marginBottom: 10,
    padding: 8,
    fontSize: 18
  },
  todoName: { fontSize: 20, fontWeight: 'bold' },
  buttonContainer: {
    alignSelf: 'center',
    backgroundColor: 'black',
    paddingHorizontal: 8
  },
  buttonText: { color: 'white', padding: 16, fontSize: 18 }
});
```

</Block>
<Block name="React Native CLI">

Open **App.tsx** and replace it with the following code:

```javascript
import React, { useEffect, useState } from 'react';
import {
  StyleSheet,
  Text,
  View,
  TextInput,
  Pressable,
  SafeAreaView
} from 'react-native';
import { generateClient } from 'aws-amplify/api';
import { createTodo } from './src/graphql/mutations';
import { listTodos } from './src/graphql/queries';

const initialState = { name: '', description: '' };
const client = generateClient();

const App = () => {
  const [formState, setFormState] = useState(initialState);
  const [todos, setTodos] = useState([]);

  useEffect(() => {
    fetchTodos();
  }, []);

  function setInput(key, value) {
    setFormState({ ...formState, [key]: value });
  }

  async function fetchTodos() {
    try {
      const todoData = await client.graphql({
        query: listTodos
      });
      const todos = todoData.data.listTodos.items;
      setTodos(todos);
    } catch (err) {
      console.log('error fetching todos');
    }
  }

  async function addTodo() {
    try {
      if (!formState.name || !formState.description) return;
      const todo = { ...formState };
      setTodos([...todos, todo]);
      setFormState(initialState);
      await client.graphql({
        query: createTodo,
        variables: {
          input: todo
        }
      });
    } catch (err) {
      console.log('error creating todo:', err);
    }
  }

  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.container}>
        <TextInput
          onChangeText={(value) => setInput('name', value)}
          style={styles.input}
          value={formState.name}
          placeholder="Name"
        />
        <TextInput
          onChangeText={(value) => setInput('description', value)}
          style={styles.input}
          value={formState.description}
          placeholder="Description"
        />
        <Pressable onPress={addTodo} style={styles.buttonContainer}>
          <Text style={styles.buttonText}>Create todo</Text>
        </Pressable>
        {todos.map((todo, index) => (
          <View key={todo.id ? todo.id : index} style={styles.todo}>
            <Text style={styles.todoName}>{todo.name}</Text>
            <Text style={styles.todoDescription}>{todo.description}</Text>
          </View>
        ))}
      </View>
    </SafeAreaView>
  );
};

export default App;

const styles = StyleSheet.create({
  container: { width: 400, flex: 1, padding: 20, alignSelf: 'center' },
  todo: { marginBottom: 15 },
  input: {
    backgroundColor: '#ddd',
    marginBottom: 10,
    padding: 8,
    fontSize: 18
  },
  todoName: { fontSize: 20, fontWeight: 'bold' },
  buttonContainer: {
    alignSelf: 'center',
    backgroundColor: 'black',
    paddingHorizontal: 8
  },
  buttonText: { color: 'white', padding: 16, fontSize: 18 }
});
```

</Block>
</BlockSwitcher>

Let's walk through some of the functions:

**useEffect** - After the component renders, the `useEffect` hook is called and it invokes the `fetchTodos` function.

**fetchTodos** - Uses the Amplify API `client` created by `generateClient()` to call the AppSync GraphQL API with the `listTodos` query. Once the data is returned, the items array is passed in to the `setTodos` function to update the local state.

**addTodo** - Uses the Amplify API `client` created by `generateClient()` to call the AppSync GraphQL API with the `createTodo` mutation. A difference between the `listTodos` query and the `createTodo` mutation is that `createTodo` accepts an argument containing the variables needed for the mutation.

</InlineFilter>

<InlineFilter filters={['vue']}>

Next, open **App.vue**.

### Writing data with GraphQL mutations

To create a new todo in the database, create a `client` by using the `generateClient()` operation, then pass the `createTodo` mutation into `client.graphql()` along with the data you'd like to write.

```html
<script setup>
  import * as mutations from './graphql/mutations';
  import { generateClient } from 'aws-amplify/api';
  import { onMounted, ref } from 'vue';

  const name = ref('');
  const description = ref('');

  const client = generateClient();

  async function addTodo() {
    if (!name.value || !description.value) return;
    const todo = { name: name.value, description: description.value };
    await client.graphql({
      query: mutations.createTodo,
      variables: { input: todo }
    });
    name.value = '';
    description.value = '';
  }
</script>
<template>
  <div id="app">
    <h1>Todo App</h1>
    <input type="text" v-model="name" placeholder="Todo name" />
    <input type="text" v-model="description" placeholder="Todo description" />
    <button v-on:click="addTodo">Create Todo</button>
  </div>
</template>
```

### Reading data with GraphQL queries

To display the data, update `App.vue` to list all the items in the database by importing `queries` and then using the `onMounted()` Vue lifecycle hook to update the page when a query runs on page load:

```html
<script setup>
  import * as mutations from './graphql/mutations';
  import * as queries from './graphql/queries';
  import { generateClient } from 'aws-amplify/api';
  import { onMounted, ref } from 'vue';

  const name = ref('');
  const description = ref('');
  const todos = ref([]);

  const client = generateClient();

  async function addTodo() {
    if (!name.value || !description.value) return;
    const todo = { name: name.value, description: description.value };
    await client.graphql({
      query: mutations.createTodo,
      variables: { input: todo }
    });
    name.value = '';
    description.value = '';
  }

  async function fetchTodos() {
    const fetchedTodos = await client.graphql({
      query: queries.listTodos
    });

    todos.value = fetchedTodos.data.listTodos.items;
  }

  onMounted(() => {
    fetchTodos();
  });
</script>
<template>
  <div id="app">
    <h1>Todo App</h1>
    <input type="text" v-model="name" placeholder="Todo name" />
    <input type="text" v-model="description" placeholder="Todo description" />
    <button v-on:click="addTodo">Create Todo</button>

    <div v-for="item in todos" :key="item.id">
      <h3>{{ item.name }}</h3>
      <p>{{ item.description }}</p>
    </div>
  </div>
</template>
```

### Real-time data with GraphQL subscriptions

Now if you wish to subscribe to data, import the `onCreateTodo` subscription and create a new subscription by passing the `onCreateTodo` subscription on `client.graphql()` like so:

```html
<script setup>
  import * as mutations from './graphql/mutations';
  import * as queries from './graphql/queries';
  import * as subscriptions from './graphql/subscriptions';
  import { generateClient } from 'aws-amplify/api';
  import { onMounted, ref } from 'vue';

  const name = ref('');
  const description = ref('');
  const todos = ref([]);

  const client = generateClient();

  async function addTodo() {
    if (!name.value || !description.value) return;
    const todo = { name: name.value, description: description.value };
    await client.graphql({
      query: mutations.createTodo,
      variables: { input: todo }
    });
    name.value = '';
    description.value = '';
  }

  async function fetchTodos() {
    const fetchedTodos = await client.graphql({
      query: queries.listTodos
    });

    todos.value = fetchedTodos.data.listTodos.items;
  }

  function subscribeToNewTodos() {
    client
      .graphql({
        query: subscriptions.onCreateTodo
      })
      .subscribe({
        next: ({ data }) => {
          todos.value = [...todos.value, data.onCreateTodo];
        }
      });
  }

  onMounted(() => {
    fetchTodos();
    subscribeToNewTodos();
  });
</script>
<template>
  <div id="app">
    <h1>Todo App</h1>
    <input type="text" v-model="name" placeholder="Todo name" />
    <input type="text" v-model="description" placeholder="Todo description" />
    <button v-on:click="addTodo">Create Todo</button>

    <div v-for="item in todos" :key="item.id">
      <h3>{{ item.name }}</h3>
      <p>{{ item.description }}</p>
    </div>
  </div>
</template>
```

</InlineFilter>

</InlineFilter>

<InlineFilter filters={["nextjs"]}>
## API with Server-Side Rendering (SSR)

In this section you will create a way to list and create todos from the Next.js application. To do this, you will fetch & render the latest todos from the server as well as create a new todo.

### Generate the Amplify GraphQL API client

To make any GraphQL API requests service-side, we need to first generate an API client that we can use on server-side. To generate a new API client, import `generateServerClientUsingCookies` from `@aws-amplify/adapter-nextjs/api` and use it to generate a cookiesClient using the **amplifyconfiguration.json** in our project as `config` and `cookies` from `next/headers`.

<Callout info>

Amplify offers two API clients for Next.js server-side runtimes. Use `generateServerClientUsingCookies` primarily for use cases where `cookies` from `next/headers` is available, such as in App Router's React Server Components, Server Actions. Use `generateServerClientUsingReqRes` for use cases where a `NextRequest`/`NextResponse` are available, such as in the Pages Router or Middleware. Review [Connect to data from server-side runtimes](/[platform]/build-a-backend/graphqlapi/connect-from-server-runtime/) to review in-depth which API client to use for which use cases.

</Callout>

Open **src/app/page.tsx** and replace it with the following code:

```tsx
import { generateServerClientUsingCookies } from '@aws-amplify/adapter-nextjs/api';
import { cookies } from 'next/headers';

import config from '@/amplifyconfiguration.json';

const cookiesClient = generateServerClientUsingCookies({
  config,
  cookies
});

export default async function Home() {
  return (
    <div
      style={{
        maxWidth: '500px',
        margin: '0 auto',
        textAlign: 'center',
        marginTop: '100px'
      }}
    >
      <form>
        <input name="name" placeholder="Add a todo" />
        <button type="submit">Add</button>
      </form>
    </div>
  );
}
```

### Create a form for submitting the todos

In Next.js you can use a [Server Action](https://nextjs.org/docs/app/api-reference/functions/server-actions) to handle form submission server-side. Let's add a Server Action which submits its data to the `createTodo` function. When called, `createTodo` should send a GraphQL mutation via `cookiesClient.graphql(...)` to the GraphQL API, then call `revalidatePath` from the Next.js cache to invalidate the page cache and fetch the latest todos.

Update the **src/app/page.tsx** with the following code:

```tsx
import { generateServerClientUsingCookies } from '@aws-amplify/adapter-nextjs/api';
import { cookies } from 'next/headers';
// 1. Add the following two imports
import { revalidatePath } from 'next/cache';
import * as mutations from '@/graphql/mutations';

import config from '@/amplifyconfiguration.json';

const cookiesClient = generateServerClientUsingCookies({
  config,
  cookies
});

// 2. Create a new Server Action
async function createTodo(formData: FormData) {
  'use server';
  const { data } = await cookiesClient.graphql({
    query: mutations.createTodo,
    variables: {
      input: {
        name: formData.get('name')?.toString() ?? ''
      }
    }
  });

  console.log('Created Todo: ', data?.createTodo);

  revalidatePath('/');
}

export default async function Home() {
  return (
    <div
      style={{
        maxWidth: '500px',
        margin: '0 auto',
        textAlign: 'center',
        marginTop: '100px'
      }}
    >
      {/* 3. Update the form's action to use the
          new create Todo Server Action*/}
      <form action={createTodo}>
        <input name="name" placeholder="Add a todo" />
        <button type="submit">Add</button>
      </form>
    </div>
  );
}
```

### List todos

Using `cookiesClient.graphql(...)` we make GraphQL queries as well. Pass in the `listTodos` query and assign the items returned to `todos` then iterate over them to display in a `<ul>` tag. If there are no todos, we display the message "No todos, please add one".

Update the **src/app/page.tsx** with the following code:

```tsx
import { generateServerClientUsingCookies } from '@aws-amplify/adapter-nextjs/api';
import { cookies } from 'next/headers';
import { revalidatePath } from 'next/cache';
import * as mutations from '@/graphql/mutations';
// 1. Add the queries as an import
import * as queries from '@/graphql/queries';

import config from '@/amplifyconfiguration.json';

const cookiesClient = generateServerClientUsingCookies({
  config,
  cookies
});

async function createTodo(formData: FormData) {
  'use server';
  const { data } = await cookiesClient.graphql({
    query: mutations.createTodo,
    variables: {
      input: {
        name: formData.get('name')?.toString() ?? ''
      }
    }
  });

  console.log('Created Todo: ', data?.createTodo);

  revalidatePath('/');
}

export default async function Home() {
  // 2. Fetch additional todos
  const { data, errors } = await cookiesClient.graphql({
    query: queries.listTodos
  });

  const todos = data.listTodos.items;

  return (
    <div
      style={{
        maxWidth: '500px',
        margin: '0 auto',
        textAlign: 'center',
        marginTop: '100px'
      }}
    >
      <form action={createTodo}>
        <input name="name" placeholder="Add a todo" />
        <button type="submit">Add</button>
      </form>

      {/* 3. Handle edge cases & zero state & error states*/}
      {(!todos || todos.length === 0 || errors) && (
        <div>
          <p>No todos, please add one.</p>
        </div>
      )}

      {/* 4. Display todos*/}
      <ul>
        {todos.map((todo) => {
          return <li style={{ listStyle: 'none' }}>{todo.name}</li>;
        })}
      </ul>
    </div>
  );
}
```

</InlineFilter>

## Run locally

Next, run the app and you should see the updated UI with the ability to create and view the list of todos:

<InlineFilter filters={['react', 'javascript', 'vue', 'nextjs']}>

```bash
npm run dev
```

</InlineFilter>
<InlineFilter filters={['angular']}>

```bash
npm start
```

</InlineFilter>
<InlineFilter filters={['react-native']}>

Start the app with the following command:

<BlockSwitcher>
<Block name="Expo CLI">

For Android:

```sh
npx expo run:android
```

For iOS:

```sh
npx expo run:ios
```

</Block>
<Block name="React Native CLI">

```bash
npm start
```

</Block>
</BlockSwitcher>
</InlineFilter>

</InlineFilter>

You have successfully deployed your API and connected it to your app!
