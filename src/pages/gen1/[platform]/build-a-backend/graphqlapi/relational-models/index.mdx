import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Relational models',
  description:
    'Learn more about how API (GraphQL) handles relationships between Models, such as "has one", "has many", "belongs to".',
  platforms: [
    'android',
    'swift'
    ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

<InlineFilter filters={["android", "swift"]}>

API (GraphQL) has the capability to handle relationships between Models, such as _has one_, _has many_, and _belongs to_. In Amplify GraphQL APIs, this is done with the `@hasOne`, `@hasMany` and `@belongsTo` directives as defined in the [GraphQL data modeling documentation](/gen1/[platform]/build-a-backend/graphqlapi/data-modeling/).

By default, GraphQL APIs requests generate a selection set with a depth of 0. Connected relationship models are not returned in the initial request, but can be lazily loaded as needed with an additional API request. We provide mechanisms to customize the selection set, which allows connected relationships to be eagerly loaded on the initial request.

<Callout warning>

With versions of Amplify CLI `@aws-amplify/cli@12.12.2` and API Category `@aws-amplify/amplify-category-api@5.11.5`, an improvement was made to how relational field data is handled in subscriptions when different authorization rules apply to related models in a schema. The improvement redacts the values for the relational fields, displaying them as null or empty, to prevent unauthorized access to relational data.

This redaction occurs whenever it cannot be determined that the child model will be protected by the same permissions as the parent model.

Because subscriptions are tied to mutations and the selection set provided in the result of a mutation is then passed through to the subscription, relational fields in the result of mutations must be redacted.

If an authorized end-user needs access to the redacted relational fields, they should perform a query to read the relational data.

Additionally, subscriptions will inherit related authorization when relational fields are set as required. To better protect relational data, consider modifying the schema to use optional relational fields.

- **Lazy and Eager Loading**: Lazy and eager loading relationships is no longer supported for Mutations and Subscriptions. However, you can continue to perform eager or lazy loading for Queries.

- **Subscriptions and Related Models**: When performing a subscription and you need to retrieve the related model, perform a lazy or eager loaded query using the model identifier from the subscription event to continue to retrieve the related data.

Based on the security posture of your application, you can choose to revert to the subscription behavior before this improvement was made.
To do so, use the `subscriptionsInheritPrimaryAuth` feature flag under `graphqltransformer` in the `amplify/backend/cli.json` file.

- If enabled, subscriptions will inherit the primary model authorization rules for the relational fields.
- If disabled, relational fields will be redacted in mutation response when there is a difference between auth rules between primary and related models.

</Callout>

## Prerequisites

The following examples have a minimum version requirement of the following:

<InlineFilter filters={["android"]}>

- Amplify CLI v12.7.0
- Amplify Android Library v2.14.0
- This guide uses updated model types generated by the Amplify CLI. To follow this guide, locate `"generatemodelsforlazyloadandcustomselectionset"` in `{project-directory}/amplify/cli.json` and set the value to `true`.

<Callout>

If you already have relational models in your project, you must re-run `amplify codegen models` after updating the feature flag. After the models have been updated, breaking changes will need to be addressed because relationship fields will now be wrapped in `ModelList`/`ModelReference` types. Follow the rest of the guide on this page information on how to use the new lazy supported models.

</Callout>

</InlineFilter>

<InlineFilter filters={["swift"]}>

- Amplify CLI v10.8.0
- Amplify Library for Swift v2.4.0
- This guide uses updated model types generated by the Amplify CLI. To follow this guide, locate `"generatemodelsforlazyloadandcustomselectionset"` in `{project-directory}/amplify/cli.json` and set the value to `true`.

<Callout>

If you already have relational models in your project, you must re-run `amplify codegen models` after updating the feature flag. After the models have been updated, breaking changes will need to be addressed because some relationships have changed to `async`. Follow the rest of the guide on this page information on how to use the new lazy supported models.

</Callout>

</InlineFilter>

## Create a GraphQL schema with relationships between models

For the following example, let's add a Post and Comment model to the [schema](/gen1/[platform]/build-a-backend/graphqlapi/set-up-graphql-api/#creating-your-first-api-and-database-table):

```graphql
type Post @model {
  id: ID!
  title: String!
  rating: Int!
  comments: [Comment] @hasMany
}

type Comment @model {
  id: ID!
  content: String
  post: Post @belongsTo
}
```

Generate the models for the updated schema using the [Amplify CLI](/gen1/[platform]/build-a-backend/graphqlapi/set-up-graphql-api/).

```bash
amplify codegen models
```

## Creating relationships

In order to create connected models, you will create an instance of the model you wish to connect and pass it to `Amplify.API.mutate`:

<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
Post post = Post.builder()
    .title("My Post with comments")
    .rating(10)
    .build();

Comment comment = Comment.builder()
    .post(post) // Directly pass in the post instance
    .content("Loving Amplify API!")
    .build();

Amplify.API.mutate(ModelMutation.create(post),
    savedPost -> {
        Log.i("MyAmplifyApp", "Post created.");
        Amplify.API.mutate(ModelMutation.create(comment),
                savedComment -> Log.i("MyAmplifyApp", "Comment created."),
                failure -> Log.e("MyAmplifyApp", "Comment not created.", failure)
        );
    },
    failure -> Log.e("MyAmplifyApp", "Post not created.", failure)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val post = Post.builder()
    .title("My Post with comments")
    .rating(10)
    .build()

val comment = Comment.builder()
    .post(post) // Directly pass in the post instance
    .content("Loving Amplify API!")
    .build()

Amplify.API.mutate(ModelMutation.create(post),
    {
        Log.i("MyAmplifyApp", "Post created")
        Amplify.API.mutate(ModelMutation.create(comment),
            { Log.i("MyAmplifyApp", "Comment created") },
            { Log.e("MyAmplifyApp", "Comment not created", it) }
        )
    },
    { Log.e("MyAmplifyApp", "Post not created", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val post = Post.builder()
    .title("My Post with comments")
    .rating(10)
    .build()

val comment = Comment.builder()
    .post(post) // Directly pass in the post instance
    .content("Loving Amplify API!")
    .build()

try {
    Amplify.API.mutate(ModelMutation.create(post))
    Log.i("MyAmplifyApp", "Post created.")

    Amplify.API.mutate(ModelMutation.create(comment))
    Log.i("MyAmplifyApp", "Comment created.")
} catch (error: ApiException) {
    Log.e("MyAmplifyApp", "Create failed", error)
}
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["swift"]}>

<Block>

```swift
do {
    let post = Post(title: "My post with comments",
                    rating: 10)
    let comment = Comment(content: "Loving Amplify API!",
                            post: post) // Directly pass in the post instance
    
    let createPostResult = try await Amplify.API.mutate(request: .create(post))
    guard case .success = createPostResult else {
        print("API response: \(createPostResult)")
        return
    }
    print("Post created.")
    let createCommentResult = try await Amplify.API.mutate(request: .create(comment))
    guard case .success = createCommentResult else {
        print("API response: \(createCommentResult)")
        return
    }
    print("Comment created.")
} catch {
    print("Create post or comment failed", error)
}
```

</Block>
</InlineFilter>

## Querying relationships

This example demonstrates an initial load of a Post with a subsequent fetch to load a page of comments for the post.

<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
Amplify.API.query(
    ModelQuery.get(Post.class, new Post.PostIdentifier("123")),
    response -> {
        Post post = response.getData();
        ModelList<Comment> commentsModelList = post.getComments();

        if (commentsModelList instanceof LoadedModelList) {
            List<Comment> comments =
                ((LoadedModelList<Comment>) commentsModelList).getItems();
            Log.i("MyAmplifyApp", "Loaded " + comments.size() + " comments.");
        } else if (commentsModelList instanceof LazyModelList) {
            ((LazyModelList<Comment>) commentsModelList).fetchPage(
                page -> {
                    List<Comment> comments = page.getItems();
                    Log.i("MyAmplifyApp", "Loaded " + comments.size() + " comments.");
                },
                failure -> Log.e("MyAmplifyApp, ", "Failed to fetch comments", failure)
            );
        }
    },
    failure -> Log.e("MyAmplifyApp", "Failed to query post.", failure)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.API.query(
    ModelQuery[Post::class.java, Post.PostIdentifier("123")],
    { response ->
        val post = response.data
        when (val commentsModelList = post.comments) {
            is LoadedModelList -> {
                val comments = commentsModelList.items
                Log.i("MyAmplifyApp", "Loaded ${comments.size} comments")
            }
            is LazyModelList -> {
                commentsModelList.fetchPage(
                    { page ->
                        val comments = page.items
                        Log.i("MyAmplifyApp", "Fetched ${comments.size} comments")
                    },
                    { Log.e("MyAmplifyApp, ", "Failed to fetch comments", it) }
                )
            }
        }
    },
    { Log.e("MyAmplifyApp, ", "Failed to fetch post", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val response =
        Amplify.API.query(ModelQuery[Post::class.java, Post.PostIdentifier("123")])
    val post = response.data
    val comments = when (val commentsModelList = post.comments) {
        is LoadedModelList -> {
            commentsModelList.items
        }
        is LazyModelList -> {
            commentsModelList.fetchPage().items
        }
    }
    Log.i("MyAmplifyApp", "Fetched ${comments.size} comments")
} catch (error: ApiException) {
    Log.e("MyAmplifyApp", "Failed to fetch post and its comments", error)
}
```

</Block>
</BlockSwitcher>

In order to handle the loaded/lazy states of relationships, the code generated models wrap relationships in `ModelReference` and `ModelList` types.

```java
public final class Post implements Model {

  public ModelList<Comment> getComments()
}

public final class Comment implements Model {

  public ModelReference<Post> getPost()
}
```

ModelReference and ModelList types are either Lazy (Default) or Loaded. See [Customizing Query Depth](#customizing-query-depth-with-custom-selection-sets) to learn how to eagerly load connected relationships.

- ModelReference\<M\>
  - LazyModelReference\<M\>
  - LoadedModelReference\<M\>
- ModelList\<M\>
  - LazyModelList\<M\>
  - LoadedModelList\<M\>

### Unwrap ModelReference type

<BlockSwitcher>
<Block name="Java">

```java
void getPostFromComment(Comment comment) {
    ModelReference<Post> postReference = comment.getPost();
    if (postReference instanceof LoadedModelReference) {
        LoadedModelReference<Post> loadedPost = ((LoadedModelReference<Post>) postReference);
        Post post = loadedPost.getValue();
        Log.i("MyAmplifyApp", "Post: " + post);
    } else if (postReference instanceof LazyModelReference) {
        LazyModelReference<Post> lazyPost = ((LazyModelReference<Post>) postReference);
        lazyPost.fetchModel(
            post -> Log.i("MyAmplifyApp", "Post: $post"),
            error -> Log.e("MyAmplifyApp", "Failed to fetch post", error)
        );
    }
}
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
fun getPostFromComment(comment: Comment) {
    when (val postReference = comment.post) {
        is LoadedModelReference -> {
            val post = postReference.value
            Log.i("MyAmplifyApp", "Post: $post")
        }
        is LazyModelReference -> {
            postReference.fetchModel(
                { post -> Log.i("MyAmplifyApp", "Post: $post") },
                { Log.e("MyAmplifyApp", "Failed to fetch post", it) }
            )
        }
    }
}
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
suspend fun getPostFromComment(comment: Comment) {
    try {
        val post = when (val postReference = comment.post) {
            is LoadedModelReference -> {
                postReference.value
            }

            is LazyModelReference -> {
                postReference.fetchModel()
            }
        }
        Log.i("MyAmplifyApp", "Post: $post")
    } catch (error: ApiException) {
        Log.e("MyAmplifyApp", "Failed to fetch post", error)
    }
}
```

</Block>
</BlockSwitcher>

### Unwrap ModelList type

<BlockSwitcher>
<Block name="Java">

```java
void getCommentsForPost(Post post) {
    ModelList<Comment> commentsModelList = post.getComments();
    if (commentsModelList instanceof LoadedModelList) {
        LoadedModelList<Comment> loadedComments = ((LoadedModelList<Comment>) commentsModelList);
        // Eager loading loads the 1st page only.
        loadedComments.getItems();
    } else if (commentsModelList instanceof LazyModelList) {
        LazyModelList<Comment> lazyComments = ((LazyModelList<Comment>) commentsModelList);
        fetchComments(lazyComments, null);
    }
}

void fetchComments(LazyModelList<Comment> lazyComments, PaginationToken token) {
    lazyComments.fetchPage(
        token,
        page -> {
            List<Comment> comments = page.getItems();
            Log.i("MyAmplifyApp", "Page of comments: " + comments);
            if (page.getHasNextPage()) {
                PaginationToken nextToken = page.getNextToken();
                fetchComments(lazyComments, nextToken); // recursively fetch next page
            }
        },
        error -> Log.e("MyAmplifyApp", "Failed to fetch comments page", error)
    );
}
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
// Post comes from server response
fun getCommentsForPost(post: Post) {
    when (val commentsModelList = post.comments) {
        is LoadedModelList -> {
            // Eager loading loads the 1st page only.
            commentsModelList.items
        }
        is LazyModelList -> {
            // Helper method to load all pages
            fetchComments(commentsModelList)
        }
    }
}

// Helper method for callback approach
fun fetchComments(lazyComments: LazyModelList<Comment>, token: PaginationToken? = null) {
    lazyComments.fetchPage(
        token,
        { page ->
            val comments = page.items
            Log.i("MyAmplifyApp", "Page of comments: $comments")
            if (page.hasNextPage) {
                val nextToken = page.nextToken
                fetchComments(lazyComments, nextToken) // recursively fetch next page
            }
        },
        { Log.e("MyAmplifyApp", "Failed to fetch comments page", it) }
    )
}
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
suspend fun getCommentsForPost(post: Post) {
    try {
        val comments = when (val commentsModelList = post.comments) {
            is LoadedModelList -> {
                // Eager loading loads the 1st page only.
                commentsModelList.items
            }
            is LazyModelList -> {
                var page = commentsModelList.fetchPage()
                var loadedComments = mutableListOf(page.items) // initial page of comments
                // loop through all pages to fetch the full list of comments
                while (page.hasNextPage) {
                    val nextToken = page.nextToken
                    page = commentsModelList.fetchPage(nextToken)
                    // add the page of comments to the comments variable
                    loadedComments += page.items
                }
                loadedComments
            }
        }
        Log.i("MyAmplifyApp", "Comments: $comments")
    } catch (error: ApiException) {
        Log.e("MyAmplifyApp", "Failed to fetch comments", error)
    }
}
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["swift"]}>

<Block>

```swift
do {
    let queryPostResult = try await Amplify.API.query(request: .get(Post.self, byIdentifier: "123"))
    guard case .success(let queriedPostOptional) = queryPostResult,
            let queriedPost = queriedPostOptional,
            let comments = queriedPost.comments else {
        print("API response: \(queryPostResult)")
        return
    }
    try await comments.fetch()
    print("Fetched \(comments.count) comments")
} catch {
    print("Failed to query post or fetch comments", error)
}
```

</Block>

Always call `fetch()` to load or retrieve the comments. If the comments were loaded as part of the query, it will return immediately. See [Customizing Query Depth](#customizing-query-depth-with-custom-selection-sets) to learn how to eagerly load connected relationships.

</InlineFilter>

## Deleting relationships

When you delete a parent object in a one-to-many relationship, the children will not be removed. Delete the children before deleting the parent to prevent orphaned data.

<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
// Delete any comments associated with parent post.
Amplify.API.mutate(
    ModelMutation.delete(comment),
    commentResponse ->
        // Once all comments for a post are deleted, the post can be deleted.
        Amplify.API.mutate(
            ModelMutation.delete(post),
            postResponse -> Log.i("MyAmplifyApp", "Deleted comment and post"),
            (error) -> Log.e("MyAmplifyApp", "Failed to delete post", error)
        ),
    error -> Log.e("MyAmplifyApp", "Failed to delete comment", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.API.mutate(
    // Delete any comments associated with parent post.
    ModelMutation.delete(comment),
    {
        // Once all comments for a post are deleted, the post can be deleted.
        Amplify.API.mutate(
            ModelMutation.delete(post),
            { Log.i("MyAmplifyApp", "Deleted comment and post") },
            { Log.e("MyAmplifyApp", "Failed to delete post", it) }
        )
    },
    { Log.e("MyAmplifyApp", "Failed to delete comment", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    // Delete any comments associated with parent post.
    Amplify.API.mutate(ModelMutation.delete(comment))
    // Once all comments for a post are deleted, the post can be deleted.
    Amplify.API.mutate(ModelMutation.delete(post))
    Log.i("MyAmplifyApp", "Deleted comment and post")
} catch (error: ApiException) {
    Log.e("MyAmplifyApp", "Failed to delete comment and post", error)
}
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["swift"]}>

<Block>

```swift
do {
    let deleteCommentResult = try await Amplify.API.mutate(request: .delete(comment))
    guard case .success = deleteCommentResult else {
        print("API response: \(deleteCommentResult)")
        return
    }
    // Once all comments for a post are deleted, the post can be deleted.
    let deletePostResult = try await Amplify.API.mutate(request: .delete(post))
    guard case .success = deletePostResult else {
        print("API response: \(deletePostResult)")
        return
    }
    print("Deleted comment and post")
} catch {
    print("Failed to delete comment or post", error)
}
```

</Block>

</InlineFilter>

## Many-to-many relationships

For many-to-many relationships, you can use the `@manyToMany` directive and specify a `relationName`. Under the hood, Amplify creates a join table and a one-to-many relationship from both models.

<Callout warning>

Join table records must be deleted prior to deleting the associated records. For example, for a many-to-many relationship between `Post`s and `Tag`s, delete the `PostTag`s join record prior to deleting a `Post` or `Tag`.

</Callout>

```graphql
type Post @model {
  id: ID!
  title: String!
  rating: Int
  editors: [User] @manyToMany(relationName: "PostEditor")
}

type User @model {
  id: ID!
  username: String!
  posts: [Post] @manyToMany(relationName: "PostEditor")
}
```

<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
Post post = Post.builder()
    .title("My Post")
    .rating(10)
    .build();

User user = User.builder()
    .username("User")
    .build();

PostEditor postEditor = PostEditor.builder()
    .post(post)
    .user(user)
    .build();

Amplify.API.mutate(ModelMutation.create(post),
    createdPost -> {
        Log.i("MyAmplifyApp", "Post created.");
        Amplify.API.mutate(ModelMutation.create(user),
                createdUser -> {
                    Log.i("MyAmplifyApp", "User created.");
                    Amplify.API.mutate(ModelMutation.create(postEditor),
                            createdPostEditor -> Log.i("MyAmplifyApp", "PostEditor created."),
                            failure -> Log.e("MyAmplifyApp", "PostEditor not created.", failure)
                    );
                },
                failure -> Log.e("MyAmplifyApp", "User not created.", failure)
        );
    },
    failure -> Log.e("MyAmplifyApp", "Post not created.", failure)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val post = Post.builder()
    .title("My Post")
    .rating(10)
    .build()

val user = User.builder()
    .username("User")
    .build()

val postEditor = PostEditor.builder()
    .post(post)
    .user(user)
    .build()

Amplify.API.mutate(ModelMutation.create(post),
    {
        Log.i("MyAmplifyApp", "Post created")
        Amplify.API.mutate(ModelMutation.create(user),
            {
                Log.i("MyAmplifyApp", "User created")
                Amplify.API.mutate(
                    ModelMutation.create(postEditor),
                    { Log.i("MyAmplifyApp", "PostEditor created") },
                    { Log.e("MyAmplifyApp", " PostEditor not created", it) }
                )
            },
            { Log.e("MyAmplifyApp", " User not created", it) }
        )
    },
    { Log.e("MyAmplifyApp", "Post not created", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val post = Post.builder()
    .title("My Post")
    .rating(10)
    .build()

val user = User.builder()
    .username("User")
    .build()

val postEditor = PostEditor.builder()
    .post(post)
    .user(user)
    .build()

try {
    Amplify.API.mutate(ModelMutation.create(post))
    Log.i("MyAmplifyApp", "Post created.")

    Amplify.API.mutate(ModelMutation.create(user))
    Log.i("MyAmplifyApp", "User created.")

    Amplify.API.mutate(ModelMutation.create(postEditor))
    Log.i("MyAmplifyApp", "PostEditor created.")
} catch (error: ApiException) {
    Log.e("MyAmplifyApp", "Create failed", error)
}
```

</Block>
</BlockSwitcher>

<Callout>

This example illustrates the complexity of working with multiple sequential create operations. To remove the nested callbacks, consider using Amplify's support for [Coroutines](/gen1/[platform]/start/project-setup/kotlin-coroutines/).

</Callout>

</InlineFilter>

<InlineFilter filters={["swift"]}>

<Block>

```swift
do {
    let post = Post(title: "My Post", rating: 10)
    let user = User(username: "User")
    let postEditor = PostEditor(post: post, user: user)
    
    let createPostResult = try await Amplify.API.mutate(request: .create(post))
    guard case .success = createPostResult else {
        print("API response: \(createPostResult)")
        return
    }
    let createUserResult = try await Amplify.API.mutate(request: .create(user))
    guard case .success = createUserResult else {
        print("API response: \(createUserResult)")
        return
    }
    let createPostEditorResult = try await Amplify.API.mutate(request: .create(postEditor))
    guard case .success = createPostEditorResult else {
        print("API response: \(createPostEditorResult)")
        return
    }
} catch {
    print("Failed to create post, user, or post editor", error)
}
```

</Block>

</InlineFilter>

## Customizing query depth with custom selection sets

You can perform a nested query through one network request, by specifying which connected models to include. This is achieved by using the optional `includes` parameter for a GraphQL request.

Query for the `Comment` and the `Post` that it belongs to:

<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
Amplify.API.query(
    ModelQuery.<Comment, CommentPath>get(
        Comment.class,
        new Comment.CommentIdentifier("c1"),
        (commentPath -> includes(commentPath.getPost()))
    ),
    response -> {
        Comment comment = response.getData();
        ModelReference<Post> postReference = comment.getPost();
        if (postReference instanceof LoadedModelReference) {
            Post post = ((LoadedModelReference<Post>) postReference).getValue();
            Log.i("MyAmplifyApp", "Post: " + post);
        }
    },
    failure -> Log.e("MyAmplifyApp", "Failed to fetch post", failure)
);
```

This will populate the selection set of the post in the GraphQL document which indicates to your GraphQL service to retrieve the post model as part of the operation. Once the comment is loaded, the post model is immediately available in-memory without requiring an additional network request.

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.API.query(
    ModelQuery.get<Comment, CommentPath>(
        Comment::class.java,
        Comment.CommentIdentifier("c1")
    ) { commentPath ->
        includes(commentPath.post)
    },
    { response ->
        val comment = response.data
        val post = (comment.post as? LoadedModelReference)?.value
        Log.i("MyAmplifyApp", "Post: $post")
    },
    { Log.e("MyAmplifyApp", "Failed to fetch post", it) }
)
```

This will populate the selection set of the post in the GraphQL document which indicates to your GraphQL service to retrieve the post model as part of the operation. Once the comment is loaded, the post model is immediately available in-memory without requiring an additional network request.

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val comment = Amplify.API.query(
        ModelQuery.get<Comment, CommentPath>(
            Comment::class.java,
            Comment.CommentIdentifier("c1")
        ) { commentPath ->
            includes(commentPath.post)
        }
    ).data
    val post = (comment.post as? LoadedModelReference)?.value
    Log.i("MyAmplifyApp", "Post: $post")
} catch (error: ApiException) {
    Log.e("MyAmplifyApp", "Failed to fetch post", error)
}
```

This will populate the selection set of the post in the GraphQL document which indicates to your GraphQL service to retrieve the post model as part of the operation. Once the comment is loaded, the post model is immediately available in-memory without requiring an additional network request.

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["swift"]}>

<Block>

```swift
do {
    let queryCommentResult = try await Amplify.API.query(request:
            .get(Comment.self,
                 byIdentifier: "c1",
                 includes: { comment in
        [comment.post]
    }))
    guard case .success(let queriedCommentOptional) = queryCommentResult,
            let queriedComment = queriedCommentOptional,
            let loadedPost = try await queriedComment.post else {
        print("API response: \(queryCommentResult)")
        return
    }
    
    print("Post: ", loadedPost)
} catch {
    print("Failed to query comment with post", error)
}
```
This will populate the selection set of the post in the GraphQL document which indicates to your GraphQL service to retrieve the post model as part of the operation. Once the comment is loaded, the post model is immediately available in-memory without requiring an additional network request.

</Block>

</InlineFilter>

Query for the `Post` and the first page of comments for the post:

<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
Amplify.API.query(
    ModelQuery.<Post, PostPath>get(
        Post.class,
        new Post.PostIdentifier("p1"),
        (postPath -> includes(postPath.getComments()))
    ),
    response -> {
        Post post = response.getData();
        ModelList<Comment> commentsModelList = post.getComments();
        if (commentsModelList instanceof LoadedModelList) {
            List<Comment> comments = ((LoadedModelList<Comment>) commentsModelList).getItems();
            Log.i("MyAmplifyApp", "Comments: " + comments);
        }
    },
    failure -> Log.e("MyAmplifyApp", "Failed to fetch post", failure)
);
```

The network request for post includes the comments, eagerly loading the first page of comments in a single network call.

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.API.query(
    ModelQuery.get<Post, PostPath>(
        Post::class.java,
        Post.PostIdentifier("p1")
    ) { postPath ->
        includes(postPath.comments)
    },
    { response ->
        val post = response.data
        val comments = (post.comments as? LoadedModelList)?.items
        Log.i("MyAmplifyApp", "Comments: $comments")
    },
    { Log.e("MyAmplifyApp", "Failed to fetch post", it) }
)
```

The network request for post includes the comments, eagerly loading the first page of comments in a single network call.

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val post = Amplify.API.query(
        ModelQuery.get<Post, PostPath>(
            Post::class.java,
            Post.PostIdentifier("p1")
        ) { postPath ->
            includes(postPath.comments)
        }
    ).data
    val comments = (post.comments as? LoadedModelList)?.items
    Log.i("MyAmplifyApp", "Comments: $comments")
} catch (error: ApiException) {
    Log.e("MyAmplifyApp", "Failed to fetch post", error)
}
```

The network request for post includes the comments, eagerly loading the first page of comments in a single network call.

</Block>
</BlockSwitcher>

You can generate complex nested queries through the includes parameter.

<BlockSwitcher>
<Block name="Java">

```java
ModelQuery.get<Comment, CommentPath>(Comment::class.java, "c1") { commentPath ->
    includes(commentPath.post.comments)
}
```

This query fetches a comment, eagerly loading the parent post and first page of comments for the post.

</Block>
<Block name="Kotlin">

```kotlin
ModelQuery.get<Comment, CommentPath>(
    Comment::class.java,
    "c1"
) { commentPath ->
    includes(commentPath.post.comments)
}
```

This query fetches a comment, eagerly loading the parent post and first page of comments for the post.

</Block>
</BlockSwitcher>

<BlockSwitcher>
<Block name="Java">

```java
ModelQuery.get<PostEditor, PostEditorPath>(PostEditor::class.java, "pe1") { postEditorPath ->
    includes(postEditorPath.post, postEditorPath.user)
}
```

This query fetches a postEditor and eagerly loads its post and user

</Block>
<Block name="Kotlin">

```kotlin
ModelQuery.get<PostEditor, PostEditorPath>(
    PostEditor::class.java,
    "pe1"
) { postEditorPath ->
    includes(postEditorPath.post, postEditorPath.user)
}
```

This query fetches a postEditor and eagerly loads its post and user

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["swift"]}>

<Block>

```swift
do {
    let queryPostResult = try await Amplify.API.query(request: 
            .get(Post.self,
                 byIdentifier: "p1",
                 includes: { post in
        [post.comments]
    }))
    guard case .success(let queriedPostOptional) = queryPostResult,
            let queriedPost = queriedPostOptional,
            let comments = queriedPost.comments else {
        print("API response: \(queryPostResult)")
        return
    }
    
    try await comments.fetch()
    print("Comments: ", comments)
} catch {
    print("Failed to query post with comments", error)
}
```

The network request for post includes the comments, eagerly loading the first page of comments in a single network call.

</Block>

You can generate complex nested queries through the includes parameter.

<Block>

```swift
let queryCommentResult = try await Amplify.API.query(request: 
    .get(Comment.self,
         byIdentifier: "p1",
         includes: { comment in
    [comment.post.comments]
}))
```

This query fetches a comment, eagerly loading the parent post and first page of comments for the post.

</Block>

<Block>

```swift
let queryCommentResult = try await Amplify.API.query(request:
        .get(PostEditor.self,
             byIdentifier: "pe1",
             includes: { postEditor in
    [postEditor.post, postEditor.user]
}))
```

This query fetches a postEditor and eagerly loads its post and user

</Block>
</InlineFilter>

</InlineFilter>
