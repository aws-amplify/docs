The GraphQL API category can be used with [TanStack Query](https://tanstack.com/query/latest/docs/react/overview) to implement optimistic UI, allowing CRUD operations to be rendered immediately on the UI before the request roundtrip has completed.

To get started, run the following command in an existing Amplify project:

```bash
# Install TanStack Query
npm i @tanstack/react-query

# Select default configuration
amplify add api              
```

When prompted, use the following schema, which can also be found under `amplify/backend/api/[name of project]/schema.graphql`:

```graphql
type RealEstateProperty @model @auth(rules: [{ allow: public }]) {
  id: ID!
  name: String!
  address: String
}
```

Save the schema and run `amplify push` to deploy the changes. For the purposes of this guide, we'll build a Real Estate Property listing application.

Next, in your application code, where you plan to render the real estate properties, add the required TanStack Query imports, and create a client:

```ts
import {
  useQuery,
  useMutation,
  useQueryClient,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/react-query'

// Create a client
const queryClient = new QueryClient()
```

Next, provide the client to your app:

```ts
<QueryClientProvider client={queryClient}>
  <App />
</QueryClientProvider>
```

Next, within your app, access the TanStack client:

```ts 
// Access the client
const queryClient = useQueryClient()
```

<Callout>

** DOCS LINKS **

For more details on TanStack Query, including requirements, supported browsers, and advanced usage, see the [TanStack Query documentation](https://tanstack.com/query/latest/docs/react/overview). 
For more on Amplify GraphQL API operations, see the [API documentation](https://docs.amplify.aws/lib/graphqlapi/getting-started/q/platform/js/).

</Callout>

<Callout>

**TODO: TanStack optimistic UI "gotchas". Determine placement of this callout.**

- Specifically around query keys and list vs single item behavior (i.e. implementing optimistic UI for a single item mutation will not behave as expected when the query is for a list of items)
- One of the things that was at first unclear to me was that the optimistic UI behavior changes based on what query key is used. So for instance, if I set my query key as “todos” when I retrieve a list of items, I can only use that query key for optimistically rendering a new item. If I were to use that key for updating an item, I'd see duplicate entries (a query key without an ID is used for optimistically rendering a create operation). Since updates usually happen in a “detail view” anyway, I've added a detail view to the sample where I query the single item, create a key for that item based on it's ID, and then I can perform updates using that query key to optimistically render the update, but not run into the issue of seeing duplicate entries. I'll link my sample app in a minute if you'd like to use the imported TanStack debugger for observing changes in the cache.

</Callout>

<Callout>

**COMPLETE EXAMPLE CALLOUT**

For the complete working example, including required imports, and React component state management, see the [Complete Example](#complete-example) below.

</Callout>

## Create a query with GraphQL API and TanStack Query

To create a query, use the `useQuery` hook, passing in the GraphQL API query (and variables). The following example creates a query to retrieve all records from the API.

```ts
// Queries
const query = useQuery({ queryKey: ['todos'], queryFn: getTodos })
```

## Create a mutation with GraphQL API and TanStack Query

<Callout>

See the [Documentation](https://tanstack.com/query/latest/docs/react/guides/optimistic-updates) for more information on optimistic updates.

</Callout>

To create a mutation, use the `useMutation` hook, passing in the GraphQL mutation (and variables). The following example creates a mutation to create a new record via the API.

```ts
// Mutations
const mutation = useMutation({
  mutationFn: postTodo,
  onSuccess: () => {
    // Invalidate and refetch
    queryClient.invalidateQueries({ queryKey: ['todos'] })
  },
})
```

## Update

## Delete

## Loading states, etc

TODO:

## Debugging optimistic UI

**NOTE: this could also be a callout**

To help visualize the inner workings of React Query, visit the [TanStack Query DevTools docs](https://tanstack.com/query/latest/docs/react/devtools) for more information.

## Complete examples

<BlockSwitcher>
<Block name="TypeScript">

```ts
import React, { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { useIsFetching } from "@tanstack/react-query";
import { API } from "aws-amplify";
import * as queries from "./graphql/queries";
import * as mutations from "./graphql/mutations";
import { GraphQLQuery } from "@aws-amplify/api";
import {
  CreateRealEstatePropertyInput,
  CreateRealEstatePropertyMutation,
  DeleteRealEstatePropertyInput,
  DeleteRealEstatePropertyMutation,
  GetRealEstatePropertyQuery,
  ListRealEstatePropertiesQuery,
  RealEstateProperty,
  UpdateRealEstatePropertyInput,
  UpdateRealEstatePropertyMutation,
} from "./API";

/**
 * https://www.tanstack.com/query/v4/docs/react/guides/background-fetching-indicators#displaying-global-background-fetching-loading-state
 * For the purposes of this demo, we show a global loading indicator when *any*
 * queries are fetching (including in the background) in order to help visualize
 * what TanStack is doing in the background. This example also displays
 * indicators for individual query and mutation loading states.
 */
function GlobalLoadingIndicator() {
  const isFetching = useIsFetching();

  return isFetching ? <div style={styles.globalLoadingIndicator}></div> : null;
}

function App() {
  const [currentRealEstatePropertyId, setCurrentRealEstatePropertyId] =
    useState<string | null>(null);

  // Access the client
  const queryClient = useQueryClient();

  // TanStack Query for listing all real estate properties:
  const {
    data: realEstateProperties,
    isLoading,
    isSuccess,
    isError: isErrorQuery,
  } = useQuery({
    queryKey: ["realEstateProperties"],
    // TODO: improve return type
    queryFn: async (): Promise<
      (RealEstateProperty | null | undefined)[] | null | undefined
    > => {
      const response = await API.graphql<
        GraphQLQuery<ListRealEstatePropertiesQuery>
      >({
        query: queries.listRealEstateProperties,
      });

      const allRealEstateProperties =
        response?.data?.listRealEstateProperties?.items;

      // TODO: figure out return type
      if (!allRealEstateProperties) return null;

      return allRealEstateProperties;
    },
  });

  // TanStack create mutation with optimistic updates
  const createMutation = useMutation({
    mutationFn: async (
      realEstatePropertyDetails: CreateRealEstatePropertyInput
    ): Promise<RealEstateProperty | undefined | null> => {
      const response = await API.graphql<
        GraphQLQuery<CreateRealEstatePropertyMutation>
      >({
        query: mutations.createRealEstateProperty,
        variables: { input: realEstatePropertyDetails },
      });

      const newRealEstateProperty = response?.data?.createRealEstateProperty;
      return newRealEstateProperty;
    },
    // When mutate is called:
    onMutate: async (newRealEstateProperty: CreateRealEstatePropertyInput) => {
      // Cancel any outgoing refetches
      // (so they don't overwrite our optimistic update)
      await queryClient.cancelQueries({ queryKey: ["realEstateProperties"] });

      // Snapshot the previous value
      const previousRealEstateProperties = queryClient.getQueryData<any>([
        "realEstateProperties",
      ]);

      // Optimistically update to the new value
      if (previousRealEstateProperties) {
        queryClient.setQueryData<any>(["realEstateProperties"], (old: any) => [
          ...old,
          newRealEstateProperty,
        ]);
      }

      // Return a context object with the snapshotted value
      return { previousRealEstateProperties };
    },
    // If the mutation fails,
    // use the context returned from onMutate to rollback
    onError: (err, newRealEstateProperty, context) => {
      console.error("Error saving record:", err, newRealEstateProperty);
      if (context?.previousRealEstateProperties) {
        queryClient.setQueryData<RealEstateProperty>(
          ["realEstateProperties"],
          context.previousRealEstateProperties
        );
      }
    },
    // Always refetch after error or success:
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ["realEstateProperties"] });
    },
  });

  /**
   * Note: this example does not return to the list view on delete in order
   * to demonstrate the optimistic update.
   */
  function RealEstatePropertyDetailView() {
    const {
      data: realEstateProperty,
      isLoading,
      isSuccess,
      isError: isErrorQuery,
    } = useQuery({
      queryKey: ["realEstateProperties", currentRealEstatePropertyId],
      // TODO: improve return type
      queryFn: async (): Promise<RealEstateProperty | null | undefined> => {
        const response = await API.graphql<
          GraphQLQuery<GetRealEstatePropertyQuery>
        >({
          query: queries.getRealEstateProperty,
          variables: { id: currentRealEstatePropertyId },
        });

        return response.data?.getRealEstateProperty;
      },
    });

    // TanStack update mutation with optimistic updates
    const updateMutation = useMutation({
      mutationFn: async (
        realEstatePropertyDetails: UpdateRealEstatePropertyInput
      ) => {
        const updatedRealEstateProperty = await API.graphql<
          GraphQLQuery<UpdateRealEstatePropertyMutation>
        >({
          query: mutations.updateRealEstateProperty,
          variables: { input: realEstatePropertyDetails },
        });

        return updatedRealEstateProperty;
      },
      // When mutate is called:
      onMutate: async (
        newRealEstateProperty: UpdateRealEstatePropertyInput
      ) => {
        // Cancel any outgoing refetches
        // (so they don't overwrite our optimistic update)
        await queryClient.cancelQueries({
          queryKey: ["realEstateProperties", newRealEstateProperty.id],
        });

        // Snapshot the previous value
        const previousRealEstateProperty =
          queryClient.getQueryData<RealEstateProperty>([
            "realEstateProperties",
            newRealEstateProperty.id,
          ]);

        // Optimistically update to the new value
        if (previousRealEstateProperty) {
          queryClient.setQueryData(
            ["realEstateProperties", newRealEstateProperty.id],
            // TODO: add docs for this.
            // Not covered in the TanStack docs, but the new property only
            // includes updated values the first two times it returns. The final
            // return includes all fields.
            { ...previousRealEstateProperty, ...newRealEstateProperty }
          );
        }

        // Return a context with the previous and new realEstateProperty
        return { previousRealEstateProperty, newRealEstateProperty };
      },
      // If the mutation fails, use the context we returned above
      onError: (err, newRealEstateProperty, context) => {
        console.error("Error updating record:", err, newRealEstateProperty);
        if (context?.previousRealEstateProperty) {
          queryClient.setQueryData<RealEstateProperty>(
            ["realEstateProperties", context.newRealEstateProperty.id],
            context.previousRealEstateProperty
          );
        }
      },
      // Always refetch after error or success:
      onSettled: (newRealEstateProperty) => {
        queryClient.invalidateQueries({
          // TODO: fix type
          // @ts-ignore
          queryKey: ["realEstateProperties", newRealEstateProperty.id],
        });
      },
    });

    // TanStack delete mutation with optimistic updates
    const deleteMutation = useMutation({
      mutationFn: async (
        realEstatePropertyDetails: DeleteRealEstatePropertyInput
      ) => {
        const deletedRealEstateProperty = await API.graphql<
          GraphQLQuery<DeleteRealEstatePropertyMutation>
        >({
          query: mutations.deleteRealEstateProperty,
          variables: { input: realEstatePropertyDetails },
        });

        return deletedRealEstateProperty;
      },
      // When mutate is called:
      onMutate: async (
        newRealEstateProperty: DeleteRealEstatePropertyInput
      ) => {
        // Cancel any outgoing refetches
        // (so they don't overwrite our optimistic update)
        await queryClient.cancelQueries({
          queryKey: ["realEstateProperties", newRealEstateProperty.id],
        });

        // Snapshot the previous value
        const previousRealEstateProperty =
          queryClient.getQueryData<RealEstateProperty>([
            "realEstateProperties",
            newRealEstateProperty.id,
          ]);

        // Optimistically update to the new value
        if (previousRealEstateProperty) {
          queryClient.setQueryData<DeleteRealEstatePropertyInput>(
            ["realEstateProperties", newRealEstateProperty.id],
            newRealEstateProperty
          );
        }

        // Return a context with the previous and new realEstateProperty
        return { previousRealEstateProperty, newRealEstateProperty };
      },
      // If the mutation fails, use the context we returned above
      onError: (err, newRealEstateProperty, context) => {
        console.error("Error deleting record:", err, newRealEstateProperty);
        if (context?.previousRealEstateProperty) {
          queryClient.setQueryData<RealEstateProperty>(
            ["realEstateProperties", context.newRealEstateProperty.id],
            context.previousRealEstateProperty
          );
        }
      },
      // Always refetch after error or success:
      onSettled: (newRealEstateProperty) => {
        queryClient.invalidateQueries({
          // TODO: fix type
          // @ts-ignore
          queryKey: ["realEstateProperties", newRealEstateProperty.id],
        });
      },
    });

    return (
      <div style={styles.detailViewContainer}>
        <h2>Real Estate Property Detail View</h2>
        {isErrorQuery && <div>{"Problem loading Real Estate Property"}</div>}
        {isLoading && (
          <div style={styles.loadingIndicator}>
            {"Loading Real Estate Property..."}
          </div>
        )}
        {isSuccess && (
          <div>
            <p>{`Name: ${realEstateProperty?.name}`}</p>
            <p>{`Address: ${realEstateProperty?.address}`}</p>
          </div>
        )}
        {realEstateProperty && (
          <div>
            <button
              onClick={() =>
                updateMutation.mutate({
                  id: realEstateProperty.id,
                  name: `Updated Home ${Date.now()}`,
                })
              }
            >
              Update Name
            </button>
            <button
              onClick={() =>
                updateMutation.mutate({
                  id: realEstateProperty.id,
                  address: `${Math.floor(1000 + Math.random() * 9000)} Main St`,
                })
              }
            >
              Update Address
            </button>
            <button
              onClick={() =>
                deleteMutation.mutate({
                  id: realEstateProperty.id,
                })
              }
            >
              Delete
            </button>
          </div>
        )}
        <button onClick={() => setCurrentRealEstatePropertyId(null)}>
          Back
        </button>
      </div>
    );
  }

  // NOTE: For test / sample cleanup purposes only (not for docs example)
  async function deleteAll() {
    //region: delete realEstateProperties:
    const response = await API.graphql<
      GraphQLQuery<ListRealEstatePropertiesQuery>
    >({
      query: queries.listRealEstateProperties,
    });

    console.log(
      "RealEstateProperties to delete",
      response?.data?.listRealEstateProperties?.items
    );

    await response?.data?.listRealEstateProperties?.items.forEach(
      async (realEstateProperty) => {
        if (!realEstateProperty?.id) return;

        const realEstatePropertyDetails: DeleteRealEstatePropertyInput = {
          id: realEstateProperty?.id,
        };

        const deletedRealEstateProperty = await API.graphql<
          GraphQLQuery<DeleteRealEstatePropertyMutation>
        >({
          query: mutations.deleteRealEstateProperty,
          variables: { input: realEstatePropertyDetails },
        });

        console.log("RealEstateProperty deleted: ", deletedRealEstateProperty);
      }
    );
    //endregion

    //region verify all deletes were successful:
    const secondResponse = await API.graphql<
      GraphQLQuery<ListRealEstatePropertiesQuery>
    >({
      query: queries.listRealEstateProperties,
    });
    console.log(
      "RealEstateProperties should be empty:",
      secondResponse?.data?.listRealEstateProperties?.items
    );

    if (secondResponse?.data?.listRealEstateProperties?.items?.length === 0) {
      console.log("All deletes successful!");
    }
    //endregion
  }

  return (
    <div>
      {!currentRealEstatePropertyId && (
        <div style={styles.appContainer}>
          <h1>Real Estate Properties:</h1>
          <button
            onClick={() => {
              createMutation.mutate({
                name: `New Home ${Date.now()}`,
                address: `${Math.floor(1000 + Math.random() * 9000)} Main St`,
              });
            }}
          >
            Add RealEstateProperty
          </button>
          <button onClick={deleteAll}>Delete All</button>
          <ul style={styles.propertiesList}>
            {isLoading && (
              <div style={styles.loadingIndicator}>
                {"Loading Real Estate Properties..."}
              </div>
            )}
            {isErrorQuery && (
              <div>{"Problem loading Real Estate Properties"}</div>
            )}
            {isSuccess &&
              realEstateProperties?.map((realEstateProperty, idx) => {
                if (!realEstateProperty) return null;
                return (
                  <li
                    style={styles.listItem}
                    key={`${idx}-${realEstateProperty.id}`}
                  >
                    <p>{realEstateProperty.name}</p>
                    <button
                      style={styles.detailViewButton}
                      onClick={() =>
                        setCurrentRealEstatePropertyId(realEstateProperty.id)
                      }
                    >
                      Detail View
                    </button>
                  </li>
                );
              })}
          </ul>
        </div>
      )}
      {currentRealEstatePropertyId && <RealEstatePropertyDetailView />}
      <GlobalLoadingIndicator />
    </div>
  );
}

export default App;

const styles: any = {
  appContainer: {
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
  },
  detailViewButton: { marginLeft: "1rem" },
  detailViewContainer: { border: "1px solid black", padding: "3rem" },
  globalLoadingIndicator: {
    position: "fixed",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "4px solid blue",
    pointerEvents: "none",
  },
  listItem: {
    display: "flex",
    justifyContent: "space-between",
    border: "1px dotted grey",
    padding: ".5rem",
    margin: ".1rem",
  },
  loadingIndicator: {
    border: "1px solid black",
    padding: "1rem",
    margin: "1rem",
  },
  propertiesList: {
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "start",
    width: "50%",
    border: "1px solid black",
    padding: "1rem",
    listStyleType: "none",
  },
};
``` 

</Block>
<Block name="JavaScript">

```js
// TODO
```

</Block>

</BlockSwitcher>