The Storage and GraphQL API categories can be used together to associate a file, such as an image or video, with a particular record. For example, you might create a `User` model with a profile picture, or a `Post` model with an associated image. With Amplify's GraphQL API and Storage categories, you can reference the file within the model itself to create an association.

To get started, run the following in an existing Amplify project:

```bash
# For Authenticator component:
npm i @aws-amplify/ui-react

# Select default configuration:
amplify add auth             

# Select "Content", "Auth users only", full CRUD access,
# and default configuration:
amplify add storage          

#Select default configuration
amplify add api              
```

When prompted, use the following schema, which can also be found under `amplify/backend/api/[name of project]/schema.graphql`:

```graphql
type Song @model @auth(rules: [{ allow: public}]) {
  id: ID!
  name: String!
  coverArtKey: String #Set as optional to allow adding file after initial create
}
```

Save the schema and run `amplify push` to deploy the changes.

To use files and attachments your application needs authorization credentials for reading and writing to Amazon S3. This is configured in the `amplify add auth` step.

<Callout>

The Storage and API categories govern data access based on their own authorization patterns. Adding an `@auth` directive to the API schema does not guard against access in the Storage category. When you run `amplify add storage`, the CLI will configure appropriate IAM policies on the bucket using a Cognito Identity Pool role. You will then have the option of adding CRUD (Create, Update, Read and Delete) based permissions as well, so that Authenticated and Guest users will be granted limited permissions within these levels. For more on configuring Storage authorization levels, see the [Storage documentation](https://docs.amplify.aws/lib/storage/configureaccess/q/platform/js/).

</Callout>

For more on configuring API authorization (separate from Storage authorization), see the [API documentation](https://docs.amplify.aws/lib/graphqlapi/authz/q/platform/js/).

<Callout>

For the complete working example, including required imports, obtaining the file from the user, and React component state management, see the [Complete Example](#complete-example) below.

</Callout>

## Create a record with an associated file

First create a record via the GraphQL API, then upload the file to Storage, and finally add the association between the record and file. Use the following example with the GraphQL API and Storage categories to create a record and associate the file with the record.

<Callout>

The API record's `id` is prepended to the Storage file name to ensure uniqueness. If this is excluded, multiple API records could then be associated with the same file key unintentionally.

</Callout>

<BlockSwitcher>
<Block name="TypeScript">

```ts
const createSongDetails: CreateSongInput = {
  name: `My first song`,
};

// Create the API record:
const response = await API.graphql<GraphQLQuery<CreateSongMutation>>({
  query: mutations.createSong,
  variables: { input: createSongDetails },
});

const song = response?.data?.createSong;

if (!song) return;

// Upload the Storage file:
const result = await Storage.put(`${song.id}-${file.name}`, file, {
  contentType: "image/png", // contentType is optional
});

const updateSongDetails: UpdateSongInput = {
  id: song.id,
  coverArtKey: result?.key,
};

// Add the file association to the record:
const updateResponse = await API.graphql<
  GraphQLQuery<UpdateSongMutation>
>({
  query: mutations.updateSong,
  variables: { input: updateSongDetails },
});

const updatedSong = updateResponse?.data?.updateSong;

// Ensure that the record has an associated image:
if (!updatedSong?.coverArtKey) return;

// Retrieve the signed URL:
const signedURL = await Storage.get(updatedSong.coverArtKey);
``` 

</Block>
<Block name="JavaScript">

```js
const createSongDetails: CreateSongInput = {
  name: `My first song`,
};

// Create the API record:
const response = await API.graphql({
  query: mutations.createSong,
  variables: { input: createSongDetails },
});

const song = response?.data?.createSong;

if (!song) return;

// Upload the Storage file:
const result = await Storage.put(`${song.id}-${file.name}`, file, {
  contentType: "image/png", // contentType is optional
});

const updateSongDetails = {
  id: song.id,
  coverArtKey: result?.key,
};

// Add the file association to the record:
const updateResponse = await API.graphql<
  GraphQLQuery<UpdateSongMutation>
>({
  query: mutations.updateSong,
  variables: { input: updateSongDetails },
});

const updatedSong = updateResponse?.data?.updateSong;

// Ensure that the record has an associated image:
if (!updatedSong?.coverArtKey) return;

// Retrieve the signed URL:
const signedURL = await Storage.get(updatedSong.coverArtKey);
```

</Block>
</BlockSwitcher>

## Add or update a file for an associated record

To associate a file with a record, update the record with the key returned by the Storage upload. The following example uploads the file using Storage, updates the record with the file's key, then retrieves the signed URL to download the image. If an image is already associated with the record, this will update the record with the new image.

<BlockSwitcher>
<Block name="TypeScript">

```ts
// Upload the Storage file:
const result = await Storage.put(`${currentSong.id}-${file.name}`, file, {
  contentType: "image/png", // contentType is optional
});

const updateSongDetails: UpdateSongInput = {
  id: currentSong.id,
  coverArtKey: result?.key,
};

// Add the file association to the record:
const response = await API.graphql<GraphQLQuery<UpdateSongMutation>>({
  query: mutations.updateSong,
  variables: { input: updateSongDetails },
});

const updatedSong = response?.data?.updateSong;

// Ensure that the record has an associated image:
if (!updatedSong?.coverArtKey) return;

// Retrieve the file's signed URL:
const signedURL = await Storage.get(updatedSong.coverArtKey);
``` 

</Block>
<Block name="JavaScript">

```js
// Upload the Storage file:
const result = await Storage.put(`${currentSong.id}-${file.name}`, file, {
  contentType: "image/png", // contentType is optional
});

const updateSongDetails = {
  id: currentSong.id,
  coverArtKey: result?.key,
};

// Add the file association to the record:
const response = await API.graphql({
  query: mutations.updateSong,
  variables: { input: updateSongDetails },
});

const updatedSong = response?.data?.updateSong;

// Ensure that the record has an associated image:
if (!updatedSong?.coverArtKey) return;

// Retrieve the file's signed URL:
const signedURL = await Storage.get(updatedSong.coverArtKey);
```

</Block>
</BlockSwitcher>

## Query a record and retrieve the associated file

To retrieve the file associated with a record, first query the record, then use Storage to get the signed URL. The signed URL can then be used to download the file, display an image, etc:

<BlockSwitcher>
<Block name="TypeScript">

```ts
// Query the record to get the file key:
const response = await API.graphql<GraphQLQuery<GetSongQuery>>({
    query: queries.getSong,
    variables: { id: currentSong.id },
  });
const song = response.data?.getSong;

// Ensure that the record has an associated image:
if (!song?.coverArtKey) return;

// Retrieve the signed URL:
const signedURL = await Storage.get(song.coverArtKey);
``` 

</Block>
<Block name="JavaScript">

```js
// Query the record to get the file key:
const response = await API.graphql({
    query: queries.getSong,
    variables: { id: currentSong.id },
  });
const song = response.data?.getSong;

// Ensure that the record has an associated image:
if (!song?.coverArtKey) return;

// Retrieve the signed URL:
const signedURL = await Storage.get(song.coverArtKey);
```

</Block>
</BlockSwitcher>

## Delete and remove files associated with API records
There are three common deletion workflows when working with Storage files and the GraphQL API:

1. Remove the file association, continue to persist both file and record.
2. Remove the record association and delete the file.
2. Delete both file and record.

### Remove the file association, continue to persist both file and record

The following example removes the file association from the record, but does not delete the file from S3, nor the record from the database.

<BlockSwitcher>
<Block name="TypeScript">

```ts
const response = await API.graphql<GraphQLQuery<GetSongQuery>>({
    query: queries.getSong,
    variables: { id: currentSong.id },
  });

const song = response?.data?.getSong;

// Ensure that the record has an associated image:
if (!song?.coverArtKey) return;

const songDetails: UpdateSongInput = {
  id: song.id,
  coverArtKey: null,
};

const updatedSong = await API.graphql<GraphQLQuery<UpdateSongMutation>>({
  query: mutations.updateSong,
  variables: { input: songDetails },
});
``` 

</Block>
<Block name="JavaScript">

```js
const response = await API.graphql({
    query: queries.getSong,
    variables: { id: currentSong.id },
  });

const song = response?.data?.getSong;

// Ensure that the record has an associated image:
if (!song?.coverArtKey) return;

const songDetails = {
  id: song.id,
  coverArtKey: null,
};

const updatedSong = await API.graphql({
  query: mutations.updateSong,
  variables: { input: songDetails },
});
```

</Block>
</BlockSwitcher>

### Remove the record association and delete the file

The following example removes the file from the record, then deletes the file from S3:

<BlockSwitcher>
<Block name="TypeScript">

```ts
const response = await API.graphql<GraphQLQuery<GetSongQuery>>({
  query: queries.getSong,
  variables: { id: currentSong.id },
});

const song = response?.data?.getSong;

// Ensure that the record has an associated image:
if (!song?.coverArtKey) return;

const songDetails: UpdateSongInput = {
  id: song.id,
  coverArtKey: null, // Set the file association to `null`
};

// Remove associated file from record
const updatedSong = await API.graphql<GraphQLQuery<UpdateSongMutation>>({
  query: mutations.updateSong,
  variables: { input: songDetails },
});

// Delete the file from S3:
await Storage.remove(song.coverArtKey);
``` 

</Block>
<Block name="JavaScript">

```js
const response = await API.graphql({
  query: queries.getSong,
  variables: { id: currentSong.id },
});

const song = response?.data?.getSong;

// Ensure that the record has an associated image:
if (!song?.coverArtKey) return;

const songDetails: UpdateSongInput = {
  id: song.id,
  coverArtKey: null, // Set the file association to `null`
};

// Remove associated file from record
const updatedSong = await API.graphql({
  query: mutations.updateSong,
  variables: { input: songDetails },
});

// Delete the file from S3:
await Storage.remove(song.coverArtKey);
```

</Block>
</BlockSwitcher>

### Delete both file and record

<BlockSwitcher>
<Block name="TypeScript">

```ts
const response = await API.graphql<GraphQLQuery<GetSongQuery>>({
    query: queries.getSong,
    variables: { id: currentSong.id },
  });

const song = response?.data?.getSong;

// Ensure that the record has an associated image:
if (!song?.coverArtKey) return;

await Storage.remove(song.coverArtKey);

const songDetails: DeleteSongInput = {
  id: song.id,
};

const deletedSong = await API.graphql<GraphQLQuery<DeleteSongMutation>>({
  query: mutations.deleteSong,
  variables: { input: songDetails },
});
``` 

</Block>
<Block name="JavaScript">

```js
const response = await API.graphql({
    query: queries.getSong,
    variables: { id: currentSong.id },
  });

const song = response?.data?.getSong;

// Ensure that the record has an associated image:
if (!song?.coverArtKey) return;

await Storage.remove(song.coverArtKey);

const songDetails = {
  id: song.id,
};

const deletedSong = await API.graphql({
  query: mutations.deleteSong,
  variables: { input: songDetails },
});
```

</Block>
</BlockSwitcher>

## Working with multiple files:

You may want to add multiple files to a single record, such as a user profile with multiple images. 
To do this, you can add a list of file keys to the record. The following example adds a list of file keys to a record:

### Schema

When prompted after running `amplify add api` use the following schema, which can also be found under `amplify/backend/api/[name of project]/schema.graphql`:

```graphql
type PhotoAlbum @model @auth(rules: [{ allow: public }]) {
  id: ID!
  name: String!
  imageKeys: [String] #Set as optional to allow adding file(s) after initial create
}
```

CRUD operations when working with multiple files is the same as when working with a single file, with the exception that we are now working with a list of image keys, as opposed to a single image key.

### Create a record with multiple associated files

First create a record via the GraphQL API, then upload the files to Storage, and finally add the associations between the record and files.

<BlockSwitcher>
<Block name="TypeScript">

```ts
// Upload all files to Storage:
const imageKeys = await Promise.all(
  Array.from(e.target.files).map(async (file) => {
    const result = await Storage.put(file.name, file, {
      contentType: "image/png", // contentType is optional
    });

    return result?.key;
  })
);

const photoAlbumDetails: CreatePhotoAlbumInput = {
  name: `My first photoAlbum`,
  imageKeys,
};

// Create album with associated files:
const response = await API.graphql<
  GraphQLQuery<CreatePhotoAlbumMutation>
>({
  query: mutations.createPhotoAlbum,
  variables: { input: photoAlbumDetails },
});

const photoAlbum = response?.data?.createPhotoAlbum;

if (!photoAlbum?.imageKeys) return;

// Retrieve signed urls for all files:
const signedUrls = await Promise.all(
  photoAlbum?.imageKeys.map(async (key) => await Storage.get(key!))
);
``` 

</Block>
<Block name="JavaScript">

```js
// Upload all files to Storage:
const imageKeys = await Promise.all(
  Array.from(e.target.files).map(async (file) => {
    const result = await Storage.put(file.name, file, {
      contentType: "image/png", // contentType is optional
    });

    return result?.key;
  })
);

const photoAlbumDetails = {
  name: `My first photoAlbum`,
  imageKeys,
};

// Create album with associated files:
const response = await API.graphql({
  query: mutations.createPhotoAlbum,
  variables: { input: photoAlbumDetails },
});

const photoAlbum = response?.data?.createPhotoAlbum;

if (!photoAlbum?.imageKeys) return;

// Retrieve signed urls for all files:
const signedUrls = await Promise.all(
  photoAlbum?.imageKeys.map(async (key) => await Storage.get(key))
);
```

</Block>
</BlockSwitcher>

### Create a record with a single associated file

When a schema allows for multiple associated images, you can still create a record with a single associated file.

<BlockSwitcher>
<Block name="TypeScript">

```ts
const result = await Storage.put(file.name, file, {
  contentType: "image/png", // contentType is optional
});

const photoAlbumDetails: CreatePhotoAlbumInput = {
  name: `My first photoAlbum`,
  imageKeys: [result?.key],
};

const response = await API.graphql<
  GraphQLQuery<CreatePhotoAlbumMutation>
>({
  query: mutations.createPhotoAlbum,
  variables: { input: photoAlbumDetails },
});

const photoAlbum = response?.data?.createPhotoAlbum;

if (!photoAlbum?.imageKeys?.length) return;

const signedURL = await Storage.get(photoAlbum.imageKeys[0]!);
``` 

</Block>
<Block name="JavaScript">

```js
const result = await Storage.put(file.name, file, {
  contentType: "image/png", // contentType is optional
});

const photoAlbumDetails = {
  name: `My first photoAlbum`,
  imageKeys: [result?.key],
};

const response = await API.graphql({
  query: mutations.createPhotoAlbum,
  variables: { input: photoAlbumDetails },
});

const photoAlbum = response?.data?.createPhotoAlbum;

if (!photoAlbum?.imageKeys?.length) return;

const signedURL = await Storage.get(photoAlbum.imageKeys[0]);
```

</Block>
</BlockSwitcher>

### Add new files to an associated record

To associate additional files with a record, update the record with the keys returned by the Storage uploads.

<BlockSwitcher>
<Block name="TypeScript">

```ts
// Upload all files to Storage:
const newImageKeys = await Promise.all(
  Array.from(e.target.files).map(async (file) => {
    const result = await Storage.put(file.name, file, {
      contentType: "image/png", // contentType is optional
    });

    return result?.key;
  })
);

// Query existing record to retrieve currently associated files:
const queriedResponse = await API.graphql<
  GraphQLQuery<GetPhotoAlbumQuery>
>({
  query: queries.getPhotoAlbum,
  variables: { id: currentPhotoAlbum.id },
});

const photoAlbum = queriedResponse.data?.getPhotoAlbum;

if (!photoAlbum?.imageKeys) return;

// Merge existing and new file keys:
const updatedImageKeys = [...newImageKeys, ...photoAlbum.imageKeys];

const photoAlbumDetails: UpdatePhotoAlbumInput = {
  id: currentPhotoAlbum.id,
  imageKeys: updatedImageKeys,
};

// Update record with merged file associations:
const response = await API.graphql<
  GraphQLQuery<UpdatePhotoAlbumMutation>
>({
  query: mutations.updatePhotoAlbum,
  variables: { input: photoAlbumDetails },
});

const updatedPhotoAlbum = response?.data?.updatePhotoAlbum;

// Ensure that the record has an associated image:
if (!updatedPhotoAlbum?.imageKeys) return;

// Retrieve signed urls for merged image keys:
const signedUrls = await Promise.all(
  updatedPhotoAlbum?.imageKeys.map(async (key) => await Storage.get(key!))
);
``` 

</Block>
<Block name="JavaScript">

```js
// Upload all files to Storage:
const newImageKeys = await Promise.all(
  Array.from(e.target.files).map(async (file) => {
    const result = await Storage.put(file.name, file, {
      contentType: "image/png", // contentType is optional
    });

    return result?.key;
  })
);

// Query existing record to retrieve currently associated files:
const queriedResponse = await API.graphql({
  query: queries.getPhotoAlbum,
  variables: { id: currentPhotoAlbum.id },
});

const photoAlbum = queriedResponse.data?.getPhotoAlbum;

if (!photoAlbum?.imageKeys) return;

// Merge existing and new file keys:
const updatedImageKeys = [...newImageKeys, ...photoAlbum.imageKeys];

const photoAlbumDetails = {
  id: currentPhotoAlbum.id,
  imageKeys: updatedImageKeys,
};

// Update record with merged file associations:
const response = await API.graphql({
  query: mutations.updatePhotoAlbum,
  variables: { input: photoAlbumDetails },
});

const updatedPhotoAlbum = response?.data?.updatePhotoAlbum;

// Ensure that the record has an associated image:
if (!updatedPhotoAlbum?.imageKeys) return;

// Retrieve signed urls for merged image keys:
const signedUrls = await Promise.all(
  updatedPhotoAlbum?.imageKeys.map(async (key) => await Storage.get(key))
);
```

</Block>
</BlockSwitcher>

### Update file for an associated record

Updating a file for an associated record is the same as updating a file for a single file record, with the exception that you will need to update the list of file keys.

<BlockSwitcher>
<Block name="TypeScript">

```ts
// TODO
``` 

</Block>
<Block name="JavaScript">

```js
// TODO
```

</Block>
</BlockSwitcher>

### Query a record and retrieve the associated files

To retrieve the files associated with a record, first query the record, then use Storage to retrieve all of the signed URLs.

<BlockSwitcher>
<Block name="TypeScript">

```ts
// Query the record to get the file keys:
const response = await API.graphql<GraphQLQuery<GetPhotoAlbumQuery>>({
  query: queries.getPhotoAlbum,
  variables: { id: currentPhotoAlbum.id },
});
const photoAlbum = response.data?.getPhotoAlbum;

// Ensure that the record has associated images:
if (!photoAlbum?.imageKeys) return;

// Retrieve the signed URLs for the associated images:
const signedUrls = await Promise.all(
  photoAlbum.imageKeys.map(async (imageKey) => {
    if (!imageKey) return;
    return await Storage.get(imageKey);
  })
);
``` 

</Block>
<Block name="JavaScript">

```js
// Query the record to get the file keys:
const response = await API.graphql({
  query: queries.getPhotoAlbum,
  variables: { id: currentPhotoAlbum.id },
});
const photoAlbum = response.data?.getPhotoAlbum;

// Ensure that the record has associated images:
if (!photoAlbum?.imageKeys) return;

// Retrieve the signed URLs for the associated images:
const signedUrls = await Promise.all(
  photoAlbum.imageKeys.map(async (imageKey) => {
    if (!imageKey) return;
    return await Storage.get(imageKey);
  })
);
```

</Block>
</BlockSwitcher>

### Delete and remove files associated with API records

The workflow for deleting and removing files associated with API records is the same as when working with a single file, except that when performing a delete you will need to iterate over the list of files keys and call `Storage.remove()` for each file.

#### Remove the file association, continue to persist both files and record

<BlockSwitcher>
<Block name="TypeScript">

```ts
const response = await API.graphql<GraphQLQuery<GetPhotoAlbumQuery>>({
  query: queries.getPhotoAlbum,
  variables: { id: currentPhotoAlbum.id },
});

const photoAlbum = response?.data?.getPhotoAlbum;

// Ensure that the record has an associated image:
if (!photoAlbum?.imageKeys) return;

const photoAlbumDetails: UpdatePhotoAlbumInput = {
  id: photoAlbum.id,
  imageKeys: null,
};

const updatedPhotoAlbum = await API.graphql<
  GraphQLQuery<UpdatePhotoAlbumMutation>
>({
  query: mutations.updatePhotoAlbum,
  variables: { input: photoAlbumDetails },
});
``` 

</Block>
<Block name="JavaScript">

```js
const response = await API.graphql({
  query: queries.getPhotoAlbum,
  variables: { id: currentPhotoAlbum.id },
});

const photoAlbum = response?.data?.getPhotoAlbum;

// Ensure that the record has an associated image:
if (!photoAlbum?.imageKeys) return;

const photoAlbumDetails = {
  id: photoAlbum.id,
  imageKeys: null,
};

const updatedPhotoAlbum = await API.graphql({
  query: mutations.updatePhotoAlbum,
  variables: { input: photoAlbumDetails },
});
```

</Block>
</BlockSwitcher>

#### Remove the record association and delete the files

<BlockSwitcher>
<Block name="TypeScript">

```ts
const response = await API.graphql<GraphQLQuery<GetPhotoAlbumQuery>>({
  query: queries.getPhotoAlbum,
  variables: { id: currentPhotoAlbum.id },
});

const photoAlbum = response?.data?.getPhotoAlbum;

// Ensure that the record has an associated images:
if (!photoAlbum?.imageKeys) return;

const photoAlbumDetails: UpdatePhotoAlbumInput = {
  id: photoAlbum.id,
  imageKeys: null, // Set the file association to `null`
};

// Remove associated files from record
const updatedPhotoAlbum = await API.graphql<
  GraphQLQuery<UpdatePhotoAlbumMutation>
>({
  query: mutations.updatePhotoAlbum,
  variables: { input: photoAlbumDetails },
});

// Delete the files from S3:
await Promise.all(
  photoAlbum?.imageKeys.map(async (imageKey) => {
    if (!imageKey) return;
    await Storage.remove(imageKey);
  })
);
``` 

</Block>
<Block name="JavaScript">

```js
const response = await API.graphql({
  query: queries.getPhotoAlbum,
  variables: { id: currentPhotoAlbum.id },
});

const photoAlbum = response?.data?.getPhotoAlbum;

// Ensure that the record has an associated images:
if (!photoAlbum?.imageKeys) return;

const photoAlbumDetails = {
  id: photoAlbum.id,
  imageKeys: null, // Set the file association to `null`
};

// Remove associated files from record
const updatedPhotoAlbum = await API.graphql({
  query: mutations.updatePhotoAlbum,
  variables: { input: photoAlbumDetails },
});

// Delete the files from S3:
await Promise.all(
  photoAlbum?.imageKeys.map(async (imageKey) => {
    if (!imageKey) return;
    await Storage.remove(imageKey);
  })
);
```

</Block>
</BlockSwitcher>

#### Delete record and all associated files

<BlockSwitcher>
<Block name="TypeScript">

```ts
const response = await API.graphql<GraphQLQuery<GetPhotoAlbumQuery>>({
  query: queries.getPhotoAlbum,
  variables: { id: currentPhotoAlbum.id },
});

const photoAlbum = response?.data?.getPhotoAlbum;

// Ensure that the record has an associated image:
if (!photoAlbum?.imageKeys) return;

await Promise.all(
  photoAlbum?.imageKeys.map(async (imageKey) => {
    if (!imageKey) return;
    await Storage.remove(imageKey);
  })
);

const photoAlbumDetails: DeletePhotoAlbumInput = {
  id: photoAlbum.id,
};

await API.graphql<GraphQLQuery<DeletePhotoAlbumMutation>>({
  query: mutations.deletePhotoAlbum,
  variables: { input: photoAlbumDetails },
});
``` 

</Block>
<Block name="JavaScript">

```js
const response = await API.graphql({
  query: queries.getPhotoAlbum,
  variables: { id: currentPhotoAlbum.id },
});

const photoAlbum = response?.data?.getPhotoAlbum;

// Ensure that the record has an associated image:
if (!photoAlbum?.imageKeys) return;

await Promise.all(
  photoAlbum?.imageKeys.map(async (imageKey) => {
    if (!imageKey) return;
    await Storage.remove(imageKey);
  })
);

const photoAlbumDetails = {
  id: photoAlbum.id,
};

await API.graphql({
  query: mutations.deletePhotoAlbum,
  variables: { input: photoAlbumDetails },
});
```

</Block>
</BlockSwitcher>

## Complete Examples:

<BlockSwitcher>
<Block name="Single File (TS)">

```ts
import { useState } from "react";
import { API, Storage } from "aws-amplify";
import { Authenticator } from "@aws-amplify/ui-react";
import "@aws-amplify/ui-react/styles.css";
import { GraphQLQuery } from "@aws-amplify/api";
import * as queries from "./graphql/queries";
import * as mutations from "./graphql/mutations";
import {
  CreateSongInput,
  CreateSongMutation,
  DeleteSongInput,
  DeleteSongMutation,
  GetSongQuery,
  UpdateSongInput,
  UpdateSongMutation,
} from "./API";

function App() {
  const [currentSong, setCurrentSong] = useState<any>();

  // Used to display image for current song:
  const [currentImageUrl, setCurrentImageUrl] = useState<
    string | null | undefined
  >("");

  async function createSongWithImage(e: React.ChangeEvent<HTMLInputElement>) {
    if (!e.target.files) return;

    const file = e.target.files[0];

    try {
      const createSongDetails: CreateSongInput = {
        name: `My first song`,
      };

      // Create the API record:
      const response = await API.graphql<GraphQLQuery<CreateSongMutation>>({
        query: mutations.createSong,
        variables: { input: createSongDetails },
      });

      const song = response?.data?.createSong;

      if (!song) return;

      // Upload the Storage file:
      const result = await Storage.put(`${song.id}-${file.name}`, file, {
        contentType: "image/png", // contentType is optional
      });

      const updateSongDetails: UpdateSongInput = {
        id: song.id,
        coverArtKey: result?.key,
      };

      // Add the file association to the record:
      const updateResponse = await API.graphql<
        GraphQLQuery<UpdateSongMutation>
      >({
        query: mutations.updateSong,
        variables: { input: updateSongDetails },
      });

      const updatedSong = updateResponse?.data?.updateSong;

      setCurrentSong(updatedSong);

      // Ensure that the record has an associated image:
      if (!updatedSong?.coverArtKey) return;

      // Retrieve the file's signed URL:
      const signedURL = await Storage.get(updatedSong.coverArtKey);
      setCurrentImageUrl(signedURL);
    } catch (error) {
      console.error("Error create song / file:", error);
    }
  }

  // Upload image, add to song, retrieve signed URL and retrieve the image.
  // Also updates image if one already exists.
  async function addNewImageToSong(e: React.ChangeEvent<HTMLInputElement>) {
    if (!currentSong) return;

    if (!e.target.files) return;

    const file = e.target.files[0];

    try {
      // Upload the Storage file:
      const result = await Storage.put(`${currentSong.id}-${file.name}`, file, {
        contentType: "image/png", // contentType is optional
      });

      const updateSongDetails: UpdateSongInput = {
        id: currentSong.id,
        coverArtKey: result?.key,
      };

      // Add the file association to the record:
      const response = await API.graphql<GraphQLQuery<UpdateSongMutation>>({
        query: mutations.updateSong,
        variables: { input: updateSongDetails },
      });

      const updatedSong = response?.data?.updateSong;

      setCurrentSong(updatedSong);

      // Ensure that the record has an associated image:
      if (!updatedSong?.coverArtKey) return;

      // Retrieve the file's signed URL:
      const signedURL = await Storage.get(updatedSong.coverArtKey);
      setCurrentImageUrl(signedURL);
    } catch (error) {
      console.error("Error uploading image / adding image to song: ", error);
    }
  }

  async function getImageForCurrentSong() {
    try {
      // Query the record to get the file key:
      const response = await API.graphql<GraphQLQuery<GetSongQuery>>({
        query: queries.getSong,
        variables: { id: currentSong.id },
      });
      const song = response.data?.getSong;

      // Ensure that the record has an associated image:
      if (!song?.coverArtKey) return;

      // Retrieve the signed URL:
      const signedURL = await Storage.get(song.coverArtKey);

      setCurrentImageUrl(signedURL);
    } catch (error) {
      console.error("Error getting song / image:", error);
    }
  }

  // Remove the file association, continue to persist both file and record
  async function removeImageFromSong() {
    if (!currentSong) return;

    try {
      const response = await API.graphql<GraphQLQuery<GetSongQuery>>({
        query: queries.getSong,
        variables: { id: currentSong.id },
      });

      const song = response?.data?.getSong;

      // Ensure that the record has an associated image:
      if (!song?.coverArtKey) return;

      const songDetails: UpdateSongInput = {
        id: song.id,
        coverArtKey: null,
      };

      const updatedSong = await API.graphql<GraphQLQuery<UpdateSongMutation>>({
        query: mutations.updateSong,
        variables: { input: songDetails },
      });

      // If successful, the response here will be `null`:
      setCurrentSong(updatedSong?.data?.updateSong);
      setCurrentImageUrl(updatedSong?.data?.updateSong?.coverArtKey);
    } catch (error) {
      console.error("Error removing image from song: ", error);
    }
  }

  // Remove the record association and delete the file
  async function deleteImageForCurrentSong() {
    if (!currentSong) return;

    try {
      const response = await API.graphql<GraphQLQuery<GetSongQuery>>({
        query: queries.getSong,
        variables: { id: currentSong.id },
      });

      const song = response?.data?.getSong;

      // Ensure that the record has an associated image:
      if (!song?.coverArtKey) return;

      const songDetails: UpdateSongInput = {
        id: song.id,
        coverArtKey: null, // Set the file association to `null`
      };

      // Remove associated file from record
      const updatedSong = await API.graphql<GraphQLQuery<UpdateSongMutation>>({
        query: mutations.updateSong,
        variables: { input: songDetails },
      });

      // Delete the file from S3:
      await Storage.remove(song.coverArtKey);

      // If successful, the response here will be `null`:
      setCurrentSong(updatedSong?.data?.updateSong);
      setCurrentImageUrl(updatedSong?.data?.updateSong?.coverArtKey);
    } catch (error) {
      console.error("Error deleting image: ", error);
    }
  }

  // Delete both file and record
  async function deleteCurrentSongAndImage() {
    if (!currentSong) return;

    try {
      const response = await API.graphql<GraphQLQuery<GetSongQuery>>({
        query: queries.getSong,
        variables: { id: currentSong.id },
      });

      const song = response?.data?.getSong;

      // Ensure that the record has an associated image:
      if (!song?.coverArtKey) return;

      await Storage.remove(song.coverArtKey);

      const songDetails: DeleteSongInput = {
        id: song.id,
      };

      await API.graphql<GraphQLQuery<DeleteSongMutation>>({
        query: mutations.deleteSong,
        variables: { input: songDetails },
      });

      clearLocalState();
    } catch (error) {
      console.error("Error deleting song: ", error);
    }
  }

  function clearLocalState() {
    setCurrentSong(null);
    setCurrentImageUrl("");
  }

  return (
    <Authenticator>
      {({ signOut, user }) => (
        <main
          style={{
            alignItems: "center",
            display: "flex",
            flexDirection: "column",
          }}
        >
          <h1>Hello {user?.username}!</h1>
          <h2>{`Current Song: ${currentSong?.id}`}</h2>
          <label>
            Create song with file:
            <input id="name" type="file" onChange={createSongWithImage} />
          </label>
          <label>
            Add / update song image:
            <input
              id="name"
              type="file"
              onChange={addNewImageToSong}
              disabled={!currentSong}
            />
          </label>
          <button
            onClick={getImageForCurrentSong}
            disabled={!currentSong || !currentImageUrl}
          >
            Get image for current song
          </button>
          <button
            onClick={removeImageFromSong}
            disabled={!currentSong || !currentImageUrl}
          >
            Remove image from current song (does not delete image)
          </button>
          <button
            onClick={deleteImageForCurrentSong}
            disabled={!currentSong || !currentImageUrl}
          >
            Remove image from current song, then delete image
          </button>
          <button onClick={deleteCurrentSongAndImage} disabled={!currentSong}>
            Delete current song (and image, if it exists)
          </button>
          <button onClick={signOut}>Sign out</button>
          {currentImageUrl && (
            <img src={currentImageUrl} alt="Storage file"></img>
          )}
        </main>
      )}
    </Authenticator>
  );
}

export default App;
``` 

</Block>
<Block name="Single File (JS)">

```js
import { useState } from "react";
import { API, Storage } from "aws-amplify";
import { Authenticator } from "@aws-amplify/ui-react";
import "@aws-amplify/ui-react/styles.css";
import * as queries from "./graphql/queries";
import * as mutations from "./graphql/mutations";

function App() {
  const [currentSong, setCurrentSong] = useState();

  // Used to display image for current song:
  const [currentImageUrl, setCurrentImageUrl] = useState("");

  async function createSongWithImage(e) {
    if (!e.target.files) return;

    const file = e.target.files[0];

    try {
      const createSongDetails = {
        name: `My first song`,
      };

      // Create the API record:
      const response = await API.graphql({
        query: mutations.createSong,
        variables: { input: createSongDetails },
      });

      const song = response?.data?.createSong;

      if (!song) return;

      // Upload the Storage file:
      const result = await Storage.put(`${song.id}-${file.name}`, file, {
        contentType: "image/png", // contentType is optional
      });

      const updateSongDetails = {
        id: song.id,
        coverArtKey: result?.key,
      };

      // Add the file association to the record:
      const updateResponse = await API.graphql({
        query: mutations.updateSong,
        variables: { input: updateSongDetails },
      });

      const updatedSong = updateResponse?.data?.updateSong;

      setCurrentSong(updatedSong);

      // Ensure that the record has an associated image:
      if (!updatedSong?.coverArtKey) return;

      // Retrieve the file's signed URL:
      const signedURL = await Storage.get(updatedSong.coverArtKey);
      setCurrentImageUrl(signedURL);
    } catch (error) {
      console.error("Error create song / file:", error);
    }
  }

  // Upload image, add to song, retrieve signed URL and retrieve the image.
  // Also updates image if one already exists.
  async function addNewImageToSong(e) {
    if (!currentSong) return;

    if (!e.target.files) return;

    const file = e.target.files[0];

    try {
      // Upload the Storage file:
      const result = await Storage.put(`${currentSong.id}-${file.name}`, file, {
        contentType: "image/png", // contentType is optional
      });

      const updateSongDetails = {
        id: currentSong.id,
        coverArtKey: result?.key,
      };

      // Add the file association to the record:
      const response = await API.graphql({
        query: mutations.updateSong,
        variables: { input: updateSongDetails },
      });

      const updatedSong = response?.data?.updateSong;

      setCurrentSong(updatedSong);

      // Ensure that the record has an associated image:
      if (!updatedSong?.coverArtKey) return;

      // Retrieve the file's signed URL:
      const signedURL = await Storage.get(updatedSong.coverArtKey);
      setCurrentImageUrl(signedURL);
    } catch (error) {
      console.error("Error uploading image / adding image to song: ", error);
    }
  }

  async function getImageForCurrentSong() {
    try {
      // Query the record to get the file key:
      const response = await API.graphql({
        query: queries.getSong,
        variables: { id: currentSong.id },
      });
      const song = response.data?.getSong;

      // Ensure that the record has an associated image:
      if (!song?.coverArtKey) return;

      // Retrieve the signed URL:
      const signedURL = await Storage.get(song.coverArtKey);

      setCurrentImageUrl(signedURL);
    } catch (error) {
      console.error("Error getting song / image:", error);
    }
  }

  // Remove the file association, continue to persist both file and record
  async function removeImageFromSong() {
    if (!currentSong) return;

    try {
      const response = await API.graphql({
        query: queries.getSong,
        variables: { id: currentSong.id },
      });

      const song = response?.data?.getSong;

      // Ensure that the record has an associated image:
      if (!song?.coverArtKey) return;

      const songDetails = {
        id: song.id,
        coverArtKey: null,
      };

      const updatedSong = await API.graphql({
        query: mutations.updateSong,
        variables: { input: songDetails },
      });

      // If successful, the response here will be `null`:
      setCurrentSong(updatedSong?.data?.updateSong);
      setCurrentImageUrl(updatedSong?.data?.updateSong?.coverArtKey);
    } catch (error) {
      console.error("Error removing image from song: ", error);
    }
  }

  // Remove the record association and delete the file
  async function deleteImageForCurrentSong() {
    if (!currentSong) return;

    try {
      const response = await API.graphql({
        query: queries.getSong,
        variables: { id: currentSong.id },
      });

      const song = response?.data?.getSong;

      // Ensure that the record has an associated image:
      if (!song?.coverArtKey) return;

      const songDetails = {
        id: song.id,
        coverArtKey: null, // Set the file association to `null`
      };

      // Remove associated file from record
      const updatedSong = await API.graphql({
        query: mutations.updateSong,
        variables: { input: songDetails },
      });

      // Delete the file from S3:
      await Storage.remove(song.coverArtKey);

      // If successful, the response here will be `null`:
      setCurrentSong(updatedSong?.data?.updateSong);
      setCurrentImageUrl(updatedSong?.data?.updateSong?.coverArtKey);
    } catch (error) {
      console.error("Error deleting image: ", error);
    }
  }

  // Delete both file and record
  async function deleteCurrentSongAndImage() {
    if (!currentSong) return;

    try {
      const response = await API.graphql({
        query: queries.getSong,
        variables: { id: currentSong.id },
      });

      const song = response?.data?.getSong;

      // Ensure that the record has an associated image:
      if (!song?.coverArtKey) return;

      await Storage.remove(song.coverArtKey);

      const songDetails = {
        id: song.id,
      };

      await API.graphql({
        query: mutations.deleteSong,
        variables: { input: songDetails },
      });

      clearLocalState();
    } catch (error) {
      console.error("Error deleting song: ", error);
    }
  }

  function clearLocalState() {
    setCurrentSong(null);
    setCurrentImageUrl("");
  }

  return (
    <Authenticator>
      {({ signOut, user }) => (
        <main
          style={{
            alignItems: "center",
            display: "flex",
            flexDirection: "column",
          }}
        >
          <h1>Hello {user?.username}!</h1>
          <h2>{`Current Song: ${currentSong?.id}`}</h2>
          <label>
            Create song with file:
            <input id="name" type="file" onChange={createSongWithImage} />
          </label>
          <label>
            Add / update song image:
            <input
              id="name"
              type="file"
              onChange={addNewImageToSong}
              disabled={!currentSong}
            />
          </label>
          <button
            onClick={getImageForCurrentSong}
            disabled={!currentSong || !currentImageUrl}
          >
            Get image for current song
          </button>
          <button
            onClick={removeImageFromSong}
            disabled={!currentSong || !currentImageUrl}
          >
            Remove image from current song (does not delete image)
          </button>
          <button
            onClick={deleteImageForCurrentSong}
            disabled={!currentSong || !currentImageUrl}
          >
            Remove image from current song, then delete image
          </button>
          <button onClick={deleteCurrentSongAndImage} disabled={!currentSong}>
            Delete current song (and image, if it exists)
          </button>
          <button onClick={signOut}>Sign out</button>
          {currentImageUrl && (
            <img src={currentImageUrl} alt="Storage file"></img>
          )}
        </main>
      )}
    </Authenticator>
  );
}

export default App;
```

</Block>

<Block name="Multi-File (TS)">

```ts
import { useState } from "react";
import { API, Storage } from "aws-amplify";
import { Authenticator } from "@aws-amplify/ui-react";
import "@aws-amplify/ui-react/styles.css";
import { GraphQLQuery } from "@aws-amplify/api";
import * as queries from "./graphql/queries";
import * as mutations from "./graphql/mutations";
import {
  CreatePhotoAlbumInput,
  CreatePhotoAlbumMutation,
  DeletePhotoAlbumInput,
  DeletePhotoAlbumMutation,
  GetPhotoAlbumQuery,
  ListPhotoAlbumsQuery,
  UpdatePhotoAlbumInput,
  UpdatePhotoAlbumMutation,
} from "./API";

function App() {
  const [currentPhotoAlbum, setCurrentPhotoAlbum] = useState<any>();

  // Used to display images for current photoAlbum:
  const [currentImages, setCurrentImages] = useState<
    (string | null | undefined)[] | null | undefined
  >([]);

  async function createPhotoAlbumWithFirstImage(
    e: React.ChangeEvent<HTMLInputElement>
  ) {
    if (!e.target.files) return;

    const file = e.target.files[0];

    try {
      const result = await Storage.put(file.name, file, {
        contentType: "image/png", // contentType is optional
      });

      const photoAlbumDetails: CreatePhotoAlbumInput = {
        name: `My first photoAlbum`,
        imageKeys: [result?.key],
      };

      const response = await API.graphql<
        GraphQLQuery<CreatePhotoAlbumMutation>
      >({
        query: mutations.createPhotoAlbum,
        variables: { input: photoAlbumDetails },
      });

      const photoAlbum = response?.data?.createPhotoAlbum;
      setCurrentPhotoAlbum(photoAlbum);

      if (!photoAlbum?.imageKeys?.length) return;

      const signedURL = await Storage.get(photoAlbum.imageKeys[0]!);
      setCurrentImages([signedURL]);
    } catch (error) {
      console.error("Error create photoAlbum / file:", error);
    }
  }

  async function createPhotoAlbumWithMultipleImages(
    e: React.ChangeEvent<HTMLInputElement>
  ) {
    if (!e.target.files) return;

    try {
      // Upload all files to Storage:
      const imageKeys = await Promise.all(
        Array.from(e.target.files).map(async (file) => {
          const result = await Storage.put(file.name, file, {
            contentType: "image/png", // contentType is optional
          });

          return result?.key;
        })
      );

      const photoAlbumDetails: CreatePhotoAlbumInput = {
        name: `My first photoAlbum`,
        imageKeys,
      };

      // Create album with associated files:
      const response = await API.graphql<
        GraphQLQuery<CreatePhotoAlbumMutation>
      >({
        query: mutations.createPhotoAlbum,
        variables: { input: photoAlbumDetails },
      });

      const photoAlbum = response?.data?.createPhotoAlbum;
      setCurrentPhotoAlbum(photoAlbum);

      if (!photoAlbum?.imageKeys) return;

      // Retrieve signed urls for all files:
      const signedUrls = await Promise.all(
        photoAlbum?.imageKeys.map(async (key) => await Storage.get(key!))
      );

      if (!signedUrls) return;
      setCurrentImages(signedUrls);
    } catch (error) {
      console.error("Error create photoAlbum / file:", error);
    }
  }

  async function addNewImagesToPhotoAlbum(
    e: React.ChangeEvent<HTMLInputElement>
  ) {
    if (!currentPhotoAlbum) return;

    if (!e.target.files) return;

    try {
      // Upload all files to Storage:
      const newImageKeys = await Promise.all(
        Array.from(e.target.files).map(async (file) => {
          const result = await Storage.put(file.name, file, {
            contentType: "image/png", // contentType is optional
          });

          return result?.key;
        })
      );

      // Query existing record to retrieve currently associated files:
      const queriedResponse = await API.graphql<
        GraphQLQuery<GetPhotoAlbumQuery>
      >({
        query: queries.getPhotoAlbum,
        variables: { id: currentPhotoAlbum.id },
      });

      const photoAlbum = queriedResponse.data?.getPhotoAlbum;

      if (!photoAlbum?.imageKeys) return;

      // Merge existing and new file keys:
      const updatedImageKeys = [...newImageKeys, ...photoAlbum.imageKeys];

      const photoAlbumDetails: UpdatePhotoAlbumInput = {
        id: currentPhotoAlbum.id,
        imageKeys: updatedImageKeys,
      };

      // Update record with merged file associations:
      const response = await API.graphql<
        GraphQLQuery<UpdatePhotoAlbumMutation>
      >({
        query: mutations.updatePhotoAlbum,
        variables: { input: photoAlbumDetails },
      });

      const updatedPhotoAlbum = response?.data?.updatePhotoAlbum;
      setCurrentPhotoAlbum(updatedPhotoAlbum);

      // Ensure that the record has an associated image:
      if (!updatedPhotoAlbum?.imageKeys) return;

      // Retrieve signed urls for merged image keys:
      const signedUrls = await Promise.all(
        updatedPhotoAlbum?.imageKeys.map(async (key) => await Storage.get(key!))
      );

      if (!signedUrls) return;

      setCurrentImages(signedUrls);
    } catch (error) {
      console.error(
        "Error uploading image / adding image to photoAlbum: ",
        error
      );
    }
  }

  async function getImagesForPhotoAlbum() {
    try {
      // Query the record to get the file keys:
      const response = await API.graphql<GraphQLQuery<GetPhotoAlbumQuery>>({
        query: queries.getPhotoAlbum,
        variables: { id: currentPhotoAlbum.id },
      });
      const photoAlbum = response.data?.getPhotoAlbum;

      // Ensure that the record has associated images:
      if (!photoAlbum?.imageKeys) return;

      // Retrieve the signed URLs for the associated images:
      const signedUrls = await Promise.all(
        photoAlbum.imageKeys.map(async (imageKey) => {
          if (!imageKey) return;
          return await Storage.get(imageKey);
        })
      );

      setCurrentImages(signedUrls);
    } catch (error) {
      console.error("Error getting photoAlbum / image:", error);
    }
  }

  // Remove the file associations, continue to persist both files and record
  async function removeImagesFromPhotoAlbum() {
    if (!currentPhotoAlbum) return;

    try {
      const response = await API.graphql<GraphQLQuery<GetPhotoAlbumQuery>>({
        query: queries.getPhotoAlbum,
        variables: { id: currentPhotoAlbum.id },
      });

      const photoAlbum = response?.data?.getPhotoAlbum;

      // Ensure that the record has an associated image:
      if (!photoAlbum?.imageKeys) return;

      const photoAlbumDetails: UpdatePhotoAlbumInput = {
        id: photoAlbum.id,
        imageKeys: null,
      };

      const updatedPhotoAlbum = await API.graphql<
        GraphQLQuery<UpdatePhotoAlbumMutation>
      >({
        query: mutations.updatePhotoAlbum,
        variables: { input: photoAlbumDetails },
      });

      // If successful, the response here will be `null`:
      setCurrentPhotoAlbum(updatedPhotoAlbum?.data?.updatePhotoAlbum);
      setCurrentImages(updatedPhotoAlbum?.data?.updatePhotoAlbum?.imageKeys);
    } catch (error) {
      console.error("Error removing image from photoAlbum: ", error);
    }
  }

  // Remove the record association and delete the file
  async function deleteImagesForCurrentPhotoAlbum() {
    if (!currentPhotoAlbum) return;

    try {
      const response = await API.graphql<GraphQLQuery<GetPhotoAlbumQuery>>({
        query: queries.getPhotoAlbum,
        variables: { id: currentPhotoAlbum.id },
      });

      const photoAlbum = response?.data?.getPhotoAlbum;

      // Ensure that the record has an associated images:
      if (!photoAlbum?.imageKeys) return;

      const photoAlbumDetails: UpdatePhotoAlbumInput = {
        id: photoAlbum.id,
        imageKeys: null, // Set the file association to `null`
      };

      // Remove associated files from record
      const updatedPhotoAlbum = await API.graphql<
        GraphQLQuery<UpdatePhotoAlbumMutation>
      >({
        query: mutations.updatePhotoAlbum,
        variables: { input: photoAlbumDetails },
      });

      // Delete the files from S3:
      await Promise.all(
        photoAlbum?.imageKeys.map(async (imageKey) => {
          if (!imageKey) return;
          await Storage.remove(imageKey);
        })
      );

      // If successful, the response here will be `null`:
      setCurrentPhotoAlbum(updatedPhotoAlbum?.data?.updatePhotoAlbum);
      setCurrentImages(updatedPhotoAlbum?.data?.updatePhotoAlbum?.imageKeys);
    } catch (error) {
      console.error("Error deleting image: ", error);
    }
  }

  // Delete both files and record
  async function deleteCurrentPhotoAlbumAndImages() {
    if (!currentPhotoAlbum) return;

    try {
      const response = await API.graphql<GraphQLQuery<GetPhotoAlbumQuery>>({
        query: queries.getPhotoAlbum,
        variables: { id: currentPhotoAlbum.id },
      });

      const photoAlbum = response?.data?.getPhotoAlbum;

      // Ensure that the record has an associated image:
      if (!photoAlbum?.imageKeys) return;

      await Promise.all(
        photoAlbum?.imageKeys.map(async (imageKey) => {
          if (!imageKey) return;
          await Storage.remove(imageKey);
        })
      );

      const photoAlbumDetails: DeletePhotoAlbumInput = {
        id: photoAlbum.id,
      };

      await API.graphql<GraphQLQuery<DeletePhotoAlbumMutation>>({
        query: mutations.deletePhotoAlbum,
        variables: { input: photoAlbumDetails },
      });

      clearLocalState();
    } catch (error) {
      console.error("Error deleting photoAlbum: ", error);
    }
  }

  function clearLocalState() {
    setCurrentPhotoAlbum(null);
    setCurrentImages([]);
  }

  // NOTE: For test / sample cleanup purposes only (not for docs example)
  async function deleteAll() {
    //region: delete photoAlbums:
    const response = await API.graphql<GraphQLQuery<ListPhotoAlbumsQuery>>({
      query: queries.listPhotoAlbums,
    });

    console.log(
      "PhotoAlbums to delete",
      response?.data?.listPhotoAlbums?.items
    );

    await response?.data?.listPhotoAlbums?.items.forEach(async (photoAlbum) => {
      if (!photoAlbum?.id) return;

      const PhotoAlbumDetails: DeletePhotoAlbumInput = {
        id: photoAlbum?.id,
      };

      const deletedPhotoAlbum = await API.graphql<
        GraphQLQuery<DeletePhotoAlbumMutation>
      >({
        query: mutations.deletePhotoAlbum,
        variables: { input: PhotoAlbumDetails },
      });

      console.log("PhotoAlbum deleted: ", deletedPhotoAlbum);
    });
    //endregion

    // Delete all images:
    await Storage.list("", { pageSize: "ALL" })
      .then(({ results }) => {
        console.log("Images to delete:", results);
        results.forEach(async (result) => {
          if (!result?.key) return;
          try {
            const deletedImage = await Storage.remove(result.key);
            console.log("Image deleted:", deletedImage);
          } catch (error) {
            console.log("Error deleting image: ", error);
          }
        });
      })
      .catch((err) => console.log(err));

    //region verify all deletes were successful:
    const secondResponse = await API.graphql<
      GraphQLQuery<ListPhotoAlbumsQuery>
    >({
      query: queries.listPhotoAlbums,
    });
    console.log(
      "PhotoAlbums should be empty:",
      secondResponse?.data?.listPhotoAlbums?.items
    );

    const storageResponse = await Storage.list("", { pageSize: "ALL" });
    console.log("Images should be empty:", storageResponse?.results);

    if (
      secondResponse?.data?.listPhotoAlbums?.items?.length === 0 &&
      storageResponse?.results?.length === 0
    ) {
      console.log("All deletes successful!");
      clearLocalState();
    }
    //endregion
  }

  return (
    <Authenticator>
      {({ signOut, user }) => (
        <main
          style={{
            alignItems: "center",
            display: "flex",
            flexDirection: "column",
          }}
        >
          <h1>Hello {user?.username}!</h1>
          <h2>{`Current PhotoAlbum: ${currentPhotoAlbum?.id}`}</h2>
          <label>
            Create photoAlbum with one file:
            <input
              id="name"
              type="file"
              accept="image/*"
              onChange={createPhotoAlbumWithFirstImage}
            />
          </label>
          <label>
            Create photoAlbum with multiple files:
            <input
              id="name"
              type="file"
              accept="image/*"
              onChange={createPhotoAlbumWithMultipleImages}
              multiple
            />
          </label>
          <label>
            Add multiple images to current photoAlbum:
            <input
              id="name"
              type="file"
              accept="image/*"
              onChange={addNewImagesToPhotoAlbum}
              disabled={!currentPhotoAlbum}
              multiple
            />
          </label>
          <button
            onClick={getImagesForPhotoAlbum}
            disabled={!currentPhotoAlbum || !currentImages}
          >
            Get Images for Current Photo Album
          </button>
          <button
            onClick={removeImagesFromPhotoAlbum}
            disabled={!currentPhotoAlbum || !currentImages}
          >
            Remove images from current PhotoAlbum (does not delete images)
          </button>
          <button
            onClick={deleteImagesForCurrentPhotoAlbum}
            disabled={!currentPhotoAlbum || !currentImages}
          >
            Remove images from current PhotoAlbum, then delete images
          </button>
          <button
            onClick={deleteCurrentPhotoAlbumAndImages}
            disabled={!currentPhotoAlbum}
          >
            Delete current PhotoAlbum (and images, if they exist)
          </button>
          <button onClick={deleteAll}>Delete all</button>
          <button onClick={signOut}>Sign out</button>
          {currentImages &&
            currentImages.map((url, idx) => {
              if (!url) return undefined;
              return <img src={url} key={idx} alt="Storage file"></img>;
            })}
        </main>
      )}
    </Authenticator>
  );
}

export default App;
```

</Block>

<Block name="Multi-File (JS)">

```js
import { useState } from "react";
import { API, Storage } from "aws-amplify";
import { Authenticator } from "@aws-amplify/ui-react";
import "@aws-amplify/ui-react/styles.css";
import * as queries from "./graphql/queries";
import * as mutations from "./graphql/mutations";

function App() {
  const [currentPhotoAlbum, setCurrentPhotoAlbum] = useState();

  // Used to display images for current photoAlbum:
  const [currentImages, setCurrentImages] = useState([]);

  async function createPhotoAlbumWithFirstImage(e) {
    if (!e.target.files) return;

    const file = e.target.files[0];

    try {
      const result = await Storage.put(file.name, file, {
        contentType: "image/png", // contentType is optional
      });

      const photoAlbumDetails = {
        name: `My first photoAlbum`,
        imageKeys: [result?.key],
      };

      const response = await API.graphql({
        query: mutations.createPhotoAlbum,
        variables: { input: photoAlbumDetails },
      });

      const photoAlbum = response?.data?.createPhotoAlbum;
      setCurrentPhotoAlbum(photoAlbum);

      if (!photoAlbum?.imageKeys?.length) return;

      const signedURL = await Storage.get(photoAlbum.imageKeys[0]);
      setCurrentImages([signedURL]);
    } catch (error) {
      console.error("Error create photoAlbum / file:", error);
    }
  }

  async function createPhotoAlbumWithMultipleImages(e) {
    if (!e.target.files) return;

    try {
      // Upload all files to Storage:
      const imageKeys = await Promise.all(
        Array.from(e.target.files).map(async (file) => {
          const result = await Storage.put(file.name, file, {
            contentType: "image/png", // contentType is optional
          });

          return result?.key;
        })
      );

      const photoAlbumDetails = {
        name: `My first photoAlbum`,
        imageKeys,
      };

      // Create album with associated files:
      const response = await API.graphql({
        query: mutations.createPhotoAlbum,
        variables: { input: photoAlbumDetails },
      });

      const photoAlbum = response?.data?.createPhotoAlbum;
      setCurrentPhotoAlbum(photoAlbum);

      if (!photoAlbum?.imageKeys) return;

      // Retrieve signed urls for all files:
      // @ts-ignore
      const signedUrls = await Promise.all(
        photoAlbum?.imageKeys.map(async (key) => await Storage.get(key))
      );

      if (!signedUrls) return;
      setCurrentImages(signedUrls);
    } catch (error) {
      console.error("Error create photoAlbum / file:", error);
    }
  }

  async function addNewImagesToPhotoAlbum(e) {
    if (!currentPhotoAlbum) return;

    if (!e.target.files) return;

    try {
      // Upload all files to Storage:
      const newImageKeys = await Promise.all(
        Array.from(e.target.files).map(async (file) => {
          const result = await Storage.put(file.name, file, {
            contentType: "image/png", // contentType is optional
          });

          return result?.key;
        })
      );

      // Query existing record to retrieve currently associated files:
      const queriedResponse = await API.graphql({
        query: queries.getPhotoAlbum,
        variables: { id: currentPhotoAlbum.id },
      });

      const photoAlbum = queriedResponse.data?.getPhotoAlbum;

      if (!photoAlbum?.imageKeys) return;

      // Merge existing and new file keys:
      const updatedImageKeys = [...newImageKeys, ...photoAlbum.imageKeys];

      const photoAlbumDetails = {
        id: currentPhotoAlbum.id,
        imageKeys: updatedImageKeys,
      };

      // Update record with merged file associations:
      const response = await API.graphql({
        query: mutations.updatePhotoAlbum,
        variables: { input: photoAlbumDetails },
      });

      const updatedPhotoAlbum = response?.data?.updatePhotoAlbum;
      setCurrentPhotoAlbum(updatedPhotoAlbum);

      // Ensure that the record has an associated image:
      if (!updatedPhotoAlbum?.imageKeys) return;

      // Retrieve signed urls for merged image keys:
      const signedUrls = await Promise.all(
        updatedPhotoAlbum?.imageKeys.map(async (key) => await Storage.get(key))
      );

      if (!signedUrls) return;

      setCurrentImages(signedUrls);
    } catch (error) {
      console.error(
        "Error uploading image / adding image to photoAlbum: ",
        error
      );
    }
  }

  async function getImagesForPhotoAlbum() {
    try {
      // Query the record to get the file keys:
      const response = await API.graphql({
        query: queries.getPhotoAlbum,
        variables: { id: currentPhotoAlbum.id },
      });
      const photoAlbum = response.data?.getPhotoAlbum;

      // Ensure that the record has associated images:
      if (!photoAlbum?.imageKeys) return;

      // Retrieve the signed URLs for the associated images:
      const signedUrls = await Promise.all(
        photoAlbum.imageKeys.map(async (imageKey) => {
          if (!imageKey) return;
          return await Storage.get(imageKey);
        })
      );

      setCurrentImages(signedUrls);
    } catch (error) {
      console.error("Error getting photoAlbum / image:", error);
    }
  }

  // Remove the file associations, continue to persist both files and record
  async function removeImagesFromPhotoAlbum() {
    if (!currentPhotoAlbum) return;

    try {
      const response = await API.graphql({
        query: queries.getPhotoAlbum,
        variables: { id: currentPhotoAlbum.id },
      });

      const photoAlbum = response?.data?.getPhotoAlbum;

      // Ensure that the record has an associated image:
      if (!photoAlbum?.imageKeys) return;

      const photoAlbumDetails = {
        id: photoAlbum.id,
        imageKeys: null,
      };

      const updatedPhotoAlbum = await API.graphql({
        query: mutations.updatePhotoAlbum,
        variables: { input: photoAlbumDetails },
      });

      // If successful, the response here will be `null`:
      setCurrentPhotoAlbum(updatedPhotoAlbum?.data?.updatePhotoAlbum);
      setCurrentImages(updatedPhotoAlbum?.data?.updatePhotoAlbum?.imageKeys);
    } catch (error) {
      console.error("Error removing image from photoAlbum: ", error);
    }
  }

  // Remove the record association and delete the file
  async function deleteImagesForCurrentPhotoAlbum() {
    if (!currentPhotoAlbum) return;

    try {
      const response = await API.graphql({
        query: queries.getPhotoAlbum,
        variables: { id: currentPhotoAlbum.id },
      });

      const photoAlbum = response?.data?.getPhotoAlbum;

      // Ensure that the record has an associated images:
      if (!photoAlbum?.imageKeys) return;

      const photoAlbumDetails = {
        id: photoAlbum.id,
        imageKeys: null, // Set the file association to `null`
      };

      // Remove associated files from record
      const updatedPhotoAlbum = await API.graphql({
        query: mutations.updatePhotoAlbum,
        variables: { input: photoAlbumDetails },
      });

      // Delete the files from S3:
      await Promise.all(
        photoAlbum?.imageKeys.map(async (imageKey) => {
          if (!imageKey) return;
          await Storage.remove(imageKey);
        })
      );

      // If successful, the response here will be `null`:
      setCurrentPhotoAlbum(updatedPhotoAlbum?.data?.updatePhotoAlbum);
      setCurrentImages(updatedPhotoAlbum?.data?.updatePhotoAlbum?.imageKeys);
    } catch (error) {
      console.error("Error deleting image: ", error);
    }
  }

  // Delete both files and record
  async function deleteCurrentPhotoAlbumAndImages() {
    if (!currentPhotoAlbum) return;

    try {
      const response = await API.graphql({
        query: queries.getPhotoAlbum,
        variables: { id: currentPhotoAlbum.id },
      });

      const photoAlbum = response?.data?.getPhotoAlbum;

      // Ensure that the record has an associated image:
      if (!photoAlbum?.imageKeys) return;

      await Promise.all(
        photoAlbum?.imageKeys.map(async (imageKey) => {
          if (!imageKey) return;
          await Storage.remove(imageKey);
        })
      );

      const photoAlbumDetails = {
        id: photoAlbum.id,
      };

      await API.graphql({
        query: mutations.deletePhotoAlbum,
        variables: { input: photoAlbumDetails },
      });

      clearLocalState();
    } catch (error) {
      console.error("Error deleting photoAlbum: ", error);
    }
  }

  function clearLocalState() {
    setCurrentPhotoAlbum(null);
    setCurrentImages([]);
  }

  // NOTE: For test / sample cleanup purposes only (not for docs example)
  async function deleteAll() {
    //region: delete photoAlbums:
    const response = await API.graphql({
      query: queries.listPhotoAlbums,
    });

    console.log(
      "PhotoAlbums to delete",
      response?.data?.listPhotoAlbums?.items
    );

    await response?.data?.listPhotoAlbums?.items.forEach(async (photoAlbum) => {
      if (!photoAlbum?.id) return;

      const PhotoAlbumDetails = {
        id: photoAlbum?.id,
      };

      const deletedPhotoAlbum = await API.graphql({
        query: mutations.deletePhotoAlbum,
        variables: { input: PhotoAlbumDetails },
      });

      console.log("PhotoAlbum deleted: ", deletedPhotoAlbum);
    });
    //endregion

    // Delete all images:
    await Storage.list("", { pageSize: "ALL" })
      .then(({ results }) => {
        console.log("Images to delete:", results);
        results.forEach(async (result) => {
          if (!result?.key) return;
          try {
            const deletedImage = await Storage.remove(result.key);
            console.log("Image deleted:", deletedImage);
          } catch (error) {
            console.log("Error deleting image: ", error);
          }
        });
      })
      .catch((err) => console.log(err));

    //region verify all deletes were successful:
    const secondResponse = await API.graphql({
      query: queries.listPhotoAlbums,
    });
    console.log(
      "PhotoAlbums should be empty:",
      secondResponse?.data?.listPhotoAlbums?.items
    );

    const storageResponse = await Storage.list("", { pageSize: "ALL" });
    console.log("Images should be empty:", storageResponse?.results);

    if (
      secondResponse?.data?.listPhotoAlbums?.items?.length === 0 &&
      storageResponse?.results?.length === 0
    ) {
      console.log("All deletes successful!");
      clearLocalState();
    }
    //endregion
  }

  return (
    <Authenticator>
      {({ signOut, user }) => (
        <main
          style={{
            alignItems: "center",
            display: "flex",
            flexDirection: "column",
          }}
        >
          <h1>Hello {user?.username}!</h1>
          <h2>{`Current PhotoAlbum: ${currentPhotoAlbum?.id}`}</h2>
          <label>
            Create photoAlbum with one file:
            <input
              id="name"
              type="file"
              accept="image/*"
              onChange={createPhotoAlbumWithFirstImage}
            />
          </label>
          <label>
            Create photoAlbum with multiple files:
            <input
              id="name"
              type="file"
              accept="image/*"
              onChange={createPhotoAlbumWithMultipleImages}
              multiple
            />
          </label>
          <label>
            Add multiple images to current photoAlbum:
            <input
              id="name"
              type="file"
              accept="image/*"
              onChange={addNewImagesToPhotoAlbum}
              disabled={!currentPhotoAlbum}
              multiple
            />
          </label>
          <button
            onClick={getImagesForPhotoAlbum}
            disabled={!currentPhotoAlbum || !currentImages}
          >
            Get Images for Current Photo Album
          </button>
          <button
            onClick={removeImagesFromPhotoAlbum}
            disabled={!currentPhotoAlbum || !currentImages}
          >
            Remove images from current PhotoAlbum (does not delete images)
          </button>
          <button
            onClick={deleteImagesForCurrentPhotoAlbum}
            disabled={!currentPhotoAlbum || !currentImages}
          >
            Remove images from current PhotoAlbum, then delete images
          </button>
          <button
            onClick={deleteCurrentPhotoAlbumAndImages}
            disabled={!currentPhotoAlbum}
          >
            Delete current PhotoAlbum (and images, if they exist)
          </button>
          <button onClick={deleteAll}>Delete all</button>
          <button onClick={signOut}>Sign out</button>
          {currentImages &&
            currentImages.map((url, idx) => {
              if (!url) return undefined;
              return <img src={url} key={idx} alt="Storage file"></img>;
            })}
        </main>
      )}
    </Authenticator>
  );
}

export default App;
```

</Block>

</BlockSwitcher>