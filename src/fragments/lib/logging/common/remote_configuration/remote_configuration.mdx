The AWSCloudWatchLoggingPlugin log levels can be configured remotely.  When configured, the Amplify Logger will fetch the remote log levels, defined in a `remoteloggingconstraints.json` file and deployed to an S3 bucket, via an API Gateway endpoint that is integrated with a lambda.  The log levels defined in the remote logging constraints file will overwrite the local log levels and will persist across app sessions.

You will need to provision and maintain your own backend resources.  The following provides a CDK construct example to provision the required AWS resources.

<Callout warning>
When you are provisioning your backend resources, you are responsible for following best security practices and securing your backend resources.
</Callout>

## CDK construct
Below is an example CDK construct that provisions the Amazon CloudWatch, AWS API Gateway, AWS Lambda, and AWS S3 bucket.  The CDK construct also deploys the `remoteloggingconstraints.json` file to the AWS S3 bucket. 

### Permissions
The CDK construct sample created IAM permission policies and assigned it to the Amplify authenticated and un-authenticate role.  
1. The API Gateway endpoint can only be invoked by user with Amplify authenticated/unauthenticated roles.  
2. Logs can only be sent by mobile application users with Amplify authenticated/unauthenticated roles.
3. The lambda invocation is only allowed from the provision AWS API Gateway resource.
4. The S3 bucket containing the `remoteloggingconstraints.json` can only be read by the Lambda execution role.

### Replace the placeholder values with your own values:
* `<CloudWatch-log-group-name>` is the log group that logs will be sent to.
* `<S3-bucket-name>` is the S3 bucket that will hold the logging constraints json file that gets fetched remotely.
* `<Amplify-authenticated-role-name>` and `<Amplify-unauthenticated-role-name>` are Amplify roles created as part of Amplify Auth configuration via Amplify CLI.  

### Resource dependencies
* `lambdaConfig` provides the location and lambda for reading from S3.  An example is provided in the next sections.
* `configFileName` and `loggingConfigLocation` provides the location and file name of the log level configuration file that is deployed to S3.  An example is provide in the next sections. 

```js
import * as cdk from "aws-cdk-lib"
import { Construct } from "constructs"
import * as apigateway from "aws-cdk-lib/aws-apigateway"
import * as lambda from "aws-cdk-lib/aws-lambda"
import * as s3 from "aws-cdk-lib/aws-s3"
import * as logs from "aws-cdk-lib/aws-logs"
import { BucketDeployment, Source } from "aws-cdk-lib/aws-s3-deployment"
import * as path from "path"
import * as iam from "aws-cdk-lib/aws-iam"

export class RemoteLoggingConstraintsConstruct extends Construct {
  constructor(scope: Construct, id: string, props: RemoteLoggingConstraintProps) {
    super(scope, id)

    const region = cdk.Stack.of(this).region
    const account = cdk.Stack.of(this).account
    const loggingConfigLocation = 'resources/config/remoteloggingconstraints.json'
    const lambdaConfig = 'resources/lambda/remoteconfig.js'
    const configFileName = 'remoteloggingconstraints.json'
    const logGroupName = <CloudWatch-log-group-name>
    const authRoleName = <Amplify-authenticated-role-name> 
    const unAuthRoleName = <Amplify-unauthenticated-role-name>
    const bucketName = <S3-bucket-name>

    new logs.LogGroup(this, 'Log Group', {
      logGroupName: logGroupName,
      retention: logs.RetentionDays.INFINITE
    })
    
    const authRole = iam.Role.fromRoleName(this, "Auth-Role", authRoleName)
    const unAuthRole = iam.Role.fromRoleName(this, "UnAuth-Role", unAuthRoleName)
    const logResource = `arn:aws:logs:${region}:${account}:log-group:${logGroupName}:log-stream:*`
    const logIAMPolicy = new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      resources: [logResource],
      actions: ["logs:PutLogEvents", "logs:DescribeLogStreams", "logs:CreateLogStream"]
    })

    authRole.addToPrincipalPolicy(logIAMPolicy)
    unAuthRole.addToPrincipalPolicy(logIAMPolicy)

    const remoteConfigBucket = new s3.Bucket(this, 'AmplifyRemoteLogging-Bucket', {
        publicReadAccess: false,
        versioned: true,
        bucketName: bucketName
      });

    new BucketDeployment(this, `AmplifyRemoteLogging-BucketDeployment`, {
        sources: [
            Source.asset(path.dirname(path.join(loggingConfigLocation))),
        ],
        destinationBucket: remoteConfigBucket
    });

    const handler = new lambda.Function(this, "AmplifyRemoteLogging-Handler", {
      runtime: lambda.Runtime.NODEJS_18_X,
      code: lambda.Code.fromAsset(path.dirname(path.join(lambdaConfig))),
      handler: "remotelogging.main",
      environment: {
        BUCKET: remoteConfigBucket.bucketName,
        KEY: configFileName
      }
    })

    remoteConfigBucket.grantRead(handler)

    const api = new apigateway.RestApi(this, "AmplifyRemoteLogging-API", {
      restApiName: "Logging API",
      description: "API Gateway for Remote Logging"
    })

    const getRemoteLoggingIntegration = new apigateway.LambdaIntegration(handler)
    const loggingConstraints = api.root.addResource('loggingconstraints')
    const getLoggingConstraints = loggingConstraints.addMethod('GET', getRemoteLoggingIntegration, {
      authorizationType: apigateway.AuthorizationType.IAM
    })

    const apiInvokePolicy = new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      resources: [ getLoggingConstraints.methodArn ],
      actions: ['execute-api:Invoke']
    })

    authRole.addToPrincipalPolicy(apiInvokePolicy)
    unAuthRole.addToPrincipalPolicy(apiInvokePolicy)

  }
}
```

## Sample Lambda handler
Below is a sample lambda that reads and returns the `remoteloggingconstraints.json` from AWS S3.
Note that caching and ETag is used.  To reduce data usage, if the logging levels has not changed since the last fetch, there is no need to return the log levels.

```js
const { S3Client, GetObjectCommand } = require("@aws-sdk/client-s3")
const s3 = new S3Client({})
const bucketName = process.env.BUCKET
const key = process.env.KEY
let cachedConfig = {
    expiresOn: 0, 
    ETag: '', 
    config: ''
}

exports.main = async function(event, context) {
  try {
    if (event.httpMethod === "GET") {
      if (!cachedConfig.config || Date.now() > cachedConfig.expiresOn) {
        // refresh cache if cache is invalid
        const command = new GetObjectCommand({ Bucket: bucketName, Key: key })
        const s3Resp = await s3.send(command)
        await setCachedConfig(s3Resp)
      }

      if (event.headers['If-None-Match'] === cachedConfig.ETag) {
        // return 304 not modified if config has not changed
        return {
          statusCode: 304,
        }
      } else {
        // return updated/modified config with latest ETag
        return {
          statusCode: 200,
          headers: {"'If-None-Match'": cachedConfig.ETag },
          body: cachedConfig.config
        }
      }
    }
  } catch(error) {
    const resp = error.stack || JSON.stringify(error, null, 2)
    return {
      statusCode: 400,
        headers: {},
        body: JSON.stringify(resp)
    }
  }
}

const setCachedConfig = async (s3Resp) => {
  cachedConfig = {
    expiresOn: Date.now() + 600 * 1000, //10 minutes
    ETag: s3Resp.ETag.replace(/\"/gi, ''), //remove \" from string
    config: await s3Resp.Body.transformToString()
  }
}
```

## Sample `remoteloggingconstraints.json`
Below is a sample remote config file that overwrites the local file in the mobile application.  This file will be deployed to S3.  Once deployed, you can change your application log levels by editing this file in S3.

```json
{
    "defaultLogLevel": "ERROR",
    "categoryLogLevel": {
        "API": "DEBUG",
        "AUTH": "DEBUG",
    },
    "userLogLevel": {
        "cognito-sub-xyz-123": {
            "defaultLogLevel": "VERBOSE",
            "categoryLogLevel": {
                "API": "VERBOSE",
                "AUTH": "VERBOSE",
            }
        }
    }
}
```

## Enable Remote Log Levels
To enable Amplify Logger to fetch remote log levels, you will need to provide the api endpoint that has the log levels and the fresh interval that you want the Amplify Logger to refresh.

import iosRemoteConfigProvider from '/src/fragments/lib/logging/ios/remote_configuration/10_remote_config_provider.mdx';
import androidRemoteConfigProvider from '/src/fragments/lib/logging/android/remote_configuration/10_remote_config_provider.mdx';
import remoteConfigProvider from '/src/fragments/lib/logging/common/remote_configuration/remote_config_provider.mdx';

<BlockSwitcher>
  <Block name="With Configuration File">
    <Fragments fragments={{all: remoteConfigProvider}}/>
  </Block>

  <Block name="With Code">
    <Fragments
      fragments={{
        ios: iosRemoteConfigProvider,
        android: androidRemoteConfigProvider
      }}
    />
  </Block>
</BlockSwitcher>

