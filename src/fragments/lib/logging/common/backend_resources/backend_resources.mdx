The AWSCloudWatchLoggingPlugin log levels can be configured remotely.  You will need to provision and maintain your own backend resources that provides the logging constraints.

When setting up remote configuration and using Amplify's default implementation `DefaultRemoteLoggingConstraintsProvider`, Amplify assumes that the backend resources consists of an API Gateway endpoint that is integrated with a lambda.  The lambda gets the remote logging constraints json file from an S3 bucket.

<Callout warning>
When you are provisioning your backend resources, you are responsible for following best security practices and securing your backend resources.
</Callout>

## CDK construct
Below is an example CDK construct that provisions the AWS CloudWatch, AWS API Gateway, AWS Lambda, and AWS S3 bucket.  The CDK construct also deploys the `logging_constraints.json` file to the AWS S3 bucket.  This is the file that will be fetched in the mobile application.  Log levels define in the remote file will overwrite the log levels defined in the mobile application.

The CDK construct sample created IAM permission policies and assigned it to the Amplify authenticated and unauthenticate role.  

1. The API Gateway endpoint can only be invoked by user with Amplify authenticated/unauthenticated roles.  
2. Logs can only be sent by mobile application users with Amplify authenticated/unauthenticated roles.
3. The lambda invocation is only allowed from the provision AWS API Gateway resource.
4. The S3 bucket containing the `remotelogginconstraints.json` can only be read by the Lambda execution role.

```js
import * as cdk from "aws-cdk-lib"
import { Construct } from "constructs"
import * as apigateway from "aws-cdk-lib/aws-apigateway"
import * as lambda from "aws-cdk-lib/aws-lambda"
import * as s3 from "aws-cdk-lib/aws-s3"
import * as logs from "aws-cdk-lib/aws-logs"
import { BucketDeployment, Source } from "aws-cdk-lib/aws-s3-deployment"
import * as path from "path"
import * as iam from "aws-cdk-lib/aws-iam"

export interface RemoteLoggingConstraintProps extends cdk.StackProps {
  bucketName?: string
  logGroupName?: string
  authRoleName?: string
  unAuthRoleName?: string
}

export class RemoteLoggingConstraintsConstruct extends Construct {
  constructor(scope: Construct, id: string, props: RemoteLoggingConstraintProps) {
    super(scope, id)

    const region = cdk.Stack.of(this).region
    const account = cdk.Stack.of(this).account
    const loggingConfig = 'resources/config/remoteloggingconstraints.json'
    const lambdaConfig = 'resources/lambda/remoteconfig.js'
    const configFileName = 'remoteloggingconstraints.json'
    const bucketName = props.bucketName 
    const logGroupName = props.logGroupName 
    const authRoleName = props.authRoleName 
    const unAuthRoleName = props.unAuthRoleName 
    
    // create new log group
    new logs.LogGroup(this, 'Log Group', {
      logGroupName: logGroupName,
      retention: logs.RetentionDays.INFINITE
    })
    
    // setup IAM permission policy for amplify auth/unauth roles to log to log group
    const authRole = iam.Role.fromRoleName(this, "Auth-Role", authRoleName)
    const unAuthRole = iam.Role.fromRoleName(this, "UnAuth-Role", unAuthRoleName)
    const logResource = `arn:aws:logs:${region}:${account}:log-group:${logGroupName}:log-stream:*`
    const logIAMPolicy = new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      resources: [logResource],
      actions: ["logs:PutLogEvents", "logs:DescribeLogStreams", "logs:CreateLogStream"]
    })

    authRole.addToPrincipalPolicy(logIAMPolicy)
    unAuthRole.addToPrincipalPolicy(logIAMPolicy)

    // create S3 bucket
    const remoteConfigBucket = new s3.Bucket(this, 'AmplifyRemoteLogging-Bucket', {
        publicReadAccess: false,
        versioned: true,
        bucketName: bucketName
      });

    // deploy S3 bucket with resources in resources/config/ directory
    new BucketDeployment(this, `AmplifyRemoteLogging-BucketDeployment`, {
        sources: [
            Source.asset(path.dirname(path.join(loggingConfig))),
        ],
        destinationBucket: remoteConfigBucket
    });

    // create lambda from code from resources/lambda/ directory
    const handler = new lambda.Function(this, "AmplifyRemoteLogging-Handler", {
      runtime: lambda.Runtime.NODEJS_18_X,
      code: lambda.Code.fromAsset(path.dirname(path.join(lambdaConfig))),
      handler: "remotelogging.main",
      environment: {
        BUCKET: remoteConfigBucket.bucketName,
        KEY: configFileName
      }
    })

    // grant lambda read access to s3
    remoteConfigBucket.grantRead(handler)

    // create API Gateway
    const api = new apigateway.RestApi(this, "AmplifyRemoteLogging-API", {
      restApiName: "Logging API",
      description: "API Gateway for Remote Logging"
    })

    // hook up API Gateway to lambda handler at GET/loggingconstraints
    const getRemoteLoggingIntegration = new apigateway.LambdaIntegration(handler)
    const loggingConstraints = api.root.addResource('loggingconstraints')
    const getLoggingConstraints = loggingConstraints.addMethod('GET', getRemoteLoggingIntegration, {
      authorizationType: apigateway.AuthorizationType.IAM
    })

    // create and add IAM policy for api invoke to roles
    const apiInvokePolicy = new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      resources: [ getLoggingConstraints.methodArn ],
      actions: ['execute-api:Invoke']
    })

    authRole.addToPrincipalPolicy(apiInvokePolicy)
    unAuthRole.addToPrincipalPolicy(apiInvokePolicy)

  }
}
```

## Sample Lambda handler
Below is a sample lambda that reads and returns the `remoteloggingconstraints.json` from AWS S3.

```js
const { S3Client, GetObjectCommand } = require("@aws-sdk/client-s3")
const s3 = new S3Client({})
const bucketName = process.env.BUCKET
const key = process.env.KEY
let cachedConfig = {
    expiresOn: 0, 
    ETag: '', 
    config: ''
}

exports.main = async function(event, context) {
  try {
    if (event.httpMethod === "GET") {
      if (!cachedConfig.config || Date.now() > cachedConfig.expiresOn) {
        // refresh cache if cache is invalid
        const command = new GetObjectCommand({ Bucket: bucketName, Key: key })
        const s3Resp = await s3.send(command)
        await setCachedConfig(s3Resp)
      }

      if (event.headers['If-None-Match'] === cachedConfig.ETag) {
        // return 304 not modified if config has not changed
        return {
          statusCode: 304,
        }
      } else {
        // return updated/modified config with latest ETag
        return {
          statusCode: 200,
          headers: {"'If-None-Match'": cachedConfig.ETag },
          body: cachedConfig.config
        }
      }
    }
  } catch(error) {
    const resp = error.stack || JSON.stringify(error, null, 2)
    return {
      statusCode: 400,
        headers: {},
        body: JSON.stringify(resp)
    }
  }
}

const setCachedConfig = async (s3Resp) => {
  cachedConfig = {
    expiresOn: Date.now() + 600 * 1000, //10 minutes
    ETag: s3Resp.ETag.replace(/\"/gi, ''), //remove \" from string
    config: await s3Resp.Body.transformToString()
  }
}
```

## Sample `remoteloggingconstraints.json`
Below is a sample remote config file that overwrites the local file in the mobile application.

```json
{
    "defaultLogLevel": "ERROR",
    "categoryLogLevel": {
        "API": "DEBUG",
        "AUTH": "DEBUG",
    },
    "userLogLevel": {
        "cognito-sub-xyz-123": {
            "defaultLogLevel": "VERBOSE",
            "categoryLogLevel": {
                "API": "VERBOSE",
                "AUTH": "VERBOSE",
            }
        }
    }
}

```