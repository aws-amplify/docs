## Distributed data

When working with distributed data, it is important to be mindful about the state of the local and the remote systems. DataStore tries to make that as simple as possible for you; however, some scenarios might require some consideration.

For instance, when updating or deleting data, one has to consider that the state of the local data might be out-of-sync with the backend. This scenario can affect how conditions should be implemented.

### Update and delete with predicate

For such scenarios both the `save()` and the `delete()` APIs support an optional predicate which will be sent to the backend and executed against the remote state.

import js0 from "/src/fragments/lib/datastore/js/sync/20-savePredicate.mdx";

<Fragments fragments={{js: js0}} />

import ios1 from "/src/fragments/lib/datastore/ios/sync/20-savePredicate.mdx";

<Fragments fragments={{ios: ios1}} />

import android2 from "/src/fragments/lib/datastore/android/sync/20-savePredicate.mdx";

<Fragments fragments={{android: android2}} />

There's a difference between the traditional local condition check using `if/else` constructs and the predicate in the aforementioned APIs as you can see in the example below.

import js3 from "/src/fragments/lib/datastore/js/sync/30-savePredicateComparison.mdx";

<Fragments fragments={{js: js3}} />

import ios4 from "/src/fragments/lib/datastore/ios/sync/30-savePredicateComparison.mdx";

<Fragments fragments={{ios: ios4}} />

import android5 from "/src/fragments/lib/datastore/android/sync/30-savePredicateComparison.mdx";

<Fragments fragments={{android: android5}} />

### Conflict detection and resolution

When concurrently updating the data in multiple places, it is likely that some conflict might happen. For most of the cases the default *Auto-merge* algorithm should be able to resolve conflicts. However, there are scenarios where the algorithm won't be able to be resolved, and in these cases, a more advanced option is available and will be described in detail in the next section.
