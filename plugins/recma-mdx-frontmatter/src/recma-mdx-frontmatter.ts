import { fromJs } from 'esast-util-from-js';
import { visit } from 'estree-util-visit';
import { createGetStaticPaths } from './create-get-static-paths.js';
import type {
  DynamicRoutePart,
  DynamicRouteFrontmatterConfig
} from './dynamic-routes.js';
import type { Program, Property } from 'estree';

/**
 * Plugin options for `recmaMdxFrontmatter`
 */
type RecmaMdxFrontmatterOptions = {
  /**
   * Name of the node to look for (e.g. the one created by remark-frontmatter)
   * @default "frontmatter"
   */
  name: string;
  /**
   * Next.js dynamic routes to configure. This is used to generate getStaticPaths where necessary
   */
  dynamicRoutes?: Record<DynamicRoutePart, DynamicRouteFrontmatterConfig>;
};

/**
 * Plugin to pass frontmatter to getStaticProps and into MDXProvider's `wrapper`.
 * This is meant to be used alongside `remark-frontmatter`
 * @param options
 * @type {import('unified').Plugin<[RecmaMdxFrontmatterOptions], import('estree').Program>}
 * @returns Next.js page getStaticProps with frontmatter data
 */
export function recmaMdxFrontmatter(options: RecmaMdxFrontmatterOptions) {
  const { name = 'frontmatter', dynamicRoutes } = options || {};
  /**
   * Transformer
   */
  const transformer = (tree: Program) => {
    const frontmatter: Record<string, unknown> = {};
    // collect frontmatter generated by `remark-mdx-frontmatter`
    visit(tree, (node) => {
      // look for `export const frontmatter = { /*...*/ }`
      if (
        node.type === 'VariableDeclarator' &&
        'name' in node.id &&
        node.id.name === name
      ) {
        if (
          node.init &&
          'type' in node.init &&
          node.init.type === 'ObjectExpression'
        ) {
          if (!Array.isArray(node.init.properties)) return;
          // collect frontmatter props
          for (const prop of node.init.properties as Property[]) {
            if (
              prop.key.type === 'Literal' &&
              typeof prop.key.value === 'string'
            ) {
              // this only supports array values and literals, no functions, objects, or other expressions
              switch (prop.value.type) {
                case 'ArrayExpression': {
                  const key = prop.key.value;
                  const value = prop.value.elements
                    .filter((element) => element?.type === 'Literal')
                    // @ts-expect-error - we know this is an array of literals
                    .map((element) => element!.value);
                  // set the array value
                  frontmatter[key] = value;
                  break;
                }
                case 'Literal': {
                  if (prop.value.type === 'Literal') {
                    frontmatter[prop.key.value] = prop.value.value;
                  }
                  break;
                }
                default: {
                  break;
                }
              }
            }
          }
          return;
        }
      }
    });
    // create `getStaticProps` to feed frontmatter to MDXProvider's `wrapper`
    const getStaticProps = fromJs(
      `
      export const getStaticProps = async () => {
        return {
          props: {
            frontmatter: ${JSON.stringify(frontmatter)}
          }
        }
      }
    `,
      {
        module: true
      }
    );
    // push `getStaticProps` to end of tree
    tree.body.push(...getStaticProps.body);

    if (dynamicRoutes) {
      const getStaticPaths = createGetStaticPaths(frontmatter, dynamicRoutes);
      if (getStaticPaths) tree.body.push(...getStaticPaths.body);
    }
  };

  return transformer;
}
